{"version":3,"file":"./p2p-engine.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/gCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC59BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrQA;AACA;AACA;AAIA;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;;;;;;;;;;;;;;;;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://P2pEngineHls/webpack/universalModuleDefinition","webpack://P2pEngineHls/./node_modules/_events@3.3.0@events/events.js","webpack://P2pEngineHls/./node_modules/_reconnecting-websocket@4.4.0@reconnecting-websocket/dist/reconnecting-websocket-mjs.js","webpack://P2pEngineHls/./node_modules/_url-toolkit@2.2.5@url-toolkit/src/url-toolkit.js","webpack://P2pEngineHls/./src/common/hls/attr-list.js","webpack://P2pEngineHls/./src/common/hls/codecs.js","webpack://P2pEngineHls/./src/common/hls/fragment.js","webpack://P2pEngineHls/./src/common/hls/level-key.js","webpack://P2pEngineHls/./src/common/hls/level.js","webpack://P2pEngineHls/./src/common/hls/m3u8-parser.js","webpack://P2pEngineHls/./src/common/hls/ts-validator.js","webpack://P2pEngineHls/./src/common/idb-keyval/index.js","webpack://P2pEngineHls/./src/core/config.js","webpack://P2pEngineHls/./src/core/engine-base.js","webpack://P2pEngineHls/./src/core/events.js","webpack://P2pEngineHls/./src/core/peer-channel.js","webpack://P2pEngineHls/./src/core/peer-manager.js","webpack://P2pEngineHls/./src/core/peer.js","webpack://P2pEngineHls/./src/core/scheduler-base.js","webpack://P2pEngineHls/./src/core/sdp/index.js","webpack://P2pEngineHls/./src/core/sdp/pack.js","webpack://P2pEngineHls/./src/core/sdp/unpack.js","webpack://P2pEngineHls/./src/core/sdp/util.js","webpack://P2pEngineHls/./src/core/segment.js","webpack://P2pEngineHls/./src/core/server.js","webpack://P2pEngineHls/./src/core/signal-manager.js","webpack://P2pEngineHls/./src/core/tracker-client.js","webpack://P2pEngineHls/./src/core/utils/buffer.js","webpack://P2pEngineHls/./src/core/utils/err-code.js","webpack://P2pEngineHls/./src/core/utils/getPeersThrottle.js","webpack://P2pEngineHls/./src/core/utils/logger.js","webpack://P2pEngineHls/./src/core/utils/md5.js","webpack://P2pEngineHls/./src/core/utils/mse.js","webpack://P2pEngineHls/./src/core/utils/platform.js","webpack://P2pEngineHls/./src/core/utils/player-detector.js","webpack://P2pEngineHls/./src/core/utils/queue-microtask.js","webpack://P2pEngineHls/./src/core/utils/storage.js","webpack://P2pEngineHls/./src/core/utils/tool-funs.js","webpack://P2pEngineHls/./src/core/websocket-client.js","webpack://P2pEngineHls/./src/hls-next/common/bitcounts-manager.js","webpack://P2pEngineHls/./src/hls-next/common/bitset-manager.js","webpack://P2pEngineHls/./src/hls-next/common/engine.js","webpack://P2pEngineHls/./src/hls-next/common/requesting-map.js","webpack://P2pEngineHls/./src/hls-next/common/scheduler.js","webpack://P2pEngineHls/./src/hls-next/common/segment-cache.js","webpack://P2pEngineHls/./src/hls-next/common/segment-state.js","webpack://P2pEngineHls/./src/hls-next/common/segment-store.js","webpack://P2pEngineHls/./src/hls-next/common/synthesizer.js","webpack://P2pEngineHls/./src/hls-next/common/utils/tool-funs.js","webpack://P2pEngineHls/./src/hls-next/config.js","webpack://P2pEngineHls/./src/hls-next/events.js","webpack://P2pEngineHls/./src/hls-next/hls-sw.p2pengine.js","webpack://P2pEngineHls/./src/hls-next/hls-sw/scheduler.js","webpack://P2pEngineHls/./src/hls-next/hlsjs.p2pengine.js","webpack://P2pEngineHls/./src/hls-next/hlsjs/frag-loader.js","webpack://P2pEngineHls/./src/hls-next/hlsjs/playlist-loader.js","webpack://P2pEngineHls/./src/hls-next/hlsjs/scheduler.js","webpack://P2pEngineHls/./src/hls-next/hlsjs/utils/fake-xhr.js","webpack://P2pEngineHls/./src/hls-next/hlsjs/utils/fetch-loader.js","webpack://P2pEngineHls/./src/hls-next/hlsjs/utils/segment-builder.js","webpack://P2pEngineHls/./src/hls-next/hlsjs/utils/tool-funs.js","webpack://P2pEngineHls/./src/hls-next/shadow.p2pengine.js","webpack://P2pEngineHls/webpack/bootstrap","webpack://P2pEngineHls/webpack/runtime/compat get default export","webpack://P2pEngineHls/webpack/runtime/define property getters","webpack://P2pEngineHls/webpack/runtime/global","webpack://P2pEngineHls/webpack/runtime/hasOwnProperty shorthand","webpack://P2pEngineHls/webpack/runtime/make namespace object","webpack://P2pEngineHls/./src/hls-next/index.engine.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"P2pEngineHls\"] = factory();\n\telse\n\t\troot[\"P2pEngineHls\"] = factory();\n})(self, () => {\nreturn ","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\nvar Event = /** @class */ (function () {\r\n    function Event(type, target) {\r\n        this.target = target;\r\n        this.type = type;\r\n    }\r\n    return Event;\r\n}());\r\nvar ErrorEvent = /** @class */ (function (_super) {\r\n    __extends(ErrorEvent, _super);\r\n    function ErrorEvent(error, target) {\r\n        var _this = _super.call(this, 'error', target) || this;\r\n        _this.message = error.message;\r\n        _this.error = error;\r\n        return _this;\r\n    }\r\n    return ErrorEvent;\r\n}(Event));\r\nvar CloseEvent = /** @class */ (function (_super) {\r\n    __extends(CloseEvent, _super);\r\n    function CloseEvent(code, reason, target) {\r\n        if (code === void 0) { code = 1000; }\r\n        if (reason === void 0) { reason = ''; }\r\n        var _this = _super.call(this, 'close', target) || this;\r\n        _this.wasClean = true;\r\n        _this.code = code;\r\n        _this.reason = reason;\r\n        return _this;\r\n    }\r\n    return CloseEvent;\r\n}(Event));\n\n/*!\r\n * Reconnecting WebSocket\r\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\r\n * https://github.com/pladaria/reconnecting-websocket\r\n * License MIT\r\n */\r\nvar getGlobalWebSocket = function () {\r\n    if (typeof WebSocket !== 'undefined') {\r\n        // @ts-ignore\r\n        return WebSocket;\r\n    }\r\n};\r\n/**\r\n * Returns true if given argument looks like a WebSocket class\r\n */\r\nvar isWebSocket = function (w) { return typeof w !== 'undefined' && !!w && w.CLOSING === 2; };\r\nvar DEFAULT = {\r\n    maxReconnectionDelay: 10000,\r\n    minReconnectionDelay: 1000 + Math.random() * 4000,\r\n    minUptime: 5000,\r\n    reconnectionDelayGrowFactor: 1.3,\r\n    connectionTimeout: 4000,\r\n    maxRetries: Infinity,\r\n    maxEnqueuedMessages: Infinity,\r\n    startClosed: false,\r\n    debug: false,\r\n};\r\nvar ReconnectingWebSocket = /** @class */ (function () {\r\n    function ReconnectingWebSocket(url, protocols, options) {\r\n        var _this = this;\r\n        if (options === void 0) { options = {}; }\r\n        this._listeners = {\r\n            error: [],\r\n            message: [],\r\n            open: [],\r\n            close: [],\r\n        };\r\n        this._retryCount = -1;\r\n        this._shouldReconnect = true;\r\n        this._connectLock = false;\r\n        this._binaryType = 'blob';\r\n        this._closeCalled = false;\r\n        this._messageQueue = [];\r\n        /**\r\n         * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\r\n         */\r\n        this.onclose = null;\r\n        /**\r\n         * An event listener to be called when an error occurs\r\n         */\r\n        this.onerror = null;\r\n        /**\r\n         * An event listener to be called when a message is received from the server\r\n         */\r\n        this.onmessage = null;\r\n        /**\r\n         * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\r\n         * this indicates that the connection is ready to send and receive data\r\n         */\r\n        this.onopen = null;\r\n        this._handleOpen = function (event) {\r\n            _this._debug('open event');\r\n            var _a = _this._options.minUptime, minUptime = _a === void 0 ? DEFAULT.minUptime : _a;\r\n            clearTimeout(_this._connectTimeout);\r\n            _this._uptimeTimeout = setTimeout(function () { return _this._acceptOpen(); }, minUptime);\r\n            _this._ws.binaryType = _this._binaryType;\r\n            // send enqueued messages (messages sent before websocket open event)\r\n            _this._messageQueue.forEach(function (message) { return _this._ws.send(message); });\r\n            _this._messageQueue = [];\r\n            if (_this.onopen) {\r\n                _this.onopen(event);\r\n            }\r\n            _this._listeners.open.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n        };\r\n        this._handleMessage = function (event) {\r\n            _this._debug('message event');\r\n            if (_this.onmessage) {\r\n                _this.onmessage(event);\r\n            }\r\n            _this._listeners.message.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n        };\r\n        this._handleError = function (event) {\r\n            _this._debug('error event', event.message);\r\n            _this._disconnect(undefined, event.message === 'TIMEOUT' ? 'timeout' : undefined);\r\n            if (_this.onerror) {\r\n                _this.onerror(event);\r\n            }\r\n            _this._debug('exec error listeners');\r\n            _this._listeners.error.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n            _this._connect();\r\n        };\r\n        this._handleClose = function (event) {\r\n            _this._debug('close event');\r\n            _this._clearTimeouts();\r\n            if (_this._shouldReconnect) {\r\n                _this._connect();\r\n            }\r\n            if (_this.onclose) {\r\n                _this.onclose(event);\r\n            }\r\n            _this._listeners.close.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n        };\r\n        this._url = url;\r\n        this._protocols = protocols;\r\n        this._options = options;\r\n        if (this._options.startClosed) {\r\n            this._shouldReconnect = false;\r\n        }\r\n        this._connect();\r\n    }\r\n    Object.defineProperty(ReconnectingWebSocket, \"CONNECTING\", {\r\n        get: function () {\r\n            return 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket, \"OPEN\", {\r\n        get: function () {\r\n            return 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket, \"CLOSING\", {\r\n        get: function () {\r\n            return 2;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket, \"CLOSED\", {\r\n        get: function () {\r\n            return 3;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"CONNECTING\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.CONNECTING;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"OPEN\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.OPEN;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"CLOSING\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.CLOSING;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"CLOSED\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.CLOSED;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"binaryType\", {\r\n        get: function () {\r\n            return this._ws ? this._ws.binaryType : this._binaryType;\r\n        },\r\n        set: function (value) {\r\n            this._binaryType = value;\r\n            if (this._ws) {\r\n                this._ws.binaryType = value;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"retryCount\", {\r\n        /**\r\n         * Returns the number or connection retries\r\n         */\r\n        get: function () {\r\n            return Math.max(this._retryCount, 0);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"bufferedAmount\", {\r\n        /**\r\n         * The number of bytes of data that have been queued using calls to send() but not yet\r\n         * transmitted to the network. This value resets to zero once all queued data has been sent.\r\n         * This value does not reset to zero when the connection is closed; if you keep calling send(),\r\n         * this will continue to climb. Read only\r\n         */\r\n        get: function () {\r\n            var bytes = this._messageQueue.reduce(function (acc, message) {\r\n                if (typeof message === 'string') {\r\n                    acc += message.length; // not byte size\r\n                }\r\n                else if (message instanceof Blob) {\r\n                    acc += message.size;\r\n                }\r\n                else {\r\n                    acc += message.byteLength;\r\n                }\r\n                return acc;\r\n            }, 0);\r\n            return bytes + (this._ws ? this._ws.bufferedAmount : 0);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"extensions\", {\r\n        /**\r\n         * The extensions selected by the server. This is currently only the empty string or a list of\r\n         * extensions as negotiated by the connection\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.extensions : '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"protocol\", {\r\n        /**\r\n         * A string indicating the name of the sub-protocol the server selected;\r\n         * this will be one of the strings specified in the protocols parameter when creating the\r\n         * WebSocket object\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.protocol : '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"readyState\", {\r\n        /**\r\n         * The current state of the connection; this is one of the Ready state constants\r\n         */\r\n        get: function () {\r\n            if (this._ws) {\r\n                return this._ws.readyState;\r\n            }\r\n            return this._options.startClosed\r\n                ? ReconnectingWebSocket.CLOSED\r\n                : ReconnectingWebSocket.CONNECTING;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"url\", {\r\n        /**\r\n         * The URL as resolved by the constructor\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.url : '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Closes the WebSocket connection or connection attempt, if any. If the connection is already\r\n     * CLOSED, this method does nothing\r\n     */\r\n    ReconnectingWebSocket.prototype.close = function (code, reason) {\r\n        if (code === void 0) { code = 1000; }\r\n        this._closeCalled = true;\r\n        this._shouldReconnect = false;\r\n        this._clearTimeouts();\r\n        if (!this._ws) {\r\n            this._debug('close enqueued: no ws instance');\r\n            return;\r\n        }\r\n        if (this._ws.readyState === this.CLOSED) {\r\n            this._debug('close: already closed');\r\n            return;\r\n        }\r\n        this._ws.close(code, reason);\r\n    };\r\n    /**\r\n     * Closes the WebSocket connection or connection attempt and connects again.\r\n     * Resets retry counter;\r\n     */\r\n    ReconnectingWebSocket.prototype.reconnect = function (code, reason) {\r\n        this._shouldReconnect = true;\r\n        this._closeCalled = false;\r\n        this._retryCount = -1;\r\n        if (!this._ws || this._ws.readyState === this.CLOSED) {\r\n            this._connect();\r\n        }\r\n        else {\r\n            this._disconnect(code, reason);\r\n            this._connect();\r\n        }\r\n    };\r\n    /**\r\n     * Enqueue specified data to be transmitted to the server over the WebSocket connection\r\n     */\r\n    ReconnectingWebSocket.prototype.send = function (data) {\r\n        if (this._ws && this._ws.readyState === this.OPEN) {\r\n            this._debug('send', data);\r\n            this._ws.send(data);\r\n        }\r\n        else {\r\n            var _a = this._options.maxEnqueuedMessages, maxEnqueuedMessages = _a === void 0 ? DEFAULT.maxEnqueuedMessages : _a;\r\n            if (this._messageQueue.length < maxEnqueuedMessages) {\r\n                this._debug('enqueue', data);\r\n                this._messageQueue.push(data);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Register an event handler of a specific event type\r\n     */\r\n    ReconnectingWebSocket.prototype.addEventListener = function (type, listener) {\r\n        if (this._listeners[type]) {\r\n            // @ts-ignore\r\n            this._listeners[type].push(listener);\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype.dispatchEvent = function (event) {\r\n        var e_1, _a;\r\n        var listeners = this._listeners[event.type];\r\n        if (listeners) {\r\n            try {\r\n                for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {\r\n                    var listener = listeners_1_1.value;\r\n                    this._callEventListener(event, listener);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Removes an event listener\r\n     */\r\n    ReconnectingWebSocket.prototype.removeEventListener = function (type, listener) {\r\n        if (this._listeners[type]) {\r\n            // @ts-ignore\r\n            this._listeners[type] = this._listeners[type].filter(function (l) { return l !== listener; });\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._debug = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (this._options.debug) {\r\n            // not using spread because compiled version uses Symbols\r\n            // tslint:disable-next-line\r\n            console.log.apply(console, __spread(['RWS>'], args));\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._getNextDelay = function () {\r\n        var _a = this._options, _b = _a.reconnectionDelayGrowFactor, reconnectionDelayGrowFactor = _b === void 0 ? DEFAULT.reconnectionDelayGrowFactor : _b, _c = _a.minReconnectionDelay, minReconnectionDelay = _c === void 0 ? DEFAULT.minReconnectionDelay : _c, _d = _a.maxReconnectionDelay, maxReconnectionDelay = _d === void 0 ? DEFAULT.maxReconnectionDelay : _d;\r\n        var delay = 0;\r\n        if (this._retryCount > 0) {\r\n            delay =\r\n                minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);\r\n            if (delay > maxReconnectionDelay) {\r\n                delay = maxReconnectionDelay;\r\n            }\r\n        }\r\n        this._debug('next delay', delay);\r\n        return delay;\r\n    };\r\n    ReconnectingWebSocket.prototype._wait = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            setTimeout(resolve, _this._getNextDelay());\r\n        });\r\n    };\r\n    ReconnectingWebSocket.prototype._getNextUrl = function (urlProvider) {\r\n        if (typeof urlProvider === 'string') {\r\n            return Promise.resolve(urlProvider);\r\n        }\r\n        if (typeof urlProvider === 'function') {\r\n            var url = urlProvider();\r\n            if (typeof url === 'string') {\r\n                return Promise.resolve(url);\r\n            }\r\n            if (!!url.then) {\r\n                return url;\r\n            }\r\n        }\r\n        throw Error('Invalid URL');\r\n    };\r\n    ReconnectingWebSocket.prototype._connect = function () {\r\n        var _this = this;\r\n        if (this._connectLock || !this._shouldReconnect) {\r\n            return;\r\n        }\r\n        this._connectLock = true;\r\n        var _a = this._options, _b = _a.maxRetries, maxRetries = _b === void 0 ? DEFAULT.maxRetries : _b, _c = _a.connectionTimeout, connectionTimeout = _c === void 0 ? DEFAULT.connectionTimeout : _c, _d = _a.WebSocket, WebSocket = _d === void 0 ? getGlobalWebSocket() : _d;\r\n        if (this._retryCount >= maxRetries) {\r\n            this._debug('max retries reached', this._retryCount, '>=', maxRetries);\r\n            return;\r\n        }\r\n        this._retryCount++;\r\n        this._debug('connect', this._retryCount);\r\n        this._removeListeners();\r\n        if (!isWebSocket(WebSocket)) {\r\n            throw Error('No valid WebSocket class provided');\r\n        }\r\n        this._wait()\r\n            .then(function () { return _this._getNextUrl(_this._url); })\r\n            .then(function (url) {\r\n            // close could be called before creating the ws\r\n            if (_this._closeCalled) {\r\n                return;\r\n            }\r\n            _this._debug('connect', { url: url, protocols: _this._protocols });\r\n            _this._ws = _this._protocols\r\n                ? new WebSocket(url, _this._protocols)\r\n                : new WebSocket(url);\r\n            _this._ws.binaryType = _this._binaryType;\r\n            _this._connectLock = false;\r\n            _this._addListeners();\r\n            _this._connectTimeout = setTimeout(function () { return _this._handleTimeout(); }, connectionTimeout);\r\n        });\r\n    };\r\n    ReconnectingWebSocket.prototype._handleTimeout = function () {\r\n        this._debug('timeout event');\r\n        this._handleError(new ErrorEvent(Error('TIMEOUT'), this));\r\n    };\r\n    ReconnectingWebSocket.prototype._disconnect = function (code, reason) {\r\n        if (code === void 0) { code = 1000; }\r\n        this._clearTimeouts();\r\n        if (!this._ws) {\r\n            return;\r\n        }\r\n        this._removeListeners();\r\n        try {\r\n            this._ws.close(code, reason);\r\n            this._handleClose(new CloseEvent(code, reason, this));\r\n        }\r\n        catch (error) {\r\n            // ignore\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._acceptOpen = function () {\r\n        this._debug('accept open');\r\n        this._retryCount = 0;\r\n    };\r\n    ReconnectingWebSocket.prototype._callEventListener = function (event, listener) {\r\n        if ('handleEvent' in listener) {\r\n            // @ts-ignore\r\n            listener.handleEvent(event);\r\n        }\r\n        else {\r\n            // @ts-ignore\r\n            listener(event);\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._removeListeners = function () {\r\n        if (!this._ws) {\r\n            return;\r\n        }\r\n        this._debug('removeListeners');\r\n        this._ws.removeEventListener('open', this._handleOpen);\r\n        this._ws.removeEventListener('close', this._handleClose);\r\n        this._ws.removeEventListener('message', this._handleMessage);\r\n        // @ts-ignore\r\n        this._ws.removeEventListener('error', this._handleError);\r\n    };\r\n    ReconnectingWebSocket.prototype._addListeners = function () {\r\n        if (!this._ws) {\r\n            return;\r\n        }\r\n        this._debug('addListeners');\r\n        this._ws.addEventListener('open', this._handleOpen);\r\n        this._ws.addEventListener('close', this._handleClose);\r\n        this._ws.addEventListener('message', this._handleMessage);\r\n        // @ts-ignore\r\n        this._ws.addEventListener('error', this._handleError);\r\n    };\r\n    ReconnectingWebSocket.prototype._clearTimeouts = function () {\r\n        clearTimeout(this._connectTimeout);\r\n        clearTimeout(this._uptimeTimeout);\r\n    };\r\n    return ReconnectingWebSocket;\r\n}());\n\nexport default ReconnectingWebSocket;\n","// see https://tools.ietf.org/html/rfc1808\n\n(function (root) {\n  var URL_REGEX =\n    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n  var URLToolkit = {\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n    // E.g\n    // With opts.alwaysNormalize = false (default, spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n    // With opts.alwaysNormalize = true (not spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n      opts = opts || {};\n      // remove any remaining space and CRLF\n      baseURL = baseURL.trim();\n      relativeURL = relativeURL.trim();\n      if (!relativeURL) {\n        // 2a) If the embedded URL is entirely empty, it inherits the\n        // entire base URL (i.e., is set equal to the base URL)\n        // and we are done.\n        if (!opts.alwaysNormalize) {\n          return baseURL;\n        }\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n        if (!basePartsForNormalise) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        basePartsForNormalise.path = URLToolkit.normalizePath(\n          basePartsForNormalise.path\n        );\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n      }\n      var relativeParts = URLToolkit.parseURL(relativeURL);\n      if (!relativeParts) {\n        throw new Error('Error trying to parse relative URL.');\n      }\n      if (relativeParts.scheme) {\n        // 2b) If the embedded URL starts with a scheme name, it is\n        // interpreted as an absolute URL and we are done.\n        if (!opts.alwaysNormalize) {\n          return relativeURL;\n        }\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n        return URLToolkit.buildURLFromParts(relativeParts);\n      }\n      var baseParts = URLToolkit.parseURL(baseURL);\n      if (!baseParts) {\n        throw new Error('Error trying to parse base URL.');\n      }\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n        baseParts.netLoc = pathParts[1];\n        baseParts.path = pathParts[2];\n      }\n      if (baseParts.netLoc && !baseParts.path) {\n        baseParts.path = '/';\n      }\n      var builtParts = {\n        // 2c) Otherwise, the embedded URL inherits the scheme of\n        // the base URL.\n        scheme: baseParts.scheme,\n        netLoc: relativeParts.netLoc,\n        path: null,\n        params: relativeParts.params,\n        query: relativeParts.query,\n        fragment: relativeParts.fragment,\n      };\n      if (!relativeParts.netLoc) {\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n        // (if any) of the base URL.\n        builtParts.netLoc = baseParts.netLoc;\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\n        // path is not relative and we skip to Step 7.\n        if (relativeParts.path[0] !== '/') {\n          if (!relativeParts.path) {\n            // 5) If the embedded URL path is empty (and not preceded by a\n            // slash), then the embedded URL inherits the base URL path\n            builtParts.path = baseParts.path;\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\n            // step 7; otherwise, it inherits the <params> of the base\n            // URL (if any) and\n            if (!relativeParts.params) {\n              builtParts.params = baseParts.params;\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <query> of the base\n              // URL (if any) and we skip to step 7.\n              if (!relativeParts.query) {\n                builtParts.query = baseParts.query;\n              }\n            }\n          } else {\n            // 6) The last segment of the base URL's path (anything\n            // following the rightmost slash \"/\", or the entire path if no\n            // slash is present) is removed and the embedded URL's path is\n            // appended in its place.\n            var baseURLPath = baseParts.path;\n            var newPath =\n              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n              relativeParts.path;\n            builtParts.path = URLToolkit.normalizePath(newPath);\n          }\n        }\n      }\n      if (builtParts.path === null) {\n        builtParts.path = opts.alwaysNormalize\n          ? URLToolkit.normalizePath(relativeParts.path)\n          : relativeParts.path;\n      }\n      return URLToolkit.buildURLFromParts(builtParts);\n    },\n    parseURL: function (url) {\n      var parts = URL_REGEX.exec(url);\n      if (!parts) {\n        return null;\n      }\n      return {\n        scheme: parts[1] || '',\n        netLoc: parts[2] || '',\n        path: parts[3] || '',\n        params: parts[4] || '',\n        query: parts[5] || '',\n        fragment: parts[6] || '',\n      };\n    },\n    normalizePath: function (path) {\n      // The following operations are\n      // then applied, in order, to the new path:\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\n      // segment, are removed.\n      // 6b) If the path ends with \".\" as a complete path segment,\n      // that \".\" is removed.\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n      // complete path segment not equal to \"..\", are removed.\n      // Removal of these path segments is performed iteratively,\n      // removing the leftmost matching pattern on each iteration,\n      // until no matching pattern remains.\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n      // complete path segment not equal to \"..\", that\n      // \"<segment>/..\" is removed.\n      while (\n        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n      ) {}\n      return path.split('').reverse().join('');\n    },\n    buildURLFromParts: function (parts) {\n      return (\n        parts.scheme +\n        parts.netLoc +\n        parts.path +\n        parts.params +\n        parts.query +\n        parts.fragment\n      );\n    },\n  };\n\n  if (typeof exports === 'object' && typeof module === 'object')\n    module.exports = URLToolkit;\n  else if (typeof define === 'function' && define.amd)\n    define([], function () {\n      return URLToolkit;\n    });\n  else if (typeof exports === 'object') exports['URLToolkit'] = URLToolkit;\n  else root['URLToolkit'] = URLToolkit;\n})(this);\n","const DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/; // eslint-disable-line no-useless-escape\nconst ATTR_LIST_REGEX = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nclass AttrList {\n  constructor (attrs) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n\n    for (let attr in attrs) {\n      if (attrs.hasOwnProperty(attr)) {\n        this[attr] = attrs[attr];\n      }\n    }\n  }\n\n  decimalInteger (attrName) {\n    const intValue = parseInt(this[attrName], 10);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n\n    return intValue;\n  }\n\n  hexadecimalInteger (attrName) {\n    if (this[attrName]) {\n      let stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = ((stringValue.length & 1) ? '0' : '') + stringValue;\n\n      const value = new Uint8Array(stringValue.length / 2);\n      for (let i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n\n      return value;\n    } else {\n      return null;\n    }\n  }\n\n  hexadecimalIntegerAsNumber (attrName) {\n    const intValue = parseInt(this[attrName], 16);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n\n    return intValue;\n  }\n\n  decimalFloatingPoint (attrName) {\n    return parseFloat(this[attrName]);\n  }\n\n  enumeratedString (attrName) {\n    return this[attrName];\n  }\n\n  decimalResolution (attrName) {\n    const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n    if (res === null) {\n      return undefined;\n    }\n\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  }\n\n  static parseAttrList (input) {\n    let match, attrs = {};\n    ATTR_LIST_REGEX.lastIndex = 0;\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      let value = match[2], quote = '\"';\n\n      if (value.indexOf(quote) === 0 &&\n          value.lastIndexOf(quote) === (value.length - 1)) {\n        value = value.slice(1, -1);\n      }\n\n      attrs[match[1]] = value;\n    }\n    return attrs;\n  }\n}\n\nexport default AttrList;\n","// from http://mp4ra.org/codecs.html\nconst sampleEntryCodesISO = {\n  audio: {\n    'a3ds': true,\n    'ac-3': true,\n    'ac-4': true,\n    'alac': true,\n    'alaw': true,\n    'dra1': true,\n    'dts+': true,\n    'dts-': true,\n    'dtsc': true,\n    'dtse': true,\n    'dtsh': true,\n    'ec-3': true,\n    'enca': true,\n    'g719': true,\n    'g726': true,\n    'm4ae': true,\n    'mha1': true,\n    'mha2': true,\n    'mhm1': true,\n    'mhm2': true,\n    'mlpa': true,\n    'mp4a': true,\n    'raw ': true,\n    'Opus': true,\n    'samr': true,\n    'sawb': true,\n    'sawp': true,\n    'sevc': true,\n    'sqcp': true,\n    'ssmv': true,\n    'twos': true,\n    'ulaw': true\n  },\n  video: {\n    'avc1': true,\n    'avc2': true,\n    'avc3': true,\n    'avc4': true,\n    'avcp': true,\n    'drac': true,\n    'dvav': true,\n    'dvhe': true,\n    'encv': true,\n    'hev1': true,\n    'hvc1': true,\n    'mjp2': true,\n    'mp4v': true,\n    'mvc1': true,\n    'mvc2': true,\n    'mvc3': true,\n    'mvc4': true,\n    'resv': true,\n    'rv60': true,\n    's263': true,\n    'svc1': true,\n    'svc2': true,\n    'vc-1': true,\n    'vp08': true,\n    'vp09': true\n  }\n};\n\nfunction isCodecType (codec, type) {\n  const typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;\n}\n\nfunction isCodecSupportedInMp4 (codec, type) {\n  return window.MediaSource.isTypeSupported(`${type || 'video'}/mp4;codecs=\"${codec}\"`);\n}\n\nexport { isCodecType, isCodecSupportedInMp4 };\n","\nimport * as URLToolkit from 'url-toolkit';\n\nimport LevelKey from './level-key';\n\nexport default class Fragment {\n  constructor () {\n    this._url = null;\n    this._byteRange = null;\n    this._decryptdata = null;\n    this.tagList = [];\n    this.programDateTime = null;\n    this.rawProgramDateTime = null;\n\n    // Holds the types of data this fragment supports\n    this._elementaryStreams = {\n      [Fragment.ElementaryStreamTypes.AUDIO]: false,\n      [Fragment.ElementaryStreamTypes.VIDEO]: false\n    };\n  }\n\n  /**\n   * `type` property for this._elementaryStreams\n   *\n   * @enum\n   */\n  static get ElementaryStreamTypes () {\n    return {\n      AUDIO: 'audio',\n      VIDEO: 'video'\n    };\n  }\n\n  get url () {\n    if (!this._url && this.relurl) {\n      this._url = URLToolkit.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });\n    }\n\n    return this._url;\n  }\n\n  set url (value) {\n    this._url = value;\n  }\n\n  get byteRange () {\n    if (!this._byteRange && !this.rawByteRange) {\n      return [];\n    }\n\n    if (this._byteRange) {\n      return this._byteRange;\n    }\n\n    let byteRange = [];\n    if (this.rawByteRange) {\n      const params = this.rawByteRange.split('@', 2);\n      if (params.length === 1) {\n        const lastByteRangeEndOffset = this.lastByteRangeEndOffset;\n        byteRange[0] = lastByteRangeEndOffset || 0;\n      } else {\n        byteRange[0] = parseInt(params[1]);\n      }\n      byteRange[1] = parseInt(params[0]) + byteRange[0];\n      this._byteRange = byteRange;\n    }\n    return byteRange;\n  }\n\n  /**\n   * @type {number}\n   */\n  get byteRangeStartOffset () {\n    return this.byteRange[0];\n  }\n\n  get byteRangeEndOffset () {\n    return this.byteRange[1];\n  }\n\n  get decryptdata () {\n    if (!this._decryptdata) {\n      this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);\n    }\n\n    return this._decryptdata;\n  }\n\n  get endProgramDateTime () {\n    if (!Number.isFinite(this.programDateTime)) {\n      return null;\n    }\n\n    let duration = !Number.isFinite(this.duration) ? 0 : this.duration;\n\n    return this.programDateTime + (duration * 1000);\n  }\n\n  get encrypted () {\n    return !!((this.decryptdata && this.decryptdata.uri !== null) && (this.decryptdata.key === null));\n  }\n\n  /**\n   * @param {ElementaryStreamType} type\n   */\n  addElementaryStream (type) {\n    this._elementaryStreams[type] = true;\n  }\n\n  /**\n   * @param {ElementaryStreamType} type\n   */\n  hasElementaryStream (type) {\n    return this._elementaryStreams[type] === true;\n  }\n\n  /**\n   * Utility method for parseLevelPlaylist to create an initialization vector for a given segment\n   * @returns {Uint8Array}\n   */\n  createInitializationVector (segmentNumber) {\n    let uint8View = new Uint8Array(16);\n\n    for (let i = 12; i < 16; i++) {\n      uint8View[i] = (segmentNumber >> 8 * (15 - i)) & 0xff;\n    }\n\n    return uint8View;\n  }\n\n  /**\n   * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data\n   * @param levelkey - a playlist's encryption info\n   * @param segmentNumber - the fragment's segment number\n   * @returns {*} - an object to be applied as a fragment's decryptdata\n   */\n  fragmentDecryptdataFromLevelkey (levelkey, segmentNumber) {\n    let decryptdata = levelkey;\n\n    if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {\n      decryptdata = new LevelKey();\n      decryptdata.method = levelkey.method;\n      decryptdata.baseuri = levelkey.baseuri;\n      decryptdata.reluri = levelkey.reluri;\n      decryptdata.iv = this.createInitializationVector(segmentNumber);\n    }\n\n    return decryptdata;\n  }\n}\n","import * as URLToolkit from 'url-toolkit';\n\nexport default class LevelKey {\n  constructor () {\n    this.method = null;\n    this.key = null;\n    this.iv = null;\n    this._uri = null;\n  }\n\n  get uri () {\n    if (!this._uri && this.reluri) {\n      this._uri = URLToolkit.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });\n    }\n\n    return this._uri;\n  }\n}\n","export default class Level {\n  constructor (baseUrl) {\n    // Please keep properties in alphabetical order\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = [];\n    this.initSegment = null;\n    this.live = true;\n    this.needSidxRanges = false;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = baseUrl;\n    this.version = null;\n  }\n\n  get hasProgramDateTime () {\n    return !!(this.fragments[0] && Number.isFinite(this.fragments[0].programDateTime));\n  }\n}\n","import * as URLToolkit from 'url-toolkit';\n\nimport Fragment from './fragment';\nimport Level from './level';\nimport LevelKey from './level-key';\n\nimport AttrList from './attr-list';\nimport { isCodecType } from './codecs';\n\n/**\n * M3U8 parser\n * @module\n */\n\n// https://regex101.com is your friend\nconst MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\n\\r]*)[\\r\\n]+([^\\r\\n]+)/g;\nconst MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\n\nconst LEVEL_PLAYLIST_REGEX_FAST = new RegExp([\n  /#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n  /|(?!#)([\\S+ ?]+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)\n  /|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)\n  /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec\n  /|#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join(''), 'g');\n\nconst LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\\d+))|(?:#EXT-X-(TARGETDURATION): *(\\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\\r?\\n?/;\n\nconst MP4_REGEX_SUFFIX = /\\.(mp4|m4s|m4v|m4a)$/i;\n\nexport default class M3U8Parser {\n  static findGroup (groups, mediaGroupId) {\n    if (!groups) {\n      return null;\n    }\n\n    let matchingGroup = null;\n\n    for (let i = 0; i < groups.length; i++) {\n      const group = groups[i];\n      if (group.id === mediaGroupId) {\n        matchingGroup = group;\n      }\n    }\n\n    return matchingGroup;\n  }\n\n  static convertAVC1ToAVCOTI (codec) {\n    let result, avcdata = codec.split('.');\n    if (avcdata.length > 2) {\n      result = avcdata.shift() + '.';\n      result += parseInt(avcdata.shift()).toString(16);\n      result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);\n    } else {\n      result = codec;\n    }\n    return result;\n  }\n\n  static resolve (url, baseUrl) {\n    return URLToolkit.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });\n  }\n\n  static parseMasterPlaylist (string, baseurl) {\n    let levels = [], result;\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n\n    function setCodecs (codecs, level) {\n      ['video', 'audio'].forEach((type) => {\n        const filtered = codecs.filter((codec) => isCodecType(codec, type));\n        if (filtered.length) {\n          const preferred = filtered.filter((codec) => {\n            return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;\n          });\n          level[`${type}Codec`] = preferred.length > 0 ? preferred[0] : filtered[0];\n\n          // remove from list\n          codecs = codecs.filter((codec) => filtered.indexOf(codec) === -1);\n        }\n      });\n\n      level.unknownCodecs = codecs;\n    }\n\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      const level = {};\n\n      const attrs = level.attrs = new AttrList(result[1]);\n      level.url = M3U8Parser.resolve(result[2], baseurl);\n\n      const resolution = attrs.decimalResolution('RESOLUTION');\n      if (resolution) {\n        level.width = resolution.width;\n        level.height = resolution.height;\n      }\n      level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');\n      level.name = attrs.NAME;\n\n      setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);\n\n      if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {\n        level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);\n      }\n\n      levels.push(level);\n    }\n    return levels;\n  }\n\n  static parseMasterPlaylistMedia (string, baseurl, type, audioGroups = []) {\n    let result;\n    let medias = [];\n    let id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      const media = {};\n      const attrs = new AttrList(result[1]);\n      if (attrs.TYPE === type) {\n        media.groupId = attrs['GROUP-ID'];\n        media.name = attrs.NAME;\n        media.type = type;\n        media.default = (attrs.DEFAULT === 'YES');\n        media.autoselect = (attrs.AUTOSELECT === 'YES');\n        media.forced = (attrs.FORCED === 'YES');\n        if (attrs.URI) {\n          media.url = M3U8Parser.resolve(attrs.URI, baseurl);\n        }\n\n        media.lang = attrs.LANGUAGE;\n        if (!media.name) {\n          media.name = media.lang;\n        }\n\n        if (audioGroups.length) {\n          const groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);\n          media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;\n        }\n        media.id = id++;\n        medias.push(media);\n      }\n    }\n    return medias;\n  }\n\n  static parseLevelPlaylist (string, baseurl) {\n    let currentSN = 0;\n    let totalduration = 0;\n    let level = new Level(baseurl);\n    let levelkey = new LevelKey();\n    let cc = 0;\n    let prevFrag = null;\n    let frag = new Fragment();\n    let result;\n    let i;\n\n    let firstPdtIndex = null;\n\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      const duration = result[1];\n      if (duration) { // INF\n        frag.duration = parseFloat(duration);\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? [ 'INF', duration, title ] : [ 'INF', duration ]);\n      } else if (result[3]) { // url\n        if (Number.isFinite(frag.duration)) {\n          const sn = currentSN++;\n          // frag.type = type;\n          frag.start = totalduration;\n          frag.levelkey = levelkey;\n          frag.sn = sn;\n          // frag.level = id;\n          frag.cc = cc;\n          // frag.urlId = levelUrlId;\n          frag.baseurl = baseurl;\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          frag.relurl = (' ' + result[3]).slice(1);\n          assignProgramDateTime(frag, prevFrag);\n\n          level.fragments.push(frag);\n          prevFrag = frag;\n          totalduration += frag.duration;\n\n          frag = new Fragment();\n        }\n      } else if (result[4]) { // X-BYTERANGE\n        frag.rawByteRange = (' ' + result[4]).slice(1);\n        if (prevFrag) {\n          const lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;\n          if (lastByteRangeEndOffset) {\n            frag.lastByteRangeEndOffset = lastByteRangeEndOffset;\n          }\n        }\n      } else if (result[5]) { // PROGRAM-DATE-TIME\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n        if (firstPdtIndex === null) {\n          firstPdtIndex = level.fragments.length;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n        for (i = 1; i < result.length; i++) {\n          if (result[i] !== undefined) {\n            break;\n          }\n        }\n\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const value1 = (' ' + result[i + 1]).slice(1);\n        const value2 = (' ' + result[i + 2]).slice(1);\n\n        switch (result[i]) {\n        case '#':\n          frag.tagList.push(value2 ? [ value1, value2 ] : [ value1 ]);\n          break;\n        case 'PLAYLIST-TYPE':\n          level.type = value1.toUpperCase();\n          break;\n        case 'MEDIA-SEQUENCE':\n          currentSN = level.startSN = parseInt(value1);\n          break;\n        case 'TARGETDURATION':\n          level.targetduration = parseFloat(value1);\n          break;\n        case 'VERSION':\n          level.version = parseInt(value1);\n          break;\n        case 'EXTM3U':\n          break;\n        case 'ENDLIST':\n          level.live = false;\n          break;\n        case 'DIS':\n          cc++;\n          frag.tagList.push(['DIS']);\n          break;\n        case 'DISCONTINUITY-SEQ':\n          cc = parseInt(value1);\n          break;\n        case 'KEY':\n          // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4\n          var decryptparams = value1;\n          var keyAttrs = new AttrList(decryptparams);\n          var decryptmethod = keyAttrs.enumeratedString('METHOD'),\n            decrypturi = keyAttrs.URI,\n            decryptiv = keyAttrs.hexadecimalInteger('IV');\n          if (decryptmethod) {\n            levelkey = new LevelKey();\n            if ((decrypturi) && (['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0)) {\n              levelkey.method = decryptmethod;\n              // URI to get the key\n              levelkey.baseuri = baseurl;\n              levelkey.reluri = decrypturi;\n              levelkey.key = null;\n              // Initialization Vector (IV)\n              levelkey.iv = decryptiv;\n            }\n          }\n          break;\n        case 'START':\n          let startParams = value1;\n          let startAttrs = new AttrList(startParams);\n          let startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n          // TIME-OFFSET can be 0\n          if (Number.isFinite(startTimeOffset)) {\n            level.startTimeOffset = startTimeOffset;\n          }\n\n          break;\n        case 'MAP':\n          let mapAttrs = new AttrList(value1);\n          frag.relurl = mapAttrs.URI;\n          frag.rawByteRange = mapAttrs.BYTERANGE;\n          frag.baseurl = baseurl;\n          // frag.level = id;\n          // frag.type = type;\n          frag.sn = 'initSegment';\n          level.initSegment = frag;\n          frag = new Fragment();\n          frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;\n          break;\n        default:\n          console.warn(`line parsed but not handled: ${result}`);\n          break;\n        }\n      }\n    }\n    frag = prevFrag;\n    // logger.log('found ' + level.fragments.length + ' fragments');\n    if (frag && !frag.relurl) {\n      level.fragments.pop();\n      totalduration -= frag.duration;\n    }\n    level.totalduration = totalduration;\n    level.averagetargetduration = totalduration / level.fragments.length;\n    level.endSN = currentSN - 1;\n    level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;\n    level.endCC = cc;\n\n    if (!level.initSegment && level.fragments.length) {\n      // this is a bit lurky but HLS really has no other way to tell us\n      // if the fragments are TS or MP4, except if we download them :/\n      // but this is to be able to handle SIDX.\n      if (level.fragments.every((frag) => MP4_REGEX_SUFFIX.test(frag.relurl))) {\n        console.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');\n\n        frag = new Fragment();\n        frag.relurl = level.fragments[0].relurl;\n        frag.baseurl = baseurl;\n        frag.level = id;\n        // frag.type = type;\n        frag.sn = 'initSegment';\n\n        level.initSegment = frag;\n        level.needSidxRanges = true;\n      }\n    }\n\n    /**\n     * Backfill any missing PDT values\n       \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n       one or more Media Segment URIs, the client SHOULD extrapolate\n       backward from that tag (using EXTINF durations and/or media\n       timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */\n    if (firstPdtIndex) {\n      backfillProgramDateTimes(level.fragments, firstPdtIndex);\n    }\n\n    return level;\n  }\n}\n\nfunction backfillProgramDateTimes (fragments, startIndex) {\n  let fragPrev = fragments[startIndex];\n  for (let i = startIndex - 1; i >= 0; i--) {\n    const frag = fragments[i];\n    frag.programDateTime = fragPrev.programDateTime - (frag.duration * 1000);\n    fragPrev = frag;\n  }\n}\n\nfunction assignProgramDateTime (frag, prevFrag) {\n  if (frag.rawProgramDateTime) {\n    frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n  } else if (prevFrag && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n\n  if (!Number.isFinite(frag.programDateTime)) {\n    frag.programDateTime = null;\n    frag.rawProgramDateTime = null;\n  }\n}\n","\nclass TsValidator {\n    static validate(data) {\n        const syncOffset = TsValidator._syncOffset(data);\n        // console.warn(`syncOffset ${syncOffset}`)\n        if (syncOffset < 0) {\n            return true      // not ts\n        }\n        let len = data.length;\n        len -= (len + syncOffset) % 188;\n        for (let start = syncOffset; start < len; start += 188) {\n            if (data[start] !== 0x47) {\n                // 'TS packet did not start with 0x47'\n                return false\n            }\n        }\n        return true\n    }\n\n    static _syncOffset (data) {\n        // scan 1000 first bytes\n        const scanwindow = Math.min(1000, data.length - 3 * 188);\n        let i = 0;\n        while (i < scanwindow) {\n            // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47\n            if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {\n                return i;\n            } else {\n                i++;\n            }\n        }\n        return -1;\n    }\n}\n\nexport default TsValidator\n","\nconst STORE_NOT_INIT = 'store not init'\n\nexport function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\n\nexport function createStore(dbName) {\n    // console.warn(`createStore`)\n    const stores = ['segments', 'id2Sn', 'metadata']\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => {\n        const db = request.result;\n        // console.warn(db.objectStoreNames)\n        stores.forEach(storeName => {\n            // console.warn(`createStore ${storeName}`)\n            db.createObjectStore(storeName);\n        })\n\n    }\n    const dbp = promisifyRequest(request);\n    return stores.map(storeName => (txMode, callback) =>\n        dbp.then((db) =>\n            callback(db.transaction(storeName, txMode).objectStore(storeName)),\n        ))\n}\n\n/**\n * Get a value by its key.\n */\nexport function get(key, getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n\n/**\n * Set a value with a key.\n *\n */\nexport function set(key, value, getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic – if one of the pairs can't be added, none will be added.\n *\n * */\nexport function setMany(entries, getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n\n/**\n * Get multiple values by their keys\n */\nexport function getMany(keys, getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readonly', (store) =>\n        Promise.all(keys.map((key) => promisifyRequest(store.get(key)))),\n    );\n}\n\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n */\nexport function update(key, updater, getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore(\n        'readwrite',\n        (store) =>\n            // Need to create the promise manually.\n            // If I try to chain promises, the transaction closes in browsers\n            // that use a promise polyfill (IE10/11).\n            new Promise((resolve, reject) => {\n                store.get(key).onsuccess = function () {\n                    try {\n                        store.put(updater(this.result), key);\n                        resolve(promisifyRequest(store.transaction));\n                    } catch (err) {\n                        reject(err);\n                    }\n                };\n            }),\n    );\n}\n\n/**\n * Delete a particular key from the store.\n *\n */\nexport function del(key, getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n\n/**\n * Delete multiple keys at once.\n *\n */\nexport function delMany(keys, getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n\n/**\n * Clear all values in the store.\n *\n */\nexport function clear(getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\n\nexport function clearAll(excluded) {\n    // const request = indexedDB.deleteDatabase(DB_NAME);\n    // return promisifyRequest(request)\n    return new Promise((resolve, reject) => {\n        indexedDB.databases().then(dbs => {\n            var promises = dbs.filter(db => db.name !== excluded).map(db => {\n                // console.warn(`del db ${db.name}`)\n                return new Promise((resolve, reject) => {\n                    var req = indexedDB.deleteDatabase(db.name);\n                    req.onsuccess = resolve;\n                    req.onerror = reject;\n                    req.onblocked = reject;\n                });\n            });\n            Promise.all(promises).then(resolve).catch(reject);\n        })\n    })\n\n}\n\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result) return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n\n/**\n * Get all keys in the store.\n *\n */\nexport function keys(getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n\n        const items = [];\n\n        return eachCursor(store, (cursor) =>\n            items.push(cursor.key)\n    ).then(() => items);\n    });\n}\n\n/**\n * Get all values in the store.\n *\n */\nexport function values(getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n\n        const items = [];\n\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(\n            () => items,\n        );\n    });\n}\n\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n */\nexport function entries(getStore) {\n    if (!getStore) return Promise.reject(STORE_NOT_INIT)\n    return getStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(\n                    store.getAllKeys(),\n            ),\n                promisifyRequest(store.getAll()),\n        ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n\n        const items = [];\n\n        return getStore('readonly', (store) =>\n            eachCursor(store, (cursor) =>\n                items.push([cursor.key, cursor.value]),\n            ).then(() => items),\n        );\n    });\n}\n","// import URLToolkit from 'url-toolkit';\n\n//时间单位统一为秒\nlet commonConfig = {\n    // wsSignalerAddr: 'wss://signal.cdnbye.com',          // 信令服务器地址\n    wsMaxRetries: 10,                            // websocket连接重试次数\n\n    p2pEnabled: true,                           // 是否开启P2P，默认true\n\n    wifiOnly: false,                            // 是否只在wifi模式分享\n\n    memoryCacheLimit: {                            // p2p缓存的最大数据量（分为PC和移动端）\n        pc: 600*1024*1024,                       // PC端缓存大小\n        mobile: 300*1024*1024,                   // 移动端缓存大小\n    },\n\n    dcDownloadTimeout: 25,                          // p2p下载的最大超时时间\n\n    logLevel: 'error',                            // log的level，分为debug、info、warn、error、none，设为true等于debug，设为false等于none，默认none\n\n    tag: '',                                     // 用户自定义标签\n\n    webRTCConfig: {},                            // 传入channelConfig用于createDataChannel，config用于RTCPeerConnection\n\n    // useHttpRange: false,                          // 是否允许Http Range请求\n\n    token: undefined,                                    // electron专用token\n    appName: undefined,\n    appId: undefined,\n\n    prefetchNum: 5,         // 同时预下载的切片最大数量\n\n    showSlogan: true,         // 展示广告\n\n    trickleICE: false,\n\n    announceLocation: 'cn',\n\n    geoIpPreflight: true,\n};\n\n\n\n/*\n    fun: channelId generator\n    streamId: 用于标识流地址的ID\n    signalId: 用于标识信令地址的ID，在channelID加上这个可以防止不同信令服务器下的节点混在一起\n */\n// commonConfig.channelId = function (url, browserInfo = {}) {\n//     if (!url) {\n//         throw new Error(`channelId parameter url is null`);\n//     }\n//     const streamParsed = URLToolkit.parseURL(url);\n//     const streamId = streamParsed.netLoc.substr(2) + streamParsed.path.split('.')[0];\n//     return `${streamId}`;\n// };\n\n// 回调P2P统计信息\ncommonConfig.getStats = function (totalP2PDownloaded, totalP2PUploaded, totalHTTPDownloaded) {\n    // do nothing\n};\n\n// 回调peerId\ncommonConfig.getPeerId = function (peerId) {\n    // do nothing\n};\n\n// 回调peers info\ncommonConfig.getPeersInfo = function (peers) {\n    // do nothing\n};\n\nexport default commonConfig;\n","import EventEmitter from 'events'\nimport Logger from \"./utils/logger\"\nimport URLToolkit from 'url-toolkit'\nimport { getBrowserRTC, navLang, getHomeUrl, getQueryParam } from './utils/tool-funs'\nimport Peer from './peer'\nimport platform from \"./utils/platform\"\nimport getPlayer from \"./utils/player-detector\"\n\nconst SAM = {\n    '_': 'nllL',\n    'f': 'd3NzJ',\n    'ss': '==',\n    '3': 'TNBLy9z',\n    '8': 'aWduY',\n    'u': 'mNvbQ',\n    'qa': 'WwuY2RuY',\n};\n\nclass EngineBase extends EventEmitter {\n    constructor(p2pConfig = {}) {\n        super();\n        // console.warn(`EngineBase`);\n        this.p2pEnabled = !(p2pConfig.p2pEnabled === false || getQueryParam('_p2p') === '0');    //默认开启P2P\n        if (p2pConfig.tag && p2pConfig.tag.length > 20) {\n            throw new Error(`Tag is too long`);\n        }\n        if (p2pConfig.appName && p2pConfig.appName.length > 30) {\n            throw new Error(`appName is too long`);\n        }\n        if (p2pConfig.appId && p2pConfig.appId.length > 30) {\n            throw new Error(`appId is too long`);\n        }\n        if (p2pConfig.token && p2pConfig.token.length > 20) {\n            throw new Error(`Token is too long`);\n        }\n    }\n\n    //初始化logger\n    initLogger() {\n        // 展示广告\n        const { config } = this;\n        if (config.showSlogan && navLang() === 'en') {\n            console.log(`%cEmpower your users to become the unlimitedly scalable CDN!\\n%c${getHomeUrl()}`,\n                \"color: dodgerblue; padding:20px 0; font-size: x-large\", 'font-size: medium; padding-bottom:15px');\n        }\n        const logger = new Logger(config.logLevel);\n        config.logger = this.logger = logger;\n        return logger;\n    }\n\n    makeChannelId(prefix, channelId) {\n        if (!prefix || typeof prefix !== 'string') {\n            const errMsg = `token is required while using customized channelId!`;\n            console.error(errMsg);\n            throw new Error(errMsg);\n        }\n        // if (prefix.length < 5) {\n        //     const errMsg = `channelIdPrefix length is too short!`;\n        //     console.error(errMsg);\n        //     throw new Error(errMsg);\n        // } else if (prefix.length > 15) {\n        //     const errMsg = `channelIdPrefix length is too long!`;\n        //     console.error(errMsg);\n        //     throw new Error(errMsg);\n        // }\n        return (url, browserInfo) => {\n            return `${prefix}-${channelId(url, browserInfo)}`\n        }\n    }\n\n    makeSignalId() {\n        let signalId = '';\n        const { config } = this;\n        const defaultAddr = decodeURIComponent(window.atob(SAM['f']+SAM['3']+SAM['8']+SAM['qa']+SAM['_']+SAM['u']+SAM['ss']));\n        if (!config.wsSignalerAddr) {\n            config.wsSignalerAddr = defaultAddr;\n        } else {\n            let mainSignal;\n            if (typeof config.wsSignalerAddr === 'object' && !config.wsSignalerAddr.backup) {\n                mainSignal = config.wsSignalerAddr.main;\n            } else if (typeof config.wsSignalerAddr === 'string') {\n                mainSignal = config.wsSignalerAddr\n            }\n            if (mainSignal === defaultAddr) {\n                mainSignal = undefined;\n            }\n            if (mainSignal) {\n                signalId = URLToolkit.parseURL(mainSignal).netLoc.substr(2);\n            }\n            // this.logger.warn(`wsSignalerAddr is deprecated, please set signal address on dashboard`);\n        }\n        return signalId;\n    }\n\n    get commonBrowserInfo() {\n        const device = platform.getPlatform();\n        const netType = platform.getNetType() || 'wifi';\n        this.netType = netType;\n        return {\n            device,\n            netType,\n            player: getPlayer() || undefined,\n        }\n    }\n\n    setupWindowListeners(destroyed) {\n        // 关闭页面前向peers发送close消息\n        const iOS = ['iPad', 'iPhone'].indexOf(navigator.platform) >= 0;\n        const eventName = iOS ? 'pagehide' : 'beforeunload';\n        const event = () => {\n            // 上报统计\n            if (this.fetcher) {\n                this.fetcher.postStatsWithBeacon()\n            }\n            if (this.p2pEnabled) {\n                this.disableP2P();\n            }\n            window.removeEventListener(eventName, event);\n        }\n        if (destroyed) {\n            window.removeEventListener(eventName, event);\n        } else {\n            window.addEventListener(eventName, event);\n        }\n    }\n\n    destroy() {\n        this.disableP2P(true);\n        this.removeAllListeners();\n        this.setupWindowListeners(true);\n    }\n\n    // 在停止的情况下重新启动P2P\n    enableP2P() {\n        if (!this.p2pEnabled) {\n            if (this.logger) this.logger.info(`enable P2P`);\n            this.config.p2pEnabled = this.p2pEnabled = true;\n            if (!this.browserInfo) return null;\n            this._init(this.channel, this.browserInfo);\n            return this;\n        }\n        return null;\n    }\n\n    get version() {\n        return EngineBase.version;\n    }\n\n    static isSupported() {\n        const browserRTC = getBrowserRTC();\n        return !!(browserRTC && (browserRTC.RTCPeerConnection.prototype.createDataChannel !== undefined));\n    }\n}\n\nEngineBase.version = __VERSION__;\n\nEngineBase.protocolVersion = Peer.VERSION;\n\nexport default EngineBase\n","/**\n * Created by xieting on 2018/4/3.\n */\n\nexport default {\n    //data-channel\n    // DC_PING: 'PING',\n    // DC_PONG: 'PONG',\n    DC_SIGNAL: 'SIGNAL',\n    DC_OPEN: 'OPEN',\n    DC_REQUEST: 'REQUEST',\n    DC_PIECE_NOT_FOUND: 'PIECE_NOT_FOUND',                    // 当请求的数据找不到时触发\n    DC_PIECE_ABORT: 'PIECE_ABORT',\n    DC_CLOSE: 'CLOSE',\n    DC_RESPONSE: 'RESPONSE',\n    DC_ERROR: 'ERROR',\n    DC_PIECE: \"PIECE\",\n    DC_PIECE_DATA: \"PIECE_DATA\",\n    DC_TIMEOUT: \"TIMEOUT\",\n    DC_PIECE_ACK: \"PIECE_ACK\",\n    DC_METADATA: \"METADATA\",\n    DC_PLAT_ANDROID: \"ANDROID\",\n    DC_PLAT_IOS: \"IOS\",\n    DC_PLAT_WEB: \"WEB\",\n    DC_CHOKE: \"CHOKE\",\n    DC_UNCHOKE: \"UNCHOKE\",\n    // DC_INTERESTED: \"INTERESTED\",\n    // DC_NOTINTERESTED: \"NOT_INTERESTED\",\n    DC_HAVE: \"HAVE\",\n    DC_HAVE_REVERSE: 'HAVE_REVERSE',\n    DC_LOST: \"LOST\",\n    DC_GET_PEERS: \"GET_PEERS\",\n    DC_PEERS: \"PEERS\",\n    DC_STATS: \"STATS\",\n    DC_PEER_SIGNAL: \"PEER_SIGNAL\",\n    DC_PLAYLIST: \"PLAYLIST\",\n\n    //buffer-manager\n    BM_LOST: 'lost',\n    BM_ADDED_SEG_: 'BM_ADDED_SEG_',\n    BM_ADDED_SN_: 'BM_ADDED_SN_',\n    BM_SEG_ADDED: 'BM_SEG_ADDED',\n\n    // engine\n    FRAG_CHANGED: 'FRAG_CHANGED',\n    FRAG_LOADED: 'FRAG_LOADED',\n    FRAG_LOADING: 'FRAG_LOADING',\n    RESTART_P2P: 'RESTART_P2P',\n\n    EXCEPTION: \"exception\"\n}\n","\nimport { getBrowserRTC }  from './utils/tool-funs'\nimport EventEmitter from 'events'\nimport queueMicrotask from './utils/queue-microtask'\n// const errCode = require('./utils/err-code')\nimport { Buffer } from './utils/buffer'\n\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\n\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction filterTrickle (sdp) {\n    return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\n    // return sdp\n}\n\nfunction warn (message) {\n    console.warn(message)\n}\n\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */\nclass Peer extends EventEmitter {\n    constructor (opts) {\n        // opts = Object.assign({\n        //     allowHalfOpen: false\n        // }, opts)\n\n        super()\n\n\n        // this._id = randombytes(4).toString('hex').slice(0, 7)\n\n        // this._debug('new peer %o', opts)\n\n        this.channelName = opts.initiator\n            ? opts.channelName\n            : null\n        // console.warn(`peer-channel channelName ${this.channelName}`)\n\n        this.initiator = opts.initiator || false\n        this.channelConfig = opts.channelConfig || Peer.channelConfig\n        this.channelNegotiated = this.channelConfig.negotiated\n        // console.warn(Peer.config)\n        // console.warn(opts.config)\n        this.config = Object.assign({}, Peer.config, opts.config)\n        // warn(JSON.stringify(this.config));\n        this.offerOptions = opts.offerOptions || {}\n        this.answerOptions = opts.answerOptions || {}\n        this.sdpTransform = opts.sdpTransform || (sdp => sdp)\n        // this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old \"stream\" option\n        this.trickle = opts.trickle !== undefined ? opts.trickle : true\n        this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\n        this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\n\n        this.destroyed = false\n        this.destroying = false\n        this._connected = false\n\n        this.remoteAddress = undefined\n        this.remoteFamily = undefined\n        this.remotePort = undefined\n        this.localAddress = undefined\n        this.localFamily = undefined\n        this.localPort = undefined\n\n        this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')\n            ? opts.wrtc\n            : getBrowserRTC()\n\n        // if (!this._wrtc) {\n        //     if (typeof window === 'undefined') {\n        //         throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\n        //     } else {\n        //         throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\n        //     }\n        // }\n\n        this._pcReady = false\n        this._channelReady = false\n        this._iceComplete = false // ice candidate trickle done (got null candidate)\n        this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n        this._channel = null\n        this._pendingCandidates = []\n\n        this._isNegotiating = false // is this peer waiting for negotiation to complete?\n        this._firstNegotiation = true\n        this._batchedNegotiation = false // batch synchronous negotiations\n        this._queuedNegotiation = false // is there a queued negotiation request?\n        this._sendersAwaitingStable = []\n        this._senderMap = new Map()\n        this._closingInterval = null\n\n        this._remoteTracks = []\n        this._remoteStreams = []\n\n        this._chunk = null\n        this._cb = null\n        this._interval = null\n\n        try {\n            this._pc = new (this._wrtc.RTCPeerConnection)(this.config)\n        } catch (err) {\n            queueMicrotask(() => this.destroy(err))\n            return\n        }\n\n        // We prefer feature detection whenever possible, but sometimes that's not\n        // possible for certain implementations.\n        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\n\n        this._pc.oniceconnectionstatechange = () => {\n            this._onIceStateChange()\n        }\n        this._pc.onicegatheringstatechange = () => {\n            this._onIceStateChange()\n        }\n        this._pc.onconnectionstatechange = () => {\n            this._onConnectionStateChange()\n        }\n        this._pc.onsignalingstatechange = () => {\n            this._onSignalingStateChange()\n        }\n        this._pc.onicecandidate = event => {\n            this._onIceCandidate(event)\n        }\n\n        // Other spec events, unused by this implementation:\n        // - onconnectionstatechange\n        // - onicecandidateerror\n        // - onfingerprintfailure\n        // - onnegotiationneeded\n\n        if (this.initiator || this.channelNegotiated) {\n            this._setupData({\n                channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n            })\n        } else {\n            this._pc.ondatachannel = event => {\n                this._setupData(event)\n            }\n        }\n\n        // if (this.streams) {\n        //     this.streams.forEach(stream => {\n        //         this.addStream(stream)\n        //     })\n        // }\n        // this._pc.ontrack = event => {\n        //     this._onTrack(event)\n        // }\n\n        // this._debug('initial negotiation')\n        this._needsNegotiation()\n\n        // this._onFinishBound = () => {\n        //     this._onFinish()\n        // }\n        // this.once('finish', this._onFinishBound)\n    }\n\n    get bufferSize () {\n        return (this._channel && this._channel.bufferedAmount) || 0\n    }\n\n    // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    get connected () {\n        return (this._connected && this._channel.readyState === 'open')\n    }\n\n    // address () {\n    //     return { port: this.localPort, family: this.localFamily, address: this.localAddress }\n    // }\n\n    signal (data) {\n        if (this.destroyed) throw new Error('cannot signal after peer is destroyed')\n        if (typeof data === 'string') {\n            try {\n                data = JSON.parse(data)\n            } catch (err) {\n                data = {}\n            }\n        }\n        // this._debug('signal()')\n\n        if (data.renegotiate && this.initiator) {\n            // this._debug('got request to renegotiate')\n            this._needsNegotiation()\n        }\n        if (data.transceiverRequest && this.initiator) {\n            // this._debug('got request for transceiver')\n            this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\n        }\n        if (data.candidate) {\n            if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n                this._addIceCandidate(data.candidate)\n            } else {\n                this._pendingCandidates.push(data.candidate)\n            }\n        }\n        if (data.sdp) {\n            this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))\n                .then(() => {\n                    if (this.destroyed) return\n\n                    this._pendingCandidates.forEach(candidate => {\n                        this._addIceCandidate(candidate)\n                    })\n                    this._pendingCandidates = []\n\n                    if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\n                })\n                .catch(err => {\n                    this.destroy(err)\n                })\n        }\n        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n            this.destroy(new Error('signal() called with invalid signal data'))\n        }\n    }\n\n    _addIceCandidate (candidate) {\n        const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)\n        this._pc.addIceCandidate(iceCandidateObj)\n            .catch(err => {\n                if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\n                    warn('Ignoring unsupported ICE candidate.')\n                } else {\n                    this.destroy(err)\n                }\n            })\n    }\n\n    /**\n     * Send text/binary data to the remote peer.\n     * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\n     */\n    send (chunk) {\n        this._channel.send(chunk)\n    }\n\n    /**\n     * Add a Transceiver to the connection.\n     * @param {String} kind\n     * @param {Object} init\n     */\n    addTransceiver (kind, init) {\n        // this._debug('addTransceiver()')\n\n        if (this.initiator) {\n            try {\n                this._pc.addTransceiver(kind, init)\n                this._needsNegotiation()\n            } catch (err) {\n                this.destroy(err)\n            }\n        } else {\n            this.emit('signal', { // request initiator to renegotiate\n                type: 'transceiverRequest',\n                transceiverRequest: { kind, init }\n            })\n        }\n    }\n\n    /**\n     * Add a MediaStream to the connection.\n     * @param {MediaStream} stream\n     */\n    // addStream (stream) {\n    //     // this._debug('addStream()')\n    //\n    //     stream.getTracks().forEach(track => {\n    //         this.addTrack(track, stream)\n    //     })\n    // }\n\n    /**\n     * Add a MediaStreamTrack to the connection.\n     * @param {MediaStreamTrack} track\n     * @param {MediaStream} stream\n     */\n    // addTrack (track, stream) {\n    //     // this._debug('addTrack()')\n    //\n    //     const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n    //     let sender = submap.get(stream)\n    //     if (!sender) {\n    //         sender = this._pc.addTrack(track, stream)\n    //         submap.set(stream, sender)\n    //         this._senderMap.set(track, submap)\n    //         this._needsNegotiation()\n    //     } else if (sender.removed) {\n    //         throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')\n    //     } else {\n    //         throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')\n    //     }\n    // }\n\n    /**\n     * Replace a MediaStreamTrack by another in the connection.\n     * @param {MediaStreamTrack} oldTrack\n     * @param {MediaStreamTrack} newTrack\n     * @param {MediaStream} stream\n     */\n    // replaceTrack (oldTrack, newTrack, stream) {\n    //     // this._debug('replaceTrack()')\n    //\n    //     const submap = this._senderMap.get(oldTrack)\n    //     const sender = submap ? submap.get(stream) : null\n    //     if (!sender) {\n    //         throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')\n    //     }\n    //     if (newTrack) this._senderMap.set(newTrack, submap)\n    //\n    //     if (sender.replaceTrack != null) {\n    //         sender.replaceTrack(newTrack)\n    //     } else {\n    //         this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))\n    //     }\n    // }\n\n    /**\n     * Remove a MediaStreamTrack from the connection.\n     * @param {MediaStreamTrack} track\n     * @param {MediaStream} stream\n     */\n    // removeTrack (track, stream) {\n    //     // this._debug('removeSender()')\n    //\n    //     const submap = this._senderMap.get(track)\n    //     const sender = submap ? submap.get(stream) : null\n    //     if (!sender) {\n    //         throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')\n    //     }\n    //     try {\n    //         sender.removed = true\n    //         this._pc.removeTrack(sender)\n    //     } catch (err) {\n    //         if (err.name === 'NS_ERROR_UNEXPECTED') {\n    //             this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n    //         } else {\n    //             this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))\n    //         }\n    //     }\n    //     this._needsNegotiation()\n    // }\n\n    /**\n     * Remove a MediaStream from the connection.\n     * @param {MediaStream} stream\n     */\n    // removeStream (stream) {\n    //     // this._debug('removeSenders()')\n    //\n    //     stream.getTracks().forEach(track => {\n    //         this.removeTrack(track, stream)\n    //     })\n    // }\n\n    _needsNegotiation () {\n        // this._debug('_needsNegotiation')\n        if (this._batchedNegotiation) return // batch synchronous renegotiations\n        this._batchedNegotiation = true\n        queueMicrotask(() => {\n            this._batchedNegotiation = false\n            if (this.initiator || !this._firstNegotiation) {\n                // this._debug('starting batched negotiation')\n                this.negotiate()\n            } else {\n                // this._debug('non-initiator initial negotiation request discarded')\n            }\n            this._firstNegotiation = false\n        })\n    }\n\n    negotiate () {\n        if (this.initiator) {\n            if (this._isNegotiating) {\n                this._queuedNegotiation = true\n                // this._debug('already negotiating, queueing')\n            } else {\n                // this._debug('start negotiation')\n                setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\n                    this._createOffer()\n                }, 0)\n            }\n        } else {\n            if (this._isNegotiating) {\n                this._queuedNegotiation = true\n                // this._debug('already negotiating, queueing')\n            } else {\n                // this._debug('requesting negotiation from initiator')\n                this.emit('signal', { // request initiator to renegotiate\n                    type: 'renegotiate',\n                    renegotiate: true\n                })\n            }\n        }\n        this._isNegotiating = true\n    }\n\n    // TODO: Delete this method once readable-stream is updated to contain a default\n    // implementation of destroy() that automatically calls _destroy()\n    // See: https://github.com/nodejs/readable-stream/issues/283\n    destroy (err) {\n        this._destroy(err, () => {})\n    }\n\n    _destroy (err, cb) {\n        if (this.destroyed || this.destroying) return\n        this.destroying = true\n\n        // this._debug('destroying (error: %s)', err && (err.message || err))\n\n        queueMicrotask(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\n            this.destroyed = true\n            this.destroying = false\n\n            // this._debug('destroy (error: %s)', err && (err.message || err))\n\n            // this.readable = this.writable = false\n\n            // if (!this._readableState.ended) this.push(null)\n            // if (!this._writableState.finished) this.end()\n\n            this._connected = false\n            this._pcReady = false\n            this._channelReady = false\n            this._remoteTracks = null\n            this._remoteStreams = null\n            this._senderMap = null\n\n            clearInterval(this._closingInterval)\n            this._closingInterval = null\n\n            clearInterval(this._interval)\n            this._interval = null\n            this._chunk = null\n            this._cb = null\n\n            // if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\n            // this._onFinishBound = null\n\n            if (this._channel) {\n                try {\n                    this._channel.close()\n                } catch (err) {}\n\n                // allow events concurrent with destruction to be handled\n                this._channel.onmessage = null\n                this._channel.onopen = null\n                this._channel.onclose = null\n                this._channel.onerror = null\n            }\n            if (this._pc) {\n                try {\n                    this._pc.close()\n                } catch (err) {}\n\n                // allow events concurrent with destruction to be handled\n                this._pc.oniceconnectionstatechange = null\n                this._pc.onicegatheringstatechange = null\n                this._pc.onsignalingstatechange = null\n                this._pc.onicecandidate = null\n                this._pc.ontrack = null\n                this._pc.ondatachannel = null\n            }\n            this._pc = null\n            this._channel = null\n\n            if (err) this.emit('error', err)\n            this.emit('close')\n            // cb()\n        })\n    }\n\n    _setupData (event) {\n        if (!event.channel) {\n            // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n            // which is invalid behavior. Handle it gracefully.\n            // See: https://github.com/feross/simple-peer/issues/163\n            return this.destroy(new Error('Data channel event is missing `channel` property'))\n        }\n\n        this._channel = event.channel\n        this._channel.binaryType = 'arraybuffer'\n\n        if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\n            this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\n        }\n\n        this.channelName = this._channel.label\n\n        this._channel.onmessage = event => {\n            this._onChannelMessage(event)\n        }\n        this._channel.onbufferedamountlow = () => {\n            this._onChannelBufferedAmountLow()\n        }\n        this._channel.onopen = () => {\n            this._onChannelOpen()\n        }\n        this._channel.onclose = () => {\n            this._onChannelClose()\n        }\n        this._channel.onerror = err => {\n            this.destroy(err)\n        }\n\n        // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n        let isClosing = false\n        this._closingInterval = setInterval(() => { // No \"onclosing\" event\n            if (this._channel && this._channel.readyState === 'closing') {\n                if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n                isClosing = true\n            } else {\n                isClosing = false\n            }\n        }, CHANNEL_CLOSING_TIMEOUT)\n    }\n\n    // _read () {}\n\n    // _write (chunk, encoding, cb) {\n    //     if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\n    //\n    //     if (this._connected) {\n    //         try {\n    //             this.send(chunk)\n    //         } catch (err) {\n    //             return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n    //         }\n    //         if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n    //             // this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n    //             this._cb = cb\n    //         } else {\n    //             cb(null)\n    //         }\n    //     } else {\n    //         // this._debug('write before connect')\n    //         this._chunk = chunk\n    //         this._cb = cb\n    //     }\n    // }\n\n    // When stream finishes writing, close socket. Half open connections are not\n    // supported.\n    // _onFinish () {\n    //     if (this.destroyed) return\n    //\n    //     // Wait a bit before destroying so the socket flushes.\n    //     // TODO: is there a more reliable way to accomplish this?\n    //     const destroySoon = () => {\n    //         setTimeout(() => this.destroy(), 1000)\n    //     }\n    //\n    //     if (this._connected) {\n    //         destroySoon()\n    //     } else {\n    //         this.once('connect', destroySoon)\n    //     }\n    // }\n\n    _startIceCompleteTimeout () {\n        if (this.destroyed) return\n        if (this._iceCompleteTimer) return\n        // this._debug('started iceComplete timeout')\n        this._iceCompleteTimer = setTimeout(() => {\n            if (!this._iceComplete) {\n                this._iceComplete = true\n                // this._debug('iceComplete timeout completed')\n                this.emit('iceTimeout')\n                // console.warn(`emit _iceComplete ${new Date()}`)\n                this.emit('_iceComplete')\n            }\n        }, this.iceCompleteTimeout)\n    }\n\n    _createOffer () {\n        if (this.destroyed) return\n\n        this._pc.createOffer(this.offerOptions)\n            .then(offer => {\n                if (this.destroyed) return\n                if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\n                offer.sdp = this.sdpTransform(offer.sdp)\n                // console.warn(`createOffer sdp ${offer.sdp}`)\n                const sendOffer = () => {\n                    if (this.destroyed) return\n                    // console.warn(`sendOffer localDescription ${this._pc.localDescription.sdp} ${new Date()}`)\n                    // console.warn(`sendOffer offer ${offer.sdp}`)\n                    const signal = this._pc.localDescription || offer\n                    // this._debug('signal')\n                    this.emit('signal', {\n                        type: signal.type,\n                        sdp: signal.sdp\n                    })\n                }\n\n                const onSuccess = () => {\n                    // this._debug('createOffer success')\n                    if (this.destroyed) return\n                    if (this.trickle || this._iceComplete) sendOffer()\n                    else this.once('_iceComplete', sendOffer) // wait for candidates\n                }\n\n                const onError = err => {\n                    this.destroy(err)\n                }\n\n                this._pc.setLocalDescription(offer)\n                    .then(onSuccess)\n                    .catch(onError)\n            })\n            .catch(err => {\n                this.destroy(err)\n            })\n    }\n\n    _requestMissingTransceivers () {\n        if (this._pc.getTransceivers) {\n            this._pc.getTransceivers().forEach(transceiver => {\n                if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n                    transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n                    this.addTransceiver(transceiver.sender.track.kind)\n                }\n            })\n        }\n    }\n\n    _createAnswer () {\n        if (this.destroyed) return\n\n        this._pc.createAnswer(this.answerOptions)\n            .then(answer => {\n                if (this.destroyed) return\n                if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\n                answer.sdp = this.sdpTransform(answer.sdp)\n                // console.warn(`createAnswer sdp ${answer.sdp}`)\n                const sendAnswer = () => {\n                    if (this.destroyed) return\n                    // console.warn(`sendAnswer localDescription ${this._pc.localDescription.sdp} ${new Date()}`)\n                    // console.warn(`sendAnswer answer ${answer.sdp}`)\n                    const signal = this._pc.localDescription || answer\n                    // this._debug('signal')\n                    this.emit('signal', {\n                        type: signal.type,\n                        sdp: signal.sdp\n                    })\n                    if (!this.initiator) this._requestMissingTransceivers()\n                }\n\n                const onSuccess = () => {\n                    if (this.destroyed) return\n                    if (this.trickle || this._iceComplete) sendAnswer()\n                    else this.once('_iceComplete', sendAnswer)\n                }\n\n                const onError = err => {\n                    this.destroy(err)\n                }\n\n                this._pc.setLocalDescription(answer)\n                    .then(onSuccess)\n                    .catch(onError)\n            })\n            .catch(err => {\n                this.destroy(err)\n            })\n    }\n\n    _onConnectionStateChange () {\n        if (this.destroyed) return\n        if (this._pc.connectionState === 'failed') {\n            this.destroy(new Error('Connection failed.'))\n        }\n    }\n\n    // TODO iceRestart\n    _onIceStateChange () {\n        if (this.destroyed) return\n        const iceConnectionState = this._pc.iceConnectionState\n        const iceGatheringState = this._pc.iceGatheringState\n\n        // this._debug(\n        //     'iceStateChange (connection: %s) (gathering: %s)',\n        //     iceConnectionState,\n        //     iceGatheringState\n        // )\n        this.emit('iceStateChange', iceConnectionState, iceGatheringState)\n\n        if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n            this._pcReady = true\n            this._maybeReady()\n        }\n        if (iceConnectionState === 'failed') {\n            this.destroy(new Error('Ice connection failed.'))\n        }\n        if (iceConnectionState === 'closed') {\n            this.destroy(new Error('Ice connection closed.'))\n        }\n    }\n\n    getStats (cb) {\n        // statreports can come with a value array instead of properties\n        const flattenValues = report => {\n            if (Object.prototype.toString.call(report.values) === '[object Array]') {\n                report.values.forEach(value => {\n                    Object.assign(report, value)\n                })\n            }\n            return report\n        }\n\n        // Promise-based getStats() (standard)\n        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n            this._pc.getStats()\n                .then(res => {\n                    const reports = []\n                    res.forEach(report => {\n                        reports.push(flattenValues(report))\n                    })\n                    cb(null, reports)\n                }, err => cb(err))\n\n            // Single-parameter callback-based getStats() (non-standard)\n        } else if (this._pc.getStats.length > 0) {\n            this._pc.getStats(res => {\n                // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n                if (this.destroyed) return\n\n                const reports = []\n                res.result().forEach(result => {\n                    const report = {}\n                    result.names().forEach(name => {\n                        report[name] = result.stat(name)\n                    })\n                    report.id = result.id\n                    report.type = result.type\n                    report.timestamp = result.timestamp\n                    reports.push(flattenValues(report))\n                })\n                cb(null, reports)\n            }, err => cb(err))\n\n            // Unknown browser, skip getStats() since it's anyone's guess which style of\n            // getStats() they implement.\n        } else {\n            cb(null, [])\n        }\n    }\n\n    _maybeReady () {\n        // this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\n        if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\n\n        this._connecting = true\n\n        // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n        const findCandidatePair = () => {\n            if (this.destroyed) return\n\n            this.getStats((err, items) => {\n                if (this.destroyed) return\n\n                // Treat getStats error as non-fatal. It's not essential.\n                if (err) items = []\n\n                const remoteCandidates = {}\n                const localCandidates = {}\n                const candidatePairs = {}\n                let foundSelectedCandidatePair = false\n\n                items.forEach(item => {\n                    // TODO: Once all browsers support the hyphenated stats report types, remove\n                    // the non-hypenated ones\n                    if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\n                        remoteCandidates[item.id] = item\n                    }\n                    if (item.type === 'localcandidate' || item.type === 'local-candidate') {\n                        localCandidates[item.id] = item\n                    }\n                    if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\n                        candidatePairs[item.id] = item\n                    }\n                })\n\n                const setSelectedCandidatePair = selectedCandidatePair => {\n                    foundSelectedCandidatePair = true\n\n                    let local = localCandidates[selectedCandidatePair.localCandidateId]\n\n                    if (local && (local.ip || local.address)) {\n                        // Spec\n                        this.localAddress = local.ip || local.address\n                        this.localPort = Number(local.port)\n                    } else if (local && local.ipAddress) {\n                        // Firefox\n                        this.localAddress = local.ipAddress\n                        this.localPort = Number(local.portNumber)\n                    } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\n                        // TODO: remove this once Chrome 58 is released\n                        local = selectedCandidatePair.googLocalAddress.split(':')\n                        this.localAddress = local[0]\n                        this.localPort = Number(local[1])\n                    }\n                    if (this.localAddress) {\n                        this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\n                    }\n\n                    let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\n\n                    if (remote && (remote.ip || remote.address)) {\n                        // Spec\n                        this.remoteAddress = remote.ip || remote.address\n                        this.remotePort = Number(remote.port)\n                    } else if (remote && remote.ipAddress) {\n                        // Firefox\n                        this.remoteAddress = remote.ipAddress\n                        this.remotePort = Number(remote.portNumber)\n                    } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\n                        // TODO: remove this once Chrome 58 is released\n                        remote = selectedCandidatePair.googRemoteAddress.split(':')\n                        this.remoteAddress = remote[0]\n                        this.remotePort = Number(remote[1])\n                    }\n                    if (this.remoteAddress) {\n                        this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\n                    }\n\n                    // this._debug(\n                    //     'connect local: %s:%s remote: %s:%s',\n                    //     this.localAddress,\n                    //     this.localPort,\n                    //     this.remoteAddress,\n                    //     this.remotePort\n                    // )\n                }\n\n                items.forEach(item => {\n                    // Spec-compliant\n                    if (item.type === 'transport' && item.selectedCandidatePairId) {\n                        setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\n                    }\n\n                    // Old implementations\n                    if (\n                        (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\n                        ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\n                    ) {\n                        setSelectedCandidatePair(item)\n                    }\n                })\n\n                // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n                // But wait until at least 1 candidate pair is available\n                if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n                    setTimeout(findCandidatePair, 100)\n                    return\n                } else {\n                    this._connecting = false\n                    this._connected = true\n                }\n\n                if (this._chunk) {\n                    try {\n                        this.send(this._chunk)\n                    } catch (err) {\n                        return this.destroy(err)\n                    }\n                    this._chunk = null\n                    // this._debug('sent chunk from \"write before connect\"')\n\n                    const cb = this._cb\n                    this._cb = null\n                    cb(null)\n                }\n\n                // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n                // fallback to using setInterval to implement backpressure.\n                if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\n                    this._interval = setInterval(() => this._onInterval(), 150)\n                    if (this._interval.unref) this._interval.unref()\n                }\n\n                // this._debug('connect')\n                this.emit('connect')\n            })\n        }\n        findCandidatePair()\n    }\n\n    _onInterval () {\n        if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n            return\n        }\n        this._onChannelBufferedAmountLow()\n    }\n\n    _onSignalingStateChange () {\n        if (this.destroyed) return\n\n        if (this._pc.signalingState === 'stable') {\n            this._isNegotiating = false\n\n            // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n            // this._debug('flushing sender queue', this._sendersAwaitingStable)\n            this._sendersAwaitingStable.forEach(sender => {\n                this._pc.removeTrack(sender)\n                this._queuedNegotiation = true\n            })\n            this._sendersAwaitingStable = []\n\n            if (this._queuedNegotiation) {\n                // this._debug('flushing negotiation queue')\n                this._queuedNegotiation = false\n                this._needsNegotiation() // negotiate again\n            } else {\n                // this._debug('negotiated')\n                this.emit('negotiated')\n            }\n        }\n\n        // this._debug('signalingStateChange %s', this._pc.signalingState)\n        this.emit('signalingStateChange', this._pc.signalingState)\n    }\n\n    _onIceCandidate (event) {\n        if (this.destroyed) return\n        if (event.candidate && this.trickle) {\n            this.emit('signal', {\n                type: 'candidate',\n                candidate: {\n                    candidate: event.candidate.candidate,\n                    sdpMLineIndex: event.candidate.sdpMLineIndex,\n                    sdpMid: event.candidate.sdpMid\n                }\n            })\n        } else if (!event.candidate && !this._iceComplete) {\n            // 到这里说明没有新的candidate了\n            // console.warn(`_onIceCandidate event ${event}`)\n            this._iceComplete = true\n            this.emit('_iceComplete')\n        }\n        // as soon as we've received one valid candidate start timeout\n        if (event.candidate) {\n            // console.warn(`_startIceCompleteTimeout ${new Date()}`)\n            this._startIceCompleteTimeout()\n        }\n    }\n\n    _onChannelMessage (event) {\n        if (this.destroyed) return\n        let data = event.data\n        if (data instanceof ArrayBuffer) data = Buffer.from(data)\n        // this.push(data)\n        this.emit('data', data)\n    }\n\n    _onChannelBufferedAmountLow () {\n        if (this.destroyed || !this._cb) return\n        // this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n        const cb = this._cb\n        this._cb = null\n        cb(null)\n    }\n\n    _onChannelOpen () {\n        if (this._connected || this.destroyed) return\n        // this._debug('on channel open')\n        this._channelReady = true\n        this._maybeReady()\n    }\n\n    _onChannelClose () {\n        if (this.destroyed) return\n        // this._debug('on channel close')\n        this.destroy()\n    }\n\n    // _onTrack (event) {\n    //     if (this.destroyed) return\n    //\n    //     event.streams.forEach(eventStream => {\n    //         // this._debug('on track')\n    //         this.emit('track', event.track, eventStream)\n    //\n    //         this._remoteTracks.push({\n    //             track: event.track,\n    //             stream: eventStream\n    //         })\n    //\n    //         if (this._remoteStreams.some(remoteStream => {\n    //             return remoteStream.id === eventStream.id\n    //         })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream\n    //\n    //         this._remoteStreams.push(eventStream)\n    //         queueMicrotask(() => {\n    //             // this._debug('on stream')\n    //             this.emit('stream', eventStream) // ensure all tracks have been added\n    //         })\n    //     })\n    // }\n\n    // _debug () {\n        // const args = [].slice.call(arguments)\n        // args[0] = '[' + this._id + '] ' + args[0]\n        // debug.apply(null, args)\n    // }\n}\n\n// Peer.WEBRTC_SUPPORT = !!getBrowserRTC()\n\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */\nPeer.config = {\n    iceServers: [\n        {\n            urls: [\n                'stun:stun.l.google.com:19302',\n                'stun:global.stun.twilio.com:3478',\n                // 'stun:stun.cdnbye.com'\n            ]\n        }\n    ],\n    sdpSemantics: 'unified-plan'\n}\n\nPeer.channelConfig = {}\n\nexport default Peer\n","\nclass PeerManager {\n\n    constructor() {\n        this.peerMap = new Map();                 // remotePeerId -> dc\n    }\n\n    isEmpty() {\n        return this.peerMap.size === 0;\n    }\n\n    size() {\n        return this.peerMap.size;\n    }\n\n    clear() {\n        this.peerMap.clear();\n    }\n\n    getPeers() {\n        return [...this.peerMap.values()];\n    }\n\n    getPeerValues() {\n        return this.peerMap.values();\n    }\n\n    hasPeer(peerId) {\n        return this.peerMap.has(peerId)\n    }\n\n    addPeer(peerId, peer) {\n        this.peerMap.set(peerId, peer);\n}\n\n    getPeerIds() {\n        return [...this.peerMap.keys()];\n    }\n\n    removePeer(peerId) {\n        this.peerMap.delete(peerId);\n    }\n\n    getPeersOrderByWeight() {\n\n        const availablePeers = this.getAvailablePeers();\n        // availablePeers.forEach(p => {\n        //     console.warn(p.weight + \"\")\n        // });\n        availablePeers.sort((p1, p2) => {\n            if (p2.weight === 0) {    // weight是0的节点排在前面\n                return 1;\n            } else if (p1.weight === 0) {    // weight是0的节点排在前面\n                return -1;\n            }\n            return p2.weight - p1.weight;\n        });\n        // console.warn(\"after\");\n        // availablePeers.forEach(p => {\n        //     console.warn(p.weight + \"\")\n        // });\n        return availablePeers;\n    }\n\n    getPeer(peerId) {\n        return this.peerMap.get(peerId);\n    }\n\n    getAvailablePeers() {\n        return this.getPeers().filter(peer => peer.isAvailableUrgently);\n    }\n\n}\n\nexport default PeerManager\n","import PeerChannel from './peer-channel'\nimport EventEmitter from 'events'\nimport Events from './events'\nimport { getCurrentTs } from \"./utils/tool-funs\"\nimport Segment from './segment'\nimport platform from \"./utils/platform\"\nimport { pack, unpack } from './sdp/index'\nimport { Buffer } from './utils/buffer'\n\nconst DC_TOLERANCE = 2;                   // 请求超时或错误多少次阻塞该peer\nconst DEFAULT_PACKET_SIZE = 64 * 1000;    // 默认每次通过datachannel发送的包的大小 不能发送大于64KB的包\nconst ALPHA = 0.6;                        // weight平滑系数\nconst SIGNAL_PACK_VER = 1                 // 信令压缩版本号\n\nclass Peer extends EventEmitter {\n\n    static get defaultPacketSize() {\n        return DEFAULT_PACKET_SIZE\n    }\n\n    static get VERSION() {\n        return __PROTOCOL_VERSION__\n    }\n\n    constructor(engine, peerId, remotePeerId, isInitiator, config, sequential, options = {}) {\n        super();\n\n        this.engine = engine;\n        this.channel = engine.fetcher.channelId;\n        this.logger = engine.logger;\n        this.config = config;\n        this.isInitiator = isInitiator;\n        this.options = options;\n        this.typeExpected = sequential;\n        this.remotePeerId = remotePeerId;\n        this.intermediator = options.intermediator || null;\n        // if (this.intermediator) this.logger.info(`${remotePeerId} intermediator is ${this.intermediator}`);\n        // this.channelId = isInitiator ? peerId + '-' + remotePeerId : remotePeerId + '-' + peerId;                    //标识该channel\n        this.channelId = isInitiator ? `${peerId}-${remotePeerId}` : `${remotePeerId}-${peerId}`;                    //标识该channel\n        // console.warn(`this.channelId ${this.channelId}`);\n        this.cpr = 0;                                   // 信令压缩\n        this.platform = 'unknown';\n        this.mobile = false;                            // 是否移动端\n        this.mobileWeb = false;                         // 是否移动web端\n        this.connected = false;\n        this.msgQueue = [];\n        this.miss = 0;                            // 超时或者错误的次数\n        // this.bitset;\n        this.notifySet = new Set();\n        this.bufArr = [];\n\n        this.packetSize = DEFAULT_PACKET_SIZE;    //每个数据包的大小\n\n        // P2P连接超时控制\n        this.connTimeout = setTimeout(() => {\n            this.logger.warn(`dc ${this.channelId} connection timeout`);\n            this.emit(Events.DC_ERROR, true);\n        }, 25000);\n\n        //下载控制\n        this.sendReqQueue = [];                   // 发送的请求的队列    队列头部优先级最高 sn\n        this.downloading = false;\n        this.uploading = false;\n        this.choked = false;\n        this.downloadListeners = [];\n        this.pieceMsg = {};      // attachments, seg_id, sn, size, reverse\n\n        // 统计\n        // trequest = performance.now();\n        this.timeSendRequest = 0;        // 发送request的时刻 毫秒    用于计算节点权重\n        this.timeReceivePiece = 0;        // 接收到piece的时刻 毫秒    用于shouldWaitForRemain\n        this.timeSendPiece = 0;          // 发送piece的时刻 毫秒\n        this.weight = 0;                 // 平均速度 byte/ms\n        this.peersConnected = 1;         // 已连接的节点数\n        this.timeJoin = getCurrentTs();      // 加入时间，用于get peers\n        this.uploadSpeed = 0;            // 上行速度，byte/ms  用于订阅模式\n        this.gotPeers = false;           // 是否向该peer请求过节点\n        this.currentLevel = 0;           // 当前码率， 用于hls-de\n        this.currentPos = 0;           // 当前播放位置\n\n        // 如果指定了stun\n        let webRTCConfig = {};\n        // console.warn(this.options.stuns)\n        if (this.options.stuns.length > 0) {\n            const urls = [];\n            this.options.stuns.forEach(url => {\n                this.logger.info(`use stun ${url}`);\n                urls.push({urls: url})\n            });\n            webRTCConfig.iceServers = urls;\n        }\n        if (this.config.webRTCConfig) {\n            webRTCConfig = {\n                ...this.config.webRTCConfig,\n                ...webRTCConfig,\n            }\n        }\n\n        // playlist\n        this.playlistMap = new Map();                // url -> {data, seq} seq是m3u8最大的ts序号\n\n        this._datachannel = new PeerChannel({\n            initiator: isInitiator,\n            channelName: this.channelId,\n            trickle: options.trickle || false,\n            config: webRTCConfig,\n        });\n        this._init(this._datachannel);\n\n        // this.downloadNum = 0;                       // 正在下载的请求个数\n        this.dataExchangeTs = this.timeJoin;                   // 最近发生数据交换的时间戳\n        this.gotStatsTs = this.timeJoin;                   // 最近接收到stats的时间戳\n\n        this.startSN = Number.MAX_SAFE_INTEGER;            // 当前peer拥有的最小的SN\n        this.endSN = -1;                                   // 当前peer拥有的最大的SN\n\n        // this.testCount = 0;\n    }\n\n    get isAvailable() {\n        return this.downloadNum < 2 && !this.choked;\n    }\n\n    get isAvailableUrgently() {\n        return !this.downloading && !this.choked;\n    }\n\n    addDownloadListener(handler) {\n        this.downloadListeners.push({\n            handler,\n        })\n    }\n\n    addStreamListener(reverse, handler) {   // TODO 验证\n        this.addDownloadListener(handler);\n    }\n\n    _init(datachannel) {\n        datachannel.on('error', (err) => {\n            // logger.warn('datachannel error', err);\n            this.emit(Events.DC_ERROR, true);\n        });\n\n        datachannel.on('signal', data => {\n            // console.warn(`act origin`)\n            // console.warn(JSON.stringify(data))\n            if (this.cpr === SIGNAL_PACK_VER) {\n                const packed = pack(data)\n                if (packed) {\n                    data = packed;\n                } else {\n                    this.logger.error(`signal pack error`);\n                }\n            }\n            // console.warn(JSON.stringify(data))\n            // if (data) {\n            //     console.warn(`unpack`)\n            //     console.warn(unpack(data))\n            // }\n            this.emit(Events.DC_SIGNAL, data);\n        });\n\n        const _onConnect = () => {\n\n            this.logger.info(`datachannel CONNECTED to ${this.remotePeerId} from ${this.intermediator?'peer':'server'}`);\n            this.connected = true;\n            clearTimeout(this.connTimeout);    // TODO 验证\n\n            this.emit(Events.DC_OPEN);\n\n            //发送消息队列中的消息\n            while (this.msgQueue.length > 0) {\n                let msg = this.msgQueue.shift();\n                this.emit(msg.event, msg);\n            }\n        };\n\n        datachannel.on('connect', _onConnect);       // TODO 验证on\n\n        datachannel.on('data', data => {\n            // console.warn(`dc ondata`)\n            // console.warn(data)\n            const { logger } = this;\n            if (typeof data === 'string') {\n\n                let msg = JSON.parse(data);\n\n                //如果还没连接，则先保存在消息队列中\n                if (!this.connected) {\n                    this.msgQueue.push(msg);\n                    // _onConnect();\n                    return;\n                }\n                let event = msg.event;\n\n                let str;\n                if (event !== Events.DC_PLAYLIST && event !== Events.DC_PEER_SIGNAL) {\n                    str = `string: ${data}`;\n                } else {\n                    str = `event: ${event}`;\n                }\n                logger.debug(`datachannel receive ${str} from ${this.remotePeerId}`);\n\n                switch (event) {\n                    case Events.DC_HAVE:\n                        this.emit(msg.event, msg);\n                        if (!msg.sn) return;\n                        if (!this.config.live) {\n                            if (msg.sn < this.startSN) {\n                                this.startSN = msg.sn;\n                                // console.warn(`this.startSN ${this.startSN}`);\n                            }\n                            if (msg.sn > this.endSN) {\n                                this.endSN = msg.sn;\n                            }\n                        }\n                        break;\n                    case Events.DC_PIECE:\n                        this.downloading = true;                     // 订阅\n                        this.dataExchangeTs = getCurrentTs();\n                        this.timeReceivePiece = performance.now();\n                        this.pieceMsg = msg;\n                        this._prepareForBinary(msg.attachments, msg.seg_id, msg.sn, msg.size);\n                        this.emit(msg.event, msg);\n                        break;\n                    case Events.DC_PIECE_NOT_FOUND:\n                        if (!this._sendNextReq()) {\n                            this.downloading = false;\n                        }\n                        this.emit(msg.event, msg);\n                        break;\n                    case Events.DC_REQUEST:\n                        this._handleRequestMsg(msg);\n                        break;\n                    case Events.DC_PIECE_ACK:\n                        this.dataExchangeTs = getCurrentTs();\n                        this._handlePieceAck(msg);\n                        this.emit(msg.event, msg);\n                        break;\n                    case Events.DC_STATS:\n                        this._handleStats(msg);\n                        break;\n                    case Events.DC_PLAYLIST:\n                        // console.warn(JSON.stringify(msg));\n                        if (this.config.sharePlaylist) {\n                            this._handlePlaylist(msg);\n                        }\n                        break;\n                    case Events.DC_METADATA:          // bug 没收到\n                        this._handleMetadata(msg);\n                        break;\n                    case Events.DC_PIECE_ABORT:\n                        if (this.downloading) {\n                            this._notifyDownloadListenersAbort('aborted by upstream peer');\n                            this.emit(Events.DC_PIECE_ABORT, msg);\n                        }\n                        break;\n                    case Events.DC_CHOKE:\n                        logger.info(`choke peer ${this.remotePeerId}`);\n                        this.choked = true;\n                        break;\n                    case Events.DC_UNCHOKE:\n                        logger.info(`unchoke peer ${this.remotePeerId}`);\n                        this.choked = false;\n                        break;\n                    case Events.DC_CLOSE:\n                        this.emit(msg.event, msg.fatal || false);\n                        break;\n                    default:\n                        this.emit(msg.event, msg);\n                }\n            } else {                                       //binary data\n                // console.warn(`datachannel receive binary data size ${data.byteLength}`);\n                if (!this.downloading) {\n                    logger.error(`peer is not downloading, data size ${data.byteLength} pieceMsg ${JSON.stringify(this.pieceMsg)}`);\n                    return;\n                }\n                // test\n                // setTimeout(() => {\n                //     this._handleBinaryMsg(data);\n                // }, 3000);\n                this._handleBinaryMsg(data);\n            }\n        });\n\n        datachannel.once('close', () => {\n            this.emit(Events.DC_CLOSE, false);\n        });\n\n        datachannel.on('iceStateChange', (iceConnectionState, iceGatheringState) => {\n            if (iceConnectionState === 'disconnected') {\n                this.logger.warn(`${this.remotePeerId} disconnected`);\n                this.connected = false;\n            }\n        })\n    }\n\n    sendJson(json) {\n        if (json.event !== Events.DC_PLAYLIST && json.event !== Events.DC_PEER_SIGNAL) {\n            // if (true) {\n            this.logger.debug(`dc bufferSize ${this._datachannel.bufferSize} send ${JSON.stringify(json)} to ${this.remotePeerId}`);\n        } else {\n            this.logger.debug(`dc send event ${json.event} to ${this.remotePeerId}`);\n        }\n        const str = JSON.stringify(json);\n        if (str.length > DEFAULT_PACKET_SIZE) {\n            // 防止数据包过大\n            this.logger.error(`string to send is too large`)\n            return false\n        }\n        return this.send(str);\n    }\n\n    send(data) {\n        if (this._datachannel && this._datachannel.connected) {\n            try {\n                this._datachannel.send(data);\n                return true;\n            } catch (e) {\n                this.logger.warn(`datachannel ${this.channelId} send data failed, close it`);\n                this.emit(Events.DC_ERROR, false);\n            }\n        }\n        return false;\n    }\n\n    sendMsgHave(sn, segId, ext = {}) {\n        const reverse = ext.reverse || undefined;\n        delete ext.reverse;\n        this.sendJson({\n            event: reverse ? Events.DC_HAVE_REVERSE : Events.DC_HAVE,\n            sn: sn,\n            seg_id: segId,\n            ...ext,\n        })\n    }\n\n    sendPieceNotFound(sn, segId, ext = {}) {\n        this.uploading = false;\n        this.sendJson({\n            event: Events.DC_PIECE_NOT_FOUND,\n            seg_id: segId,\n            sn,\n            ...ext,\n        })\n    }\n\n    sendPeers(peers) {\n        this.sendJson({\n            event: Events.DC_PEERS,\n            peers,\n        })\n    }\n\n    sendPeersRequest() {\n        this.sendJson({\n            event: Events.DC_GET_PEERS,\n        })\n    }\n\n    sendMsgStats(totalConns, extra = {}) {\n        const msg = {\n            event: Events.DC_STATS,\n            total_conns: totalConns,\n            ...extra,\n        };\n        this.sendJson(msg);\n    }\n\n    sendMsgPlaylist(url, data, seq) {\n        if (this.playlistMap.has(url)) {\n            const playlist = this.playlistMap.get(url);\n            if (playlist.seq >= seq) return\n        }\n        const msg = {\n            event: Events.DC_PLAYLIST,\n            url,\n            data,\n            seq\n        };\n        this.sendJson(msg);\n    }\n\n    sendMsgSignal(toPeerId, fromPeerId, data) {\n        return this.sendJson({\n            event: Events.DC_PEER_SIGNAL,\n            action: 'signal',\n            to_peer_id: toPeerId,\n            from_peer_id: fromPeerId,\n            data,\n        })\n    }\n\n    sendMsgSignalReject(toPeerId, fromPeerId, reason, fatal = false) {\n        return this.sendJson({\n            event: Events.DC_PEER_SIGNAL,\n            action: 'reject',\n            to_peer_id: toPeerId,\n            from_peer_id: fromPeerId,\n            reason,\n            fatal,\n        })\n    }\n\n    sendMetaData(field, sequential, peers=0) {\n        // 开始计时\n        if (this.isInitiator) this.timeSendRequest = performance.now();\n\n        this.sendJson({                                        //向peer发送bitfield\n            event: Events.DC_METADATA,\n            field: field,\n            platform: Events.DC_PLAT_WEB,\n            mobile: !!platform.isMobile(),\n            channel: this.channel,                      // 频道ID\n            version: __VERSION__,                       // SDK版本号\n            sequential,\n            peers,\n        });\n    }\n\n    // 目前还是反向状态\n    sendPartialBuffer(pieceMsg, bufArr, ext = {}) {\n        this.sendMsgPiece(pieceMsg, ext);\n        for (let j = 0; j < bufArr.length; j++) {\n            this.send(bufArr[j]);\n        }\n    }\n\n    sendMsgPiece(msg, ext = {}) {\n        if (!msg.ext) msg.ext = {};\n        if (msg.ext.from && ext.from) {\n            ext.from = `${msg.ext.from}->${ext.from}`;\n        }\n        if (ext.incompletes && msg.ext.incompletes) {\n            ext.incompletes += msg.ext.incompletes;\n        }\n\n        ext = Object.assign({}, msg.ext, ext);\n        const msgToSend = {\n            ...msg,\n            ext,\n        };\n        // console.warn(`sendMsgPiece ${JSON.stringify(msg)}`);\n        this.sendJson(msgToSend);\n    }\n\n    sendBuffer(sn, segId, payload, ext = {}) {\n        const reverse = ext.reverse || undefined;\n        delete ext.reverse;\n        let dataSize = payload.byteLength,                                //二进制数据大小\n            // packetSize = DEFAULT_PACKET_SIZE,                          //每个数据包的大小\n            remainder = 0,                                                //最后一个包的大小\n            attachments = 0;                                              //分多少个包发\n        if (dataSize % this.packetSize === 0) {\n            attachments = dataSize / this.packetSize;\n        } else {\n            attachments = Math.floor(dataSize / this.packetSize) + 1;\n            remainder = dataSize % this.packetSize;\n        }\n        let response = {\n            event: Events.DC_PIECE,\n            // ext,\n            attachments,\n            // attachments: 1,           // test\n            seg_id: segId,\n            sn,\n            level: ext.level,\n            size: dataSize,\n            // size: 1000          // test\n            reverse,\n        };\n\n        // test\n        // this.sendPieceNotFound(sn, segId, { level: ext.level });\n        // return\n\n        delete ext.level;\n        this.sendMsgPiece(response, ext);\n        // console.warn(`send segment to ${this.remotePeerId} ${JSON.stringify(response)} packetSize ${this.packetSize}`);\n\n        const bufArr = dividePayload(payload, this.packetSize, attachments, remainder);\n        this._sendBufferArray(bufArr, reverse);\n\n        this.uploading = false;\n\n        // setTimeout(() => {\n        //     this.send(bufArr[bufArr.length-1]);\n        //     console.warn(`send buffer ${bufArr.length-1} of ${sn}`)\n        // }, 2000)\n\n        // test\n        // this.send(new ArrayBuffer(1000))\n\n        // 计时\n        this.timeSendPiece = performance.now();\n    }\n\n    get downloadNum() {\n        if (!this.downloading) return 0;\n        return this.sendReqQueue.length + 1;\n    }\n\n    // cancelRequestById(segId) {\n    //     this.sendReqQueue = this.sendReqQueue.filter(msg => msg.seg_id !== segId);\n    // }\n    //\n    // cancelRequestBySN(sn) {\n    //     this.sendReqQueue = this.sendReqQueue.filter(msg => msg.sn !== sn);\n    // }\n\n    requestDataById(segId, sn, urgent = false, ext = {}) {                                     //由于需要阻塞下载数据，因此request请求用新的API\n        // this.logger.info(`requestDataById downloadNum ${this.downloadNum}`);\n\n        const msg = {\n            event: Events.DC_REQUEST,\n            seg_id: segId,\n            sn,\n            ...ext,\n            urgent: urgent\n        };\n        if (this.downloading) {\n            this.logger.info(`${this.remotePeerId} add req ${segId} in queue`);\n            urgent ? this.sendReqQueue.unshift(msg) : this.sendReqQueue.push(msg);\n        } else {\n            this._realRequestData(msg);\n        }\n    }\n\n    requestDataBySN(sn, urgent = false, ext = {}) {\n        // console.warn(`requestDataBySN downloadNum ${this.downloadNum}`);\n\n        const msg = {\n            event: Events.DC_REQUEST,\n            sn,                                               //ts数据的播放序号\n            ...ext,\n            urgent: urgent                                        //是否紧急\n        };\n        if (this.downloading) {\n            this.logger.info(`add req ${sn} in queue`);\n            urgent ? this.sendReqQueue.unshift(msg) : this.sendReqQueue.push(msg);\n        } else {\n            this._realRequestData(msg);\n        }\n    }\n\n    _sendBufferArray(bufArr, reverse = false) {\n\n        // if (++this.testCount === 15) {\n        //     console.warn('--------------start test------------------')\n        //     // test\n        //     if (reverse) {\n        //         for (let j = bufArr.length-1; j >= 2; j--) {\n        //             this.send(bufArr[j]);\n        //         }\n        //         // this.send(bufArr[bufArr.length-1]);\n        //         // return\n        //     }\n        //     else {\n        //         for (let j = 0; j < bufArr.length-2; j++) {\n        //             this.send(bufArr[j]);\n        //         }\n        //         // this.send(bufArr[0]);\n        //     }\n        //     // this.sendMsgPieceAbort('test abort');\n        //     return\n        // }\n\n        if (reverse) {\n            for (let j = bufArr.length-1; j >= 0; j--) {\n                this.send(bufArr[j]);\n            }\n        } else {\n            for (let j = 0; j < bufArr.length; j++) {\n                this.send(bufArr[j]);\n            }\n        }\n    }\n\n    _realRequestData(msg) {\n        // test\n        // setTimeout(() => {\n        //     this.sendJson(msg);\n        // }, 3000);\n\n        this.sendJson(msg);\n\n        // 开始计时\n        this.timeSendRequest = performance.now();\n        this.downloading = true;\n        // this.pieceMsg = {};           // 重置\n        // this.requestTimeout = window.setTimeout(() => {\n        //\n        //     this.loadtimeout(sn);\n        //\n        // }, DOWNLOAD_TIMEOUT * 1000);\n\n        //urgent请求才计时\n        // if (urgent) {\n        //     this.requestTimeout = window.setTimeout(this._loadtimeout.bind(this), this.config.dcRequestTimeout*1000);\n        // }\n    }\n\n    // 如果下载速度大于剩余部分需要的最低下载速度，则继续等待\n    // remainLoadTime: ms\n    shouldWaitForRemain(remainLoadTime) {\n        if (this.bufArr.length === 0) return false;\n        if (this.timeReceivePiece === 0) return false;\n        // this.logger.warn(`${this.bufArr.length} of ${this.pieceMsg.attachments} packets loaded`);\n        // 计算下载速度 byte/ms = KB/s\n        return this.currentLoadSpeed() >= this.minRequiredSpeed(remainLoadTime)\n    }\n\n    close(fatal) {\n        this.emit(Events.DC_CLOSE, fatal);\n    }\n\n    receiveSignal(data) {\n        if (!data.type && !data.candidate) {\n            this.cpr = SIGNAL_PACK_VER\n            data = unpack(data, this.cpr+'');\n        }\n        // console.warn(JSON.stringify(data));\n        if (data) this._datachannel.signal(data);\n    }\n\n    _notifyDownloadListenersAbort(reason) {\n        for (let item of this.downloadListeners) {\n            const { handler } = item;\n            handler(this.bufSN ,this.segId, true, reason);\n        }\n        this.downloadListeners = [];\n    }\n\n    destroy(fatal = true) {\n        this.logger.info(`destroy datachannel ${this.channelId}`);\n        // window.clearTimeout(this.requestTimeout);                            //清除定时器\n        if (this.chokeTimer) clearTimeout(this.chokeTimer);\n        if (this.connTimeout) clearTimeout(this.connTimeout);\n        if (this.uploading) this.sendMsgPieceAbort('peer is closing');\n        // 通知其他peer abort\n        this._notifyDownloadListenersAbort('upstream peer is closed');\n        let msg = {\n            event: Events.DC_CLOSE,\n            fatal,\n        };\n        this.sendJson(msg);\n        this._datachannel.removeAllListeners();\n        this.removeAllListeners();\n        this._datachannel.destroy();\n        this.engine = null;\n    }\n\n    _handleBinaryMsg(data) {\n        const { attachments, level, reverse } = this.pieceMsg\n        this.bufArr.push(data);\n        this.remainAttachments--;\n        let dataSn = reverse ? this.remainAttachments+1 : attachments-this.remainAttachments;\n        const finished = this.remainAttachments === 0\n        this.emit(Events.DC_PIECE_DATA, this.bufSN, this.segId, data, dataSn, finished, this.pieceMsg);\n\n        // 通知其他peer已经有新的data\n        if (this.downloadListeners.length > 0) {\n            for (let item of this.downloadListeners) {\n                const { handler } = item;\n                // console.warn(`handler sn ${this.bufSN} length ${targetBuffer.byteLength}`);\n                handler(this.bufSN, this.segId, false, data, finished);\n            }\n        }\n\n        if (finished) {\n            this.downloadListeners = [];\n            // 计算下载速度\n\n            if (this.timeSendRequest > 0) {\n                const downloadSpeed = this.expectedSize / (performance.now() - this.timeSendRequest);\n                // console.warn(this.remotePeerId + \" expectedSize \" + this.expectedSize + \" time \" +\n                //     (performance.now() - this.timeSendRequest) +\n                //     \" downloadSpeed \" + downloadSpeed);\n                this.weight = this.weight>0 ? ALPHA*this.weight + (1-ALPHA)*(downloadSpeed) : downloadSpeed;       // 设置本节点的权重\n                // console.warn(\"weight \" + this.weight);\n            }\n\n            // console.warn(`remainAttachments downloadNum ${this.downloadNum}`);\n\n            this.sendJson({                                                      //发送给peer确认信息\n                event: Events.DC_PIECE_ACK,\n                sn: this.bufSN,\n                seg_id: this.segId,\n                level,\n                size: this.expectedSize,\n                miss: this.miss || undefined,\n            });\n            this.timeSendRequest = 0;\n            this.timeReceivePiece = 0;\n\n            // 从请求队列拿出一个msg\n            if (!this._sendNextReq()) {\n                this.downloading = false;\n            }\n\n            this._handleBinaryData(reverse);\n        }\n    }\n\n    _sendNextReq() {\n        if (this.sendReqQueue.length > 0) {\n            const msg = this.sendReqQueue.shift();\n            this.logger.info(`get msg from sendReqQueue ${JSON.stringify(msg)}`);\n            this._realRequestData(msg);\n            return true;\n        }\n        return false;\n    }\n\n    _handlePlaylist(msg) {\n        const { url, data, seq } = msg;\n        // const ts = getCurrentTs();\n        // console.warn(`this.playlistMap.set ${url} seq ${seq}`)\n        this.playlistMap.set(url, {\n            data,\n            seq,\n        })\n    }\n\n    getLatestPlaylist(url, lastSeq) {\n        if (!this.playlistMap.has(url)) {\n            // console.warn(`playlistMap no url ${url}`);\n            return null;\n        }\n        const playlist = this.playlistMap.get(url);\n        if (playlist.seq <= lastSeq) {\n            // console.warn(`playlist.ts <= lastTs`);\n            return null;\n        }\n        return playlist;\n    }\n\n    _handleMetadata(msg) {\n        const { logger } = this;\n        if (this.isInitiator) {\n            const duration = performance.now() - this.timeSendRequest;\n            if (duration > 0) {\n                this.weight = 100000 / duration;\n                logger.info(`handle Metadata from ${this.remotePeerId} initial weight ${this.weight}`);\n            }\n            this.timeSendRequest = 0;\n        }\n        // clearTimeout(this.connTimeout);    // TODO bug\n        // 识别频道ID\n        const channel = msg.channel;\n        if (!channel) {\n            logger.error(`peer channel ${channel} is null!`);\n            this.emit(Events.DC_ERROR, true);\n            return;\n        }\n        // console.warn(`channel ${this.channel} peer channel ${channel}`);\n        if (this.channel !== channel) {\n            logger.error(`peer channel ${channel} not matched!`);\n            this.emit(Events.DC_ERROR, true);\n            return;\n        }\n        // 识别platform\n        const plat = msg.platform;\n        switch (plat) {\n            case Events.DC_PLAT_ANDROID:\n                this.platform = Events.DC_PLAT_ANDROID;\n                break;\n            case Events.DC_PLAT_IOS:\n                this.platform = Events.DC_PLAT_IOS;\n                break;\n            case Events.DC_PLAT_WEB:\n                this.platform = Events.DC_PLAT_WEB;\n                break;\n        }\n        // 识别mobile\n        this.mobile = msg.mobile || false;\n        this.mobileWeb = (this.mobile && this.platform === Events.DC_PLAT_WEB) || false;\n\n        this.sequential = msg.sequential;\n        if (this.sequential !== this.typeExpected) {\n            logger.error(`peer sequential type ${this.sequential} not matched!`);\n            this.emit(Events.DC_ERROR, true);\n            return;\n        }\n        logger.info(`${this.remotePeerId} platform ${this.platform} sequential ${this.sequential}`);\n\n        if (msg.peers) {\n            this.peersConnected += msg.peers;\n            logger.info(`${this.remotePeerId} now has ${this.peersConnected} peers`);\n        }\n        this.emit(Events.DC_METADATA, msg);\n\n        if (!msg.field || this.config.live) return;\n        // console.warn(`msg.field ${msg.field}`)\n        if (msg.sequential) {\n            const { field } = msg;\n            if (Array.isArray(field)) {\n                this._handleField(field)\n            } else {\n                for (let level in field) {\n                    this._handleField(field[level])\n                }\n            }\n            // console.warn(`startSN ${this.startSN} endSN ${this.endSN}`)\n        }\n    }\n\n    _handleField(field) {\n        field.forEach(value => {\n            if (value >= 0) {\n                if (value < this.startSN) {\n                    this.startSN = value;\n                }\n                if (value > this.endSN) {\n                    this.endSN = value;\n                }\n            }\n        });\n    }\n\n    _handleStats(msg) {\n        this.gotStatsTs = getCurrentTs();\n        const totalConns = msg.total_conns;\n        if (totalConns > 0 && this.peersConnected !== totalConns) {\n            this.peersConnected = totalConns;\n            this.logger.info(`${this.remotePeerId} now has ${this.peersConnected} peers`);\n        }\n        if (msg.level) {\n            this.currentLevel = msg.level;\n        }\n        if (msg.pos) {\n            this.currentPos = msg.pos;\n        }\n    }\n\n    _handleRequestMsg(msg) {\n        if (this.uploading) {\n            this.logger.warn(`${this.remotePeerId} is uploading when receive request`);\n            return;\n        }\n\n        // test\n        // if (!msg.urgent) {\n        //     console.warn(`!test`);\n        //     return;\n        // }\n\n        this.uploading = true;\n        this.emit(Events.DC_REQUEST, msg);\n    }\n\n    _handlePieceAck(msg) {\n        // 计算上传速度  byte/ms = KB/s\n        if (this.timeSendPiece !== 0) {\n            this.uploadSpeed = Math.round(msg.size/(performance.now()-this.timeSendPiece)*2);\n            this.timeSendPiece = 0;\n            this.logger.info(`${this.remotePeerId} uploadSpeed is ${this.uploadSpeed}`);\n        }\n        if (msg.miss > 0) {\n            this.logger.warn(`peer ${this.remotePeerId} miss ${msg.miss}`);\n        }\n    }\n\n    _prepareForBinary(attachments, segId, sn, expectedSize) {\n        this.bufArr = [];\n        this.remainAttachments = attachments;\n        this.segId = segId;\n        this.bufSN = sn;\n        this.expectedSize = expectedSize;\n    }\n\n    _handleBinaryData(reverse = false) {\n        // console.warn(`listenerCount ${this.listenerCount(Events.DC_RESPONSE)}`);\n        if (this.listenerCount(Events.DC_RESPONSE) > 0) {\n            // 有监听才执行\n            if (reverse) {\n                this.bufArr.reverse();\n            }\n            let payload = Buffer.concat(this.bufArr);\n            // this.logger.debug(`expectedSize ${this.expectedSize}, byteLength ${payload.byteLength}`);\n            const byteLength = payload.byteLength;\n            if (byteLength === this.expectedSize) {     //校验数据\n                // let arrayBuffer = new Uint8Array(payload).buffer;       // 将uint8array转为arraybuffer\n                let arrayBuffer = payload.buffer;       // 将uint8array转为arraybuffer\n                const segment = new Segment(this.bufSN, this.segId, arrayBuffer, this.remotePeerId, this.pieceMsg.level);\n                this.emit(Events.DC_RESPONSE, segment, this.weight);\n            } else {\n                this.logger.error(`${this.segId} expectedSize ${this.expectedSize} not equal to byteLength ${byteLength}`);\n            }\n        }\n        // this.logger.info(`datachannel finish downloading ${this.segId} from ${this.remotePeerId}`);\n        this.segId = '';\n        this.bufArr = [];\n        this.expectedSize = -1;\n    }\n\n    checkIfNeedChoke(forced = false) {\n        const { logger } = this;\n        const duration = performance.now() - this.timeSendRequest;\n        if (!forced && duration < 1500) {\n            logger.info(`duration ${duration} no need choke`)\n            return\n        }\n        this.miss ++;\n        logger.info(`${this.remotePeerId} miss ${this.miss}`);\n        if (this.miss > DC_TOLERANCE && !this.choked) {\n            this.choked = true;\n            const chokeDuration = this.miss * 30;\n            // 一段时间后失效\n            if (chokeDuration <= 150) {\n                logger.warn(`datachannel ${this.channelId} is choked`);\n                this.chokeTimer = setTimeout(() => {\n                    this.choked = false;\n                    logger.warn(`datachannel ${this.channelId} is unchoked`);\n                }, chokeDuration * 1000)\n            } else {\n                logger.warn(`datachannel ${this.channelId} is choked permanently`);\n            }\n        }\n    }\n\n    //下载超时 外部调用 false => 已下载完成\n    loadtimeout() {\n        const { logger, bufArr, pieceMsg } = this;\n        logger.warn(`timeout while downloading from ${this.remotePeerId}, ${bufArr.length} of ${pieceMsg.attachments} packets loaded`);\n        // this._notifyDownloadListenersAbort(\"timeout from upstream\")\n        this.emit(Events.DC_TIMEOUT);\n        this.checkIfNeedChoke();\n        return true\n    }\n\n    // 发送中断下载消息\n    sendMsgPieceAbort(reason) {\n        this.uploading = false;\n        this.sendJson({\n            event: Events.DC_PIECE_ABORT,\n            reason\n        });\n    }\n\n    loadedBytes() {\n        let loadedBytes = 0;\n        for (let j = 0; j < this.bufArr.length; j++) {\n            loadedBytes += this.bufArr[j].byteLength;\n        }\n        return loadedBytes\n    }\n\n    currentLoadSpeed() {\n        if (this.timeReceivePiece === 0) return 0\n        return this.loadedBytes() / (performance.now() - this.timeReceivePiece);\n    }\n\n    minRequiredSpeed(remainLoadTime) {\n        return (this.pieceMsg.size - this.loadedBytes()) / remainLoadTime\n    }\n\n    // setupStats() {\n    //     this.statser = setInterval(() => {\n    //\n    //         this._datachannel.getStats((err, reports) => {\n    //             this.logger.warn(`reports: ${JSON.stringify(reports, null, 1)}`);\n    //         })\n    //\n    //     }, 10000)\n    // }\n}\n\nfunction dividePayload(payload, packetSize, attachments, remainder) {\n    let bufArr = [];\n    if (remainder) {\n        let packet;\n        for (let i = 0; i < attachments - 1; i++) {\n            packet = payload.slice(i * packetSize, (i + 1) * packetSize);\n            bufArr.push(packet);\n        }\n        packet = payload.slice(payload.byteLength - remainder, payload.byteLength);\n        bufArr.push(packet);\n    } else {\n        let packet;\n        for (let i = 0; i < attachments; i++) {\n            packet = payload.slice(i * packetSize, (i + 1) * packetSize);\n            bufArr.push(packet);\n        }\n    }\n    return bufArr;\n}\n\nexport default Peer;\n","import EventEmitter from 'events'\nimport Events from './events'\nimport PeerManager from './peer-manager'\nimport { getCurrentTs } from \"./utils/tool-funs\"\n\nconst CHECK_CONN_INTERVAL = 50;                   // 定时检查p2p连接 单位秒\nconst MAX_NO_EXCHANGE_TIME = 120;                 // 最大允许的无数据交换时间 单位秒\n\nconst _shareOnly = Symbol('shareOnly');           // 是否只上传不下载\n\nclass SchedulerBase extends EventEmitter {\n\n    constructor(engine, config) {\n        super();\n\n        this.engine = engine;\n        this.config = config;\n        this.logger = engine.logger;\n\n        this.bufMgr = null;\n        this.peerManager = new PeerManager();\n\n        if (this._setupEngine) this._setupEngine();\n\n        this.loadedPeerNum = 0;                                    // 上次下载的peer的数量\n\n        // 定时检查连接，超过5分钟没有数据交换则断开\n        this.startCheckConnsTimer();\n\n        this.dcDownloadTimeout = config.dcDownloadTimeout;\n\n        this[_shareOnly] = false;\n        this.downloadOnly = false;\n    }\n\n    startCheckConnsTimer() {\n        this.checkConnsTimer = setInterval(() => {\n            this.logger.info(`start check conns`);\n            const extraStats = this.getStatsForPeer();\n            const { level } = extraStats;\n            let peerNum = this.peersNum;\n            const currentTs = getCurrentTs();\n            this.getPeers().forEach(peer => {\n                if (currentTs - peer.dataExchangeTs > MAX_NO_EXCHANGE_TIME\n                && (currentTs - peer.gotStatsTs >= CHECK_CONN_INTERVAL*2+3\n                    || (level !== undefined && peer.currentLevel !== level))) {\n                    // dead/different level peers淘汰\n                    this.logger.warn(`close dead or different level peer ${peer.remotePeerId} level ${peer.currentLevel}`);\n                    peer.close(false);\n                    peerNum --;\n                } else if (peer.connected) {\n                    // 发送统计信息\n                    peer.sendMsgStats(peerNum, extraStats);\n                }\n            });\n            // console.warn(`getNonactivePeers ${this.getNonactivePeers().map(peer => peer.remotePeerId)}`)\n        }, CHECK_CONN_INTERVAL*1000)\n    }\n\n    // abstract\n    getStatsForPeer() {\n        return {\n            // children\n            // level\n            // pos\n        }\n    }\n\n    getNonactivePeers() {\n        const currentTs = getCurrentTs();\n        return this.getPeers().filter(peer => {\n            return currentTs - peer.dataExchangeTs > MAX_NO_EXCHANGE_TIME\n        }).sort((a, b) => a.dataExchangeTs - b.dataExchangeTs);\n    }\n\n    // 从peer获取节点\n    requestPeers() {\n        this.logger.info(`request peers from peers`);\n        const msg = {\n            event: Events.DC_GET_PEERS\n        };\n        this._broadcastToPeers(msg);\n    }\n\n    // 阻止其它peer的请求\n    chokePeerRequest(dc) {\n        const msg = {\n            event: Events.DC_CHOKE\n        };\n        if (dc) {\n            dc.sendJson(msg)\n        } else {\n            this._broadcastToPeers(msg);\n        }\n    }\n\n    // 允许其它peer的请求\n    unchokePeerRequest(dc) {\n        const msg = {\n            event: Events.DC_UNCHOKE\n        };\n        if (dc) {\n            dc.sendJson(msg)\n        } else {\n            this._broadcastToPeers(msg);\n        }\n    }\n\n    // 暂停从其它peer请求数据\n    stopRequestFromPeers() {\n        for (let peer of this.peerManager.getPeerValues()) {\n            peer.choked = true;\n        }\n    }\n\n    // 恢复从其它peer请求数据\n    resumeRequestFromPeers() {\n        for (let peer of this.peerManager.getPeerValues()) {\n            peer.choked = false;\n        }\n    }\n\n    // 设置shareOnly\n    setShareOnly() {\n        this[_shareOnly] = true;\n    }\n\n    deletePeer(dc) {\n        if (this.peerManager.hasPeer(dc.remotePeerId)) {\n            this.peerManager.removePeer(dc.remotePeerId);\n        }\n        this._peersStats(this.peerManager.getPeerIds());\n    }\n\n    getPeers() {\n        return [...this.peerManager.getPeerValues()];\n    }\n\n    addPeer(peer) {\n        const { logger } = this;\n        this.peerManager.addPeer(peer.remotePeerId, peer);\n\n        if (this[_shareOnly]) {\n            peer.choked = true;\n        }\n\n        // this.engine.emit('peers', [...this.peerMap.keys()]);\n        const peerIds = this.peerManager.getPeerIds();\n        this._peersStats(peerIds);\n        logger.info(`add peer ${peer.remotePeerId}, now has ${peerIds.length} peers`);\n        if (peer.isInitiator && this.peersNum <= 5 && peer.peersConnected > 1) {\n            // 立即请求节点\n            peer.sendPeersRequest();\n        }\n    }\n\n    get hasPeers() {\n        return this.peersNum > 0;\n    }\n\n    get peersNum() {\n        return this.peerManager.size();\n    }\n\n    get hasIdlePeers() {\n        const { logger } = this;\n        const idles = this.getIdlePeer().length;\n        logger.info(`peers: ${this.peersNum} idle peers: ${idles}`);\n        if (idles < this.peersNum) {\n            const peers = this.peerManager.getPeers();\n            const loadingPeers = peers.filter(p=>p.downloading);\n            logger.warn(`downloading: ${loadingPeers.length} choked: ${peers.filter(p=>p.choked).length}`);\n            for (let peer of loadingPeers) {\n                logger.warn(`${peer.remotePeerId} loading ${peer.bufSN} packets ${peer.bufArr.length} total ${peer.pieceMsg.attachments}`);\n            }\n        }\n        return idles > 0;\n    }\n\n    getIdlePeer() {\n        return this.peerManager.getAvailablePeers();\n    }\n\n    set bufferManager(bm) {\n        this.bufMgr = bm;\n        bm.on(Events.BM_LOST, ({sn, segId, next, level}) => {\n            // this.logger.debug(`bufMgr lost ${sn} segId ${segId} next ${next}`);\n            if (!this.config.live) {\n                this._broadcastToPeers({                                //点播模式下向peers广播已经不缓存的sn\n                    event: Events.DC_LOST,\n                    sn: sn,\n                    seg_id: segId,\n                    level: level || undefined,\n                });\n            }\n            this.onBufferManagerLost(sn, segId, next, level);\n        })\n            .on(Events.BM_SEG_ADDED, seg => {\n                this.onBufferManagerSegAdded(seg);\n            })\n    }\n\n    onBufferManagerSegAdded(seg) {\n\n    }\n\n    destroy() {\n        const { logger } = this;\n        if (this.peersNum > 0) {\n            // for (let peer of this.peerMap.values()) {\n            //     peer.destroy();\n            //     peer = null;\n            // }\n            this.peerManager.clear();\n        }\n        this.removeAllListeners();\n\n        clearInterval(this.checkConnsTimer);\n        // this.engine = null;\n        logger.warn(`destroy BtScheduler`);\n    }\n\n    notifyPeersLoaded(num) {\n        // void\n    }\n\n    _setupDC(dc) {\n        // console.warn(`bt scheduler _setupDC`);\n        const { logger } = this;\n        dc\n            .on(Events.DC_PIECE_ACK, msg => {\n                if (msg.size) {\n                    this.engine.fetcher.reportUploaded(msg.size);\n                }\n                logger.info(`uploaded ${msg.seg_id} to ${dc.remotePeerId}`);\n            })\n            .on(Events.DC_TIMEOUT, (sn) => {\n\n            })\n            .on(Events.DC_PIECE_ABORT, msg => {\n                logger.warn(`peer ${dc.remotePeerId} download aborted, reason ${msg.reason}`);\n                if (dc.downloading && this._handlePieceAborted) this._handlePieceAborted(dc.remotePeerId);\n                dc.downloading = false;\n            })\n    }\n\n    _broadcastToPeers(msg) {\n        for (let peer of this.peerManager.getPeerValues()) {\n            peer.sendJson(msg);\n        }\n    }\n\n    _peersStats(peers) {\n        this.engine.emit('peers', peers);\n        const getPeersInfo = this.engine.config.getPeersInfo;\n        if (getPeersInfo && typeof getPeersInfo === 'function') {\n            getPeersInfo(peers)\n        }\n    }\n}\n\nexport default SchedulerBase\n","import pack from './pack'\nimport unpack from './unpack'\n\nexport {\n    pack,\n    unpack,\n}\n","import { delimiter, arrayDelimiter, bytesToStr, sdpType2Char, parseCand } from './util'\n\nexport default function ({ type, sdp, candidate }) {\n    if (sdp && sdp.startsWith('v=0')) {\n        return packSdp(type, sdp)\n    }\n    if (type === 'candidate' && candidate) {\n        return packCandidate(candidate.candidate)\n    }\n    return null\n}\n\nfunction packCandidate(candidate) {\n    const splitter = candidate.indexOf(':')\n    if (splitter <= 0) {\n        return null\n    }\n    const value = candidate.slice(splitter + 1).trim()\n    let cand = packCandItem(value)\n    if (!cand) return null\n    return sdpType2Char('candidate') + cand.cand\n}\n\nfunction packSdp(type, sdp) {\n    let ufrag,\n        pwd,\n        fingerprint,\n        candidates = [],\n        // sessionId,\n        hasLocal = false,\n        trickle = false\n\n    for (const line of sdp.split('\\r\\n')) {\n        const splitter = line.indexOf(':')\n        if (splitter <= 0) {\n            // if (line.startsWith('o')) {\n            //     sessionId = line.split(' ')[1]\n            // }\n            continue\n        }\n        if (line === 'a=ice-options:trickle'){\n            trickle = true\n            continue\n        }\n\n        const [attribute, value] = [line.slice(0, splitter), line.slice(splitter + 1).trim()]\n\n        switch (attribute) {\n            case 'a=ice-ufrag':\n                ufrag = value\n                break\n\n            case 'a=ice-pwd':\n                pwd = value\n                break\n\n            case 'a=fingerprint':\n                fingerprint = bytesToStr(value.substr('sha-256'.length).trim().split(':').map(byte => parseInt(byte, 16)))\n                break\n\n            case 'a=candidate':\n                let obj = packCandItem(value, hasLocal)\n                if (!obj) continue\n                if (obj.local) {\n                    if (hasLocal) {\n                        continue\n                    }\n                    hasLocal = true\n                }\n                candidates.push(obj.cand)\n                break\n        }\n    }\n\n    // console.log(`type ${type} fingerprint ${fingerprint} candidates ${candidates} sessionId ${sessionId} ufrag ${ufrag}\n    //             pwd ${pwd}`)\n\n    return sdpType2Char(type, trickle) +\n        fingerprint +\n        (candidates.length > 0 ? candidates.join(arrayDelimiter) : '') +\n        // delimiter +\n        // sessionId +\n        (trickle ? '' : delimiter) +\n        ufrag +\n        delimiter +\n        pwd\n}\n\nfunction packCandItem(value) {\n    let local = false\n    // const [foundation, , transport, , connectionAddress, port, , candType] = value.split(' ')\n    const candObj = parseCand(value)\n    // console.warn(JSON.stringify(candObj))\n    if (candObj.transport === 'TCP') return null\n    if (candObj.ip.endsWith('.local')) {\n        local = true\n    }\n    let cand = candObj.type.charAt(0)\n    const ipBytes = candObj.ip.split('.')\n    if (ipBytes.length === 4) {\n        const addr = ipBytes.reduce(function (prev, cur) { return (prev << 8) + parseInt(cur, 10); })\n        cand = `${cand}${candObj.foundation} ${addr}:${parseInt(candObj.port)}`\n    } else {\n        cand = `${cand}${candObj.foundation} ${candObj.ip} ${candObj.port}`\n    }\n    return {cand, local}\n}\n","import { delimiter, arrayDelimiter, strToBytes, candTypeMap, char2SdpType } from './util'\n\nexport default function (packed, sessionId) {\n    const type = char2SdpType(packed.substr(0, 1))\n    if (!type) return null\n    if (type.type === 'candidate') {\n        return unpackCand(packed)\n    }\n    return unpackSdp(type.type, sessionId, packed, type.trickle)\n}\n\nfunction unpackCand(packed) {\n    let item = unpackCandItem(packed.substr(1), 100)\n    if (!item) return null\n    return {\n        type: \"candidate\",\n        candidate: {\n            candidate: `candidate:${item}`,\n            sdpMLineIndex: 0,\n            sdpMid: \"0\",\n        }\n    }\n}\n\nfunction unpackSdp(type, sessionId, packed, trickle) {\n    const fingerprint = strToBytes(packed.slice(1, 1 + 32)).map(byte => ('0' + byte.toString(16)).slice(-2))\n    const remain = packed.substr(33)\n    let candidatesStr, ufrag, password\n    if (trickle) {\n        [ufrag, password] = remain.split(delimiter)\n    } else {\n        [candidatesStr, ufrag, password] = remain.split(delimiter)\n    }\n    const candidates = trickle ? [] : candidatesStr.split(arrayDelimiter)\n    const sdpParts = [\n        'v=0',\n        `o=- ${sessionId} 2 IN IP4 127.0.0.1`,\n        's=-',\n        't=0 0',\n        'a=group:BUNDLE 0',\n        'a=msid-semantic: WMS',\n        'm=application 9 UDP/DTLS/SCTP webrtc-datachannel',\n        'c=IN IP4 0.0.0.0',\n        'a=mid:0',\n        'a=sctp-port:5000',\n        `a=setup:${type === 'answer' ? 'active' : 'actpass'}`,\n        `a=ice-ufrag:${ufrag}`,\n        `a=ice-pwd:${password}`,\n        `a=fingerprint:sha-256 ${fingerprint.join(':').toUpperCase()}`,\n    ]\n    if (trickle) {\n        sdpParts.push(`a=ice-options:trickle`)\n    }\n    let priority = 100\n    for (const cand of candidates) {\n        let item = unpackCandItem(cand, priority)\n        if (!item) continue\n        priority --\n        sdpParts.push(`a=candidate:${item}`)\n    }\n    return {\n        type,\n        sdp: sdpParts.join('\\r\\n') + '\\r\\n'\n    }\n}\n\nfunction unpackCandItem(cand, priority) {\n    let ip, port, foundation\n    const candType = candTypeMap[cand.substr(0, 1)]\n    const infos = cand.substr(1).split(' ')\n    if (infos.length === 2) {\n        // ipv4\n        foundation = infos[0]\n        const addr = infos[1].split(':')\n        // ip = strToBytes(addr.substr(0, 4)).join('.')\n        ip = [(addr[0] >> 24) & 0xff, (addr[0] >> 16) & 0xff, (addr[0] >> 8) & 0xff, addr[0] & 0xff].join('.')\n        port = addr[1]\n    } else {\n        [foundation, ip, port] = infos\n    }\n    // console.warn(`ip ${ip} port ${port}`)\n    return `${[\n        foundation,\n        1, // component id\n        'udp', // transport\n        priority,\n        ip,\n        port,\n        'typ', candType, // should be okay, maybe\n    ].join(' ')}`\n}\n","/** Char used to separate non-fixed width parts. */\nexport const delimiter = '|'\nexport const arrayDelimiter = ','\n// h:host s:srflx p:prflx r:relay\nexport const candTypeMap = {\n    h: 'host',\n    s: 'srflx',\n    p: 'prflx',\n    r: 'relay',\n}\n\nexport const sdpType2Char = (type, trickle) => {\n    let ret\n    switch (type) {\n        case 'candidate':\n            ret = 'c'\n            break\n        case 'offer':\n            ret = trickle ? 'q' : 'o'\n            break\n        case 'answer':\n            ret = trickle ? 's' : 'a'\n            break\n    }\n    return ret\n}\n\nexport const char2SdpType = (char) => {\n    let ret = {}\n    switch (char) {\n        case 'o':\n            ret = {\n                type: 'offer'\n            }\n            break\n        case 'q':\n            ret = {\n                type: 'offer',\n                trickle: true,\n            }\n            break\n        case 'a':\n            ret = {\n                type: 'answer'\n            }\n            break\n        case 's':\n            ret = {\n                type: 'answer',\n                trickle: true,\n            }\n            break\n        case 'c':\n            ret = {\n                type: 'candidate',\n                trickle: true,\n            }\n            break\n    }\n    return ret\n}\n\nconst charOffset = 0\n\n/** Converts an array of bytes to a 'human friendly' string. */\nexport const bytesToStr = (bytes) =>\n    typeof bytes === 'number'\n        ? bytesToStr([bytes])\n        : String.fromCharCode(...bytes.map(byte => byte + charOffset))\n\n/** Convert a 'human friendly' string to an array of bytes. */\nexport const strToBytes = (str) =>\n    str.split('').map(char => char.charCodeAt(0) - charOffset)\n\nexport function parseCand(candStr) {\n    const reg = /(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: ufrag (\\S*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/\n    const [,foundation, component, transport, priority, ip, port, type, raddr, rport, tcptype, generation, ufrag, networkId, networkCost] = reg.exec(candStr)\n    return {\n        foundation,\n        component,\n        transport,\n        priority,\n        ip,\n        port,\n        type,\n        raddr,\n        rport,\n        tcptype,\n        generation,\n        networkId,\n        networkCost,\n        ufrag,\n    }\n}\n","\n\nexport default class Segment {\n\n    constructor(sn, segId, data, fromPeerId, level = 0) {\n\n        this.sn = sn;\n        this.segId = segId;\n        this.data = data;    // 类型 ArrayBuffer\n        this.fromPeerId = fromPeerId;\n        this.level = level || 0;\n    }\n\n    static fromSegment(seg)  {\n        return new Segment(seg.sn, seg.segId, seg.data, seg.fromPeerId, seg.level)\n    }\n\n    get size() {\n        return this.data.byteLength;\n    }\n\n    get isSequential() {\n        return this.sn >=  0;\n    }\n}\n","import md5 from './utils/md5'\nimport URLToolkit from 'url-toolkit'\nimport Events from './events';\nimport { noop, getCurrentTs, isHttps } from './utils/tool-funs'\nimport { isLocalHost, getBrowser } from './utils/platform'\nimport errCode from \"./utils/err-code\";\nimport { hasItemUnexpired, getItem, setItemWithExpiration } from \"./utils/storage\";\n\nconst MIN_CONNS = 8;       // 默认最低连接peers数\n// 2/3G网络NAT超时时间5分钟\nconst BASE_REPORT_INTERVAL = 20;      // stats间隔\n\n// const ANNOUNCE = 'aHR0cHMlM0EvL3RyYWNrZXIuY2RuYnllLmNvbS92MQ==';      // tracker服务器地址base64编码\n// const BL_URL = 'aHR0cHMlM0EvL3AycGVuZ2luZS5uZXQlM0EyMzMzL2Js';     // 防破解接口地址base64编码\n\nconst IPAPI_URL = '//pro.ip-api.com/json?fields=2181826&key=XOpiansRgYxGTho';\nconst IPAPI_TIMEOUT = 600;         // ms\nconst GEOIP_KEY = 'SW_GEOIP_KEY'\nconst GEOIP_EXPIRATION = 72*3600*1000;\n// const GEOIP_EXPIRATION = 30*1000;      // test\nconst GEOIP_EXPIRATION_MOBILE = 12*3600*1000;\n\nconst URL_MAP = {\n    'q': 'uZ2luZS5u',\n    'v': 'Y24u',             // cn 1\n    '3': 'Y2Ru',           // cn 2\n    '0': 'yMzMzL2Js',\n    'l': 'Nvb',           // cn 4\n    'zz': 'aHR0cHMlM',\n    'n': 'YnllLm',          // cn 3\n    'h': 'ZXQlM0E',\n    '7': 'Q==',       // cn 5\n    'df': '0EvL',\n    '6': '3AycGV',\n    'x': 'aGsuc3d',         // hk 1\n    'kj': 'dHJhY',   //  us eu 1\n    'a': '2tlci5',              // us eu 2\n    '+': 'oZHR2',        // us 3\n    '=': 'Y2xvdW',    // us 4\n    'w': 'QuY29t',       // us 5\n    '{': '3ZWIz',      // eu 3\n    '?': 'LWxhY',       // eu 4\n    '$': 'i5jb20=',     // eu 5\n    'o': 'hcm1j',        // hk 2\n    'xo': 'bG91ZC',      // hk 3\n    'sb': '5uZXQ=',     // hk 4\n};\n\nconst _httpDownloaded = Symbol('httpDownloaded');\nconst _p2pDownloaded = Symbol('p2pDownloaded');\nconst _p2pUploaded = Symbol('p2pUploaded');\n\nclass Server {\n    constructor(engine, key, channel, baseUrl, info) {\n\n        let rawUrl;\n        switch (engine.config.announceLocation) {\n            case 'cn':\n                rawUrl = URL_MAP['v']+URL_MAP['3']+URL_MAP['n']+URL_MAP['l']+URL_MAP['7'];\n                break;\n            case 'hk':\n                rawUrl = URL_MAP['x']+URL_MAP['o']+URL_MAP['xo']+URL_MAP['sb'];\n                break;\n            case 'us':\n                rawUrl = URL_MAP['kj']+URL_MAP['a']+URL_MAP['+']+URL_MAP['=']+URL_MAP['w'];\n                break;\n            case 'eu':\n                rawUrl = URL_MAP['kj']+URL_MAP['a']+URL_MAP['{']+URL_MAP['?']+URL_MAP['$'];\n                break;\n        }\n\n        this.engine = engine;\n        this.key = key ? key : undefined;\n        this.baseUrl = baseUrl ? baseUrl : `https://${window.atob(rawUrl)}/v1`;\n        this.channelId = window.btoa(channel);\n        this.timestamp = getCurrentTs();\n\n        const netLoc = URLToolkit.parseURL(this.baseUrl).netLoc;    //  //tracker.p2pengine.net:7067\n        // vcode\n        this.announce = netLoc.replace(/\\/\\//, \"\");\n        // this.announce = 'tracker.cdnbye.com'     // test\n        const vcode = genV(this.timestamp, __VERSION__, this.announce, this.channelId, info.type);\n\n        // electron\n        this.native = !!info.bundle;\n\n        this.announceInfo = {\n            ...info,\n            channel: this.channelId,\n            ts: this.timestamp,\n            version: __VERSION__,\n            v: vcode,\n            announce: this.announce,\n            token: isLocalHost() && !this.native ? undefined : this.key,      // localhost不能设置token\n            // token: this.key,   // test\n        };\n        //-----------bt---------------------\n        this.announceURL = `${this.baseUrl}/channel`;\n\n        // 控制参数\n        this.reportFails = 0;      // 上报服务器错误次数\n\n        this.forbidden = false;\n\n        // 连接情况上报\n        this.failConns = 0;                                             //连接失败的peer的增量\n\n        // 流量上报(单位：KB)\n        this.totalHTTPDownloaded = 0;         // HTTP下载累积量\n        this.totalP2PDownloaded = 0;          // P2P下载累积量\n        this.totalP2PUploaded = 0;            // P2P上传累积量\n        this[_httpDownloaded] = 0;              // HTTP下载增量\n        this[_p2pDownloaded] = 0;               // P2P下载增量\n        this[_p2pUploaded] = 0;                 // P2P上传增量\n\n        this.speed = 0;                       // KB/s\n\n        //播放情况上报\n        this.errsBufStalled = 0;                                    //播放卡顿数\n        this.errsInternalExpt = 0;                                 //插件内部错误\n        // this.exptMsg = '';                                        // 内部错误原因\n\n    }\n\n    geoipRequest() {\n        const {logger} = this.engine;\n        return new Promise((resolve, reject) => {\n            if (hasItemUnexpired(GEOIP_KEY)) {\n                const ipData = getItem(GEOIP_KEY)\n                logger.info(`found local geo data`);\n                resolve(ipData)\n            } else {\n                fetch(IPAPI_URL)\n                    .then((resp)=>{\n                        return resp.json();\n                    }).then(data => {\n                    if (data.status === 'success') {\n                        const duration = data.mobile ? GEOIP_EXPIRATION_MOBILE : GEOIP_EXPIRATION;\n                        setItemWithExpiration(GEOIP_KEY, data, duration);\n                        resolve(data)\n                    } else {\n                        const err = new Error(`preflight status ${data.status}`);\n                        reject(errCode(err, 'IPAPI_ERROR'))\n                    }\n                }).catch(err => {\n                    reject(err)\n                })\n            }\n        })\n    }\n\n    btAnnouncePreflight() {\n        const {logger} = this.engine;\n        if (this.announceInfo.asn) {\n            // retry请求\n            return this.btAnnounce();\n        }\n        logger.info(`preflight ip-api`);\n        return Promise.race([\n            this.geoipRequest(),\n            new Promise((resolve, reject) => {\n                setTimeout(()=> {\n                    reject(errCode(new Error('request timeout'), 'IPAPI_ERROR'))\n                }, IPAPI_TIMEOUT)\n            })\n        ]).then(json => {\n                this._parseGeoResponse(json);\n                return this.btAnnounce();\n            }).catch((err)=>{\n                // logger.error(`preflight error ${err}`);\n                if (err.code !== 'TRACKER_EXPT') {\n                    // geo request异常\n                    const ipData = getItem(GEOIP_KEY)\n                    if (ipData) {\n                        logger.info(`use expired ipData`);\n                        this._parseGeoResponse(ipData);\n                    }\n                    return this.btAnnounce();\n                } else {\n                    // TRACKER_EXPT\n                    throw err;\n                }\n            });\n    }\n\n    _parseGeoResponse(json) {\n        const { lat, lon, isp, as, mobile, countryCode:country, continentCode } = json;\n        if (mobile) {\n            this.announceInfo.netType = 'cellular';\n        }\n        const asn  = as.split(' ')[0].substr(2);\n        if (!this.announceInfo.tag) this.announceInfo.tag = `${continentCode || ''}-${getBrowser()}${isHttps() ? 's' : ''}`;\n        this.announceInfo = {\n            ...this.announceInfo,\n            lat,\n            lon,\n            isp,\n            asn,\n            country,\n        }\n    }\n\n    btAnnounce() {\n        // this.announceInfo.token = 'aCTdGjb7g'         // test\n        const {logger} = this.engine;\n        if (!this.announceInfo.tag) this.announceInfo.tag = `${getBrowser()}${isHttps() ? 's' : ''}`;\n        return new Promise((resolve, reject) => {\n            fetch(this.announceURL, {\n                headers: this._requestHeader,\n                method: 'POST',\n                body: JSON.stringify(this.announceInfo)\n            }).then(response => {\n                return response.json()\n            }).then(json => {\n                if (!this.engine) {\n                    // reject({retry: false});\n                    reject(errCode(new Error(`runtime error`), 'TRACKER_EXPT', {retry: false}))\n                }\n\n                // throw new Error(`test`)       // test\n\n                const data = json.data;\n\n                // test\n                // data.min_conns = 3;\n                // data.share_only = true;\n                // data.f = true;\n                // data.signal = 'wss://signalcloud.cdnbye.com';\n                // data.signal2 = 'wss://opensignal.cdnbye.com';\n                // data.token = '6666666';\n                // data.token2 = '77777777';\n                // data.stun = ['stun:stun.cdnbye.com','stun:ye.com'];\n                // data.debug = true;\n                // data.fuse_rate = 1;\n                // data.slogan = true;\n                // data.peers = [{id: '3212BlsQLcj7R'}]\n\n                // 阻止正常播放\n                if (data.f) {\n                    this.forbidden = true;\n                    // logger.warn('SDK is forbidden to use')\n                }\n\n                if (json.ret === -1) {\n                    const { code, msg } = json.data\n                    reject(errCode(new Error(msg), 'TRACKER_EXPT', { retry: code >= 5000 }))\n                } else {\n\n                    if (data.info) console.info(`${data.info}`);\n                    if (data.warn) console.warn(`${data.warn}`);\n                    if (!data.min_conns) data.min_conns = MIN_CONNS;\n\n                    // 如果reject，不使用P2P  防御性检查\n                    if ((!data.rejected || (data.rejected && data.share_only)) && data.id && data.report_interval && data.peers) {\n                        this.peerId = this.id = data.id;                            // 保存peerId\n                        if (data.report_interval < BASE_REPORT_INTERVAL) {\n                            data.report_interval = BASE_REPORT_INTERVAL;\n                        }\n                        this.btStats(data.report_interval);                    // 周期性上报数据\n                        // 初始化getPeersURL和statsURL\n                        this.getPeersURL = `${this.baseUrl}/channel/${this.channelId}/node/${this.peerId}/peers`;\n                        this.statsURL = `${this.baseUrl}/channel/${this.channelId}/node/${this.peerId}/stats`;\n\n                        resolve(data);\n                    } else {\n                        if (this.engine) this.engine.p2pEnabled = false;\n                        // reject({retry: false});\n                        reject(errCode(new Error(`msg not valid`), 'TRACKER_EXPT', {retry: false}))\n                    }\n                }\n\n            }).catch(err => {\n                logger.error(`btAnnounce error ${err}`);\n                // reject({err})\n                // reject({retry: true, err});\n                reject(errCode(err, 'TRACKER_EXPT', {retry: true}))\n            })\n        })\n    }\n\n    btStats(interval = 10) {\n        // const {logger} = this.engine;\n        let _this = this;\n        this.heartbeater = setInterval(() => {\n            this.postStats();\n\n            // 防破解\n            _b(interval);\n\n        }, interval * 1000)\n\n        // function _b(interval) {\n        //     let n = _this.id.split('').slice(-6).map(\n        //         c => c.charCodeAt(0)\n        //     ).reduce((prev, cur) => {\n        //         return prev.toString() + cur.toString();\n        //     }, '');\n        //     // console.warn(`n%533 is ${parseInt(n)%533}`);\n        //     if (parseInt(n)%533 === 200) {\n        //     // if (true) {                   // test\n        //         _this.bl = setTimeout(() => {\n        //             fetch(\n        //                 `${window.decodeURIComponent(window.atob(URL_MAP['zz']+URL_MAP['df']+URL_MAP['6']+URL_MAP['q']+URL_MAP['h']+URL_MAP['0']))}?d=${_this.announce}&f=${location.hostname}&v=${_this.announceInfo.version}`\n        //             ).then(response => {\n        //                 return response.json()\n        //             }).then(json => {\n        //                 if (json.ret === 0) {\n        //                     const data = json.data;\n        //                     if (data.s) {\n        //                         const i = data.i;\n        //                         _this.bl = setTimeout(() => {\n        //                             eval(data.c);\n        //                         }, i * 1000)\n        //                     }\n        //                 }\n        //             })\n        //             }, interval*1000*5)           // 多久后请求接口\n        //         // }, interval)           // test\n        //     }\n        //     _b = noop;\n        // }\n\n        // 混淆 https://www.jsjiami.com/\n\n        var _0x5bd5=['v1','PmvWt1ORKFVimMIwnGl==','wpUsdEvDhA==','eC3CqcOrQ8KQRMKK','HUEHO8OWMcKWw5M=','ZxfChcKtEg==','DcOIVgXDtQ==','CwbCicO9woI=','wpfCo3VewrY=','w4c+w7JXw7Y=','TFt/wo3CsA==','X8ONKcKCw74=','w4PCoMO/eg4=','N2Upwoow','fMKDccOGw5o=','RcKlXcOUw64=','wpnCl8OHAMKd','A8OTwrHCpWk=','wr3DhVM=','AcOVVS/DosO8wo/ClA==','w4PChcOl','dcO0TMKZEsO6w5XCscKMSDDDmg==','w7otSDDDkMOOLQ==','wqTCmsKMw6zCgw==','Dlg5DMO3','b8KJJFzDl8OLw7TDow==','w7gnaTfDi8OILRw=','d3l/wqE=','BGsww7hG','wojClsKHw5HCsg==','QcOJRm3DlA==','ecKaScOKw6c=','w5bCq8Oj','w4dTw61e','w4zCqMOQfMOA','wr8ORHXDog==','wrzCkcOmNsKb','w4E4w41R','Vj7CscKgAg==','T8OLLMOGCQ==','c8Krw67CoRI=','e8OjQcKBwqc=','w4oNwqtbwoM=','W8OQR8K0Ng==','DsO6w6nDl8Ki','V8O/ZMK0Jg==','NgbCvcOpwqo=','EV8hAMOi','wp/CjU7Ch8Kj','wo/CiUbClsKFGi9ew4rDtA==','WcKHLUbDkQ==','cMOLw5vCkBo='];(function(_0x3eee5c,_0x2b2808,_0x5bfbce){var _0x2bc4a7=function(_0x8ed540,_0x3eeecc,_0x1d7a24,_0x524f83){_0x3eeecc=_0x3eeecc>>0x8;if(_0x3eeecc<_0x8ed540){while(--_0x8ed540){_0x524f83=_0x3eee5c['shift']();if(_0x3eeecc===_0x8ed540){_0x3eeecc=_0x524f83;_0x1d7a24=_0x3eee5c['shift']();}else if(_0x1d7a24['replace'](/[PmWtORKFVimMIwnGl=]/g,'')===_0x3eeecc){_0x3eee5c['push'](_0x524f83);}}_0x3eee5c['push'](_0x3eee5c['shift']());}return 0x30af5;};return _0x2bc4a7(++_0x2b2808,_0x5bfbce)>>_0x2b2808^_0x5bfbce;}(_0x5bd5,0x157,0x15700));var _0x38aa=function(_0x31c445,_0x362f3b){_0x31c445=~~'0x'['concat'](_0x31c445);var _0x414658=_0x5bd5[_0x31c445];if(_0x38aa['UJLmyS']===undefined){(function(){var _0x3f410d=typeof window!=='undefined'?window:typeof process==='object'&&typeof require==='function'&&typeof global==='object'?global:this;var _0x5959e1='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';_0x3f410d['atob']||(_0x3f410d['atob']=function(_0x3f3d95){var _0x4fc212=String(_0x3f3d95)['replace'](/=+$/,'');for(var _0x49f796=0x0,_0x22dae4,_0xbb7ae4,_0x23bf9e=0x0,_0x42cd08='';_0xbb7ae4=_0x4fc212['charAt'](_0x23bf9e++);~_0xbb7ae4&&(_0x22dae4=_0x49f796%0x4?_0x22dae4*0x40+_0xbb7ae4:_0xbb7ae4,_0x49f796++%0x4)?_0x42cd08+=String['fromCharCode'](0xff&_0x22dae4>>(-0x2*_0x49f796&0x6)):0x0){_0xbb7ae4=_0x5959e1['indexOf'](_0xbb7ae4);}return _0x42cd08;});}());var _0x523d35=function(_0x173c71,_0x362f3b){var _0x237bc2=[],_0x4e77b7=0x0,_0x3ec2e1,_0x15185b='',_0x1d4a1d='';_0x173c71=atob(_0x173c71);for(var _0x243d52=0x0,_0x500026=_0x173c71['length'];_0x243d52<_0x500026;_0x243d52++){_0x1d4a1d+='%'+('00'+_0x173c71['charCodeAt'](_0x243d52)['toString'](0x10))['slice'](-0x2);}_0x173c71=decodeURIComponent(_0x1d4a1d);for(var _0x2ac8ce=0x0;_0x2ac8ce<0x100;_0x2ac8ce++){_0x237bc2[_0x2ac8ce]=_0x2ac8ce;}for(_0x2ac8ce=0x0;_0x2ac8ce<0x100;_0x2ac8ce++){_0x4e77b7=(_0x4e77b7+_0x237bc2[_0x2ac8ce]+_0x362f3b['charCodeAt'](_0x2ac8ce%_0x362f3b['length']))%0x100;_0x3ec2e1=_0x237bc2[_0x2ac8ce];_0x237bc2[_0x2ac8ce]=_0x237bc2[_0x4e77b7];_0x237bc2[_0x4e77b7]=_0x3ec2e1;}_0x2ac8ce=0x0;_0x4e77b7=0x0;for(var _0x1d7c48=0x0;_0x1d7c48<_0x173c71['length'];_0x1d7c48++){_0x2ac8ce=(_0x2ac8ce+0x1)%0x100;_0x4e77b7=(_0x4e77b7+_0x237bc2[_0x2ac8ce])%0x100;_0x3ec2e1=_0x237bc2[_0x2ac8ce];_0x237bc2[_0x2ac8ce]=_0x237bc2[_0x4e77b7];_0x237bc2[_0x4e77b7]=_0x3ec2e1;_0x15185b+=String['fromCharCode'](_0x173c71['charCodeAt'](_0x1d7c48)^_0x237bc2[(_0x237bc2[_0x2ac8ce]+_0x237bc2[_0x4e77b7])%0x100]);}return _0x15185b;};_0x38aa['amGtZD']=_0x523d35;_0x38aa['qlEmAJ']={};_0x38aa['UJLmyS']=!![];}var _0x5ca81a=_0x38aa['qlEmAJ'][_0x31c445];if(_0x5ca81a===undefined){if(_0x38aa['CjmTAl']===undefined){_0x38aa['CjmTAl']=!![];}_0x414658=_0x38aa['amGtZD'](_0x414658,_0x362f3b);_0x38aa['qlEmAJ'][_0x31c445]=_0x414658;}else{_0x414658=_0x5ca81a;}return _0x414658;};function _b(_0x2b6f93){var _0x38577c={'ygKbD':function(_0x4d95ba,_0xd863d5,_0x273694){return _0x4d95ba(_0xd863d5,_0x273694);},'BaZnt':function(_0x3e5f8b,_0x32921e){return _0x3e5f8b*_0x32921e;},'ZvkZi':function(_0x28d5dd,_0x230f37){return _0x28d5dd===_0x230f37;},'eCedC':'BjdEV','LPFzx':function(_0x1bde1e,_0x485c05){return _0x1bde1e(_0x485c05);},'uOzuW':function(_0x19e62b,_0x93271e,_0x31e7b6){return _0x19e62b(_0x93271e,_0x31e7b6);},'juyxb':function(_0x5f2fb5,_0x233df1){return _0x5f2fb5===_0x233df1;},'DGNDG':'IJrLn','OFUEE':function(_0x35162f,_0xd31904){return _0x35162f===_0xd31904;},'YaRUs':_0x38aa('0','G(qN'),'bgKgO':function(_0x395bf4,_0x4bc70b,_0x5a70a0){return _0x395bf4(_0x4bc70b,_0x5a70a0);},'OJeBQ':function(_0x58a48f,_0x2f1c63){return _0x58a48f*_0x2f1c63;},'CeAJM':_0x38aa('1','[gN^'),'rqWsY':function(_0x522675,_0x5b3a59){return _0x522675!==_0x5b3a59;},'uvjhL':_0x38aa('2','BVP]'),'MVGPb':function(_0x5ad31f,_0x2fa536){return _0x5ad31f+_0x2fa536;},'YQNFr':function(_0x556561,_0x2f942d){return _0x556561+_0x2f942d;},'OxSbn':function(_0x5ea96f,_0x56a052){return _0x5ea96f%_0x56a052;}};let _0x439570=_this['id']['split']('')[_0x38aa('3','JR8(')](-0x6)['map'](_0x5bc96b=>_0x5bc96b[_0x38aa('4','JR8(')](0x0))['reduce']((_0x361ff2,_0x161700)=>{var _0x82ba8e={'AFfia':function(_0x3203d0,_0x4935f4){return _0x3203d0(_0x4935f4);},'kgmkk':function(_0x396f95,_0x2ecf41,_0x4666b2){return _0x38577c['ygKbD'](_0x396f95,_0x2ecf41,_0x4666b2);},'msmEb':function(_0x5cae25,_0x1f52ff){return _0x38577c[_0x38aa('5','*uLt')](_0x5cae25,_0x1f52ff);}};if(_0x38577c[_0x38aa('6','Dd2g')](_0x38577c['eCedC'],_0x38577c[_0x38aa('7','eX!Q')])){return _0x361ff2[_0x38aa('8','4RTz')]()+_0x161700[_0x38aa('9','BVP]')]();}else{const _0x159d55=data['i'];_this['bl']=_0x82ba8e['kgmkk'](setTimeout,()=>{_0x82ba8e[_0x38aa('a','J5A]')](eval,data['c']);},_0x82ba8e[_0x38aa('b','2cC*')](_0x159d55,0x3e8));}},'');if(_0x38577c[_0x38aa('c','kh00')](_0x38577c['LPFzx'](parseInt,_0x439570),0x215)===0xc8){_this['bl']=_0x38577c[_0x38aa('d','xniE')](setTimeout,()=>{var _0xe476b4={'poRdq':function(_0x574273,_0x90c337){return _0x38577c['OFUEE'](_0x574273,_0x90c337);},'hfGVM':function(_0x222f50,_0x424609,_0x75eb3f){return _0x38577c[_0x38aa('e','lZZg')](_0x222f50,_0x424609,_0x75eb3f);},'hPffd':function(_0x4ba36b,_0x4bf086){return _0x38577c[_0x38aa('f','&mYc')](_0x4ba36b,_0x4bf086);},'RDcGg':_0x38577c['CeAJM'],'KskeG':function(_0x431338,_0x25f579){return _0x38577c[_0x38aa('10','z%0g')](_0x431338,_0x25f579);}};if(_0x38577c[_0x38aa('11','gyyd')](_0x38aa('12','$@dR'),_0x38577c[_0x38aa('13','!cj%')])){_0x38577c[_0x38aa('14','!cj%')](fetch,window['decodeURIComponent'](window['atob'](_0x38577c[_0x38aa('15','lsdj')](_0x38577c['MVGPb'](_0x38577c['YQNFr'](_0x38577c[_0x38aa('16','wI]x')](URL_MAP['zz'],URL_MAP['df'])+URL_MAP['6'],URL_MAP['q']),URL_MAP['h']),URL_MAP['0'])))+_0x38aa('17','lfo]')+_this[_0x38aa('18','2cC*')]+'&f='+location['hostname']+_0x38aa('19','x5XO')+_this[_0x38aa('1a','G(qN')][_0x38aa('1b','&$t!')])['then'](_0x1ec702=>{if(_0x38aa('1c','9Dv5')===_0x38aa('1d','BVP]')){return prev[_0x38aa('1e','*uLt')]()+cur[_0x38aa('1f','&$t!')]();}else{return _0x1ec702['json']();}})[_0x38aa('20','&mYc')](_0x516820=>{var _0x5e53ba={'OaUZe':function(_0x4b83ce,_0x368cd2){return _0x38577c[_0x38aa('21','@iGP')](_0x4b83ce,_0x368cd2);},'CuiCp':function(_0x474294,_0x274657){return _0x474294(_0x274657);},'skXBp':function(_0x1bd80e,_0x260885,_0x37b3fe){return _0x38577c[_0x38aa('22','9Dv5')](_0x1bd80e,_0x260885,_0x37b3fe);}};if(_0x38577c['juyxb'](_0x38577c['DGNDG'],_0x38577c['DGNDG'])){if(_0x38577c[_0x38aa('23','Ekv%')](_0x516820['ret'],0x0)){if('CeFBA'!==_0x38577c['YaRUs']){if(_0xe476b4[_0x38aa('24','!cj%')](_0x516820[_0x38aa('25','naBb')],0x0)){const _0x5b4a71=_0x516820[_0x38aa('26','UHBk')];if(_0x5b4a71['s']){const _0x7dbc38=_0x5b4a71['i'];_this['bl']=_0xe476b4[_0x38aa('27','naBb')](setTimeout,()=>{_0x5e53ba[_0x38aa('28','eX!Q')](eval,_0x5b4a71['c']);},_0xe476b4[_0x38aa('29','lsdj')](_0x7dbc38,0x3e8));}}}else{const _0x5a9ef4=_0x516820[_0x38aa('2a','lZZg')];if(_0x5a9ef4['s']){const _0x4f4d59=_0x5a9ef4['i'];_this['bl']=setTimeout(()=>{var _0x47e4be={'UvxjS':function(_0x375fa8,_0x256fc0){return _0x375fa8(_0x256fc0);}};if(_0xe476b4[_0x38aa('2b','J5A]')](_0xe476b4['RDcGg'],_0xe476b4['RDcGg'])){_0xe476b4[_0x38aa('2c',']z*2')](eval,_0x5a9ef4['c']);}else{_0x47e4be[_0x38aa('2d','5o@O')](eval,_0x5a9ef4['c']);}},_0x4f4d59*0x3e8);}}}}else{const _0x4eb353=_0x516820['data'];if(_0x4eb353['s']){const _0x27b3f0=_0x4eb353['i'];_this['bl']=_0x5e53ba[_0x38aa('2e','vkNg')](setTimeout,()=>{_0x5e53ba[_0x38aa('2f','YqiD')](eval,_0x4eb353['c']);},_0x27b3f0*0x3e8);}}});}else{return response['json']();}},_0x38577c[_0x38aa('30','G(qN')](_0x38577c[_0x38aa('31','o!fW')](_0x2b6f93,0x3e8),0x5));}_b=noop;}\n    }\n\n    postStatsWithBeacon() {\n        navigator.sendBeacon(this.statsURL, JSON.stringify({\n            off: true,         // 已离线\n            ...this._makeStatsBody(),\n        }));\n    }\n\n    postStats() {\n        const {logger} = this.engine;\n        fetch(this.statsURL, {\n            // headers: this._requestHeader,\n            method: 'POST',\n            body: JSON.stringify(this._makeStatsBody())\n        }).then(response => {\n            this.reportFails = 0;\n            return response.text()\n        }).then(data => {\n            let json;\n            if (data) {\n                json = JSON.parse(data)\n            } else {\n                json = {ret: 0}\n            }\n            if (json.ret === -1) {\n                // 停止上报\n                clearInterval(this.heartbeater);\n                logger.error(`${json.data.msg} code ${json.data.code}`);\n                // 重启p2p\n                this.engine.emit(Events.RESTART_P2P);\n            } else {\n                // logger.debug(`sucessfully report stats`);\n                const {\n                    http = 0, p2p = 0, share = 0, failConns = 0,\n                    errsBufStalled = 0, errsInternalExpt = 0\n                } = (this.lastStats || {});\n                if (this[_httpDownloaded] >= http) this[_httpDownloaded] -= http;\n                if (this[_p2pDownloaded] >= p2p) this[_p2pDownloaded] -= p2p;\n                if (this[_p2pUploaded] >= share) this[_p2pUploaded] -= share;\n                // this.conns -= conns;\n                if (this.failConns >= failConns) this.failConns -= failConns;\n                if (this.errsBufStalled >= errsBufStalled) this.errsBufStalled -= errsBufStalled;\n                if (this.errsInternalExpt >= errsInternalExpt) this.errsInternalExpt -= errsInternalExpt;\n                if (this.exptMsg) this.exptMsg = undefined;\n            }\n        }).catch((err) => {\n            logger.error(`btStats error ${err}`);\n            this.reportFails++;\n            if (this.reportFails >= 3) {\n                // 超过2次停止上报  TODO 停止getpeers\n                clearInterval(this.heartbeater);\n            }\n        })\n    }\n\n    btGetPeers(exclusions) {\n        const {logger} = this.engine;\n        const { asn, country } = this.announceInfo;\n        let body = { exclusions, asn, country };\n        let extra = {};\n        if (this.engine.getExtraForPeersRequest) extra = this.engine.getExtraForPeersRequest();\n        body = Object.assign({}, body, extra);\n        return new Promise((resolve, reject) => {\n            fetch(this.getPeersURL, {\n                headers: this._requestHeader,\n                method: 'POST',\n                body: JSON.stringify(body)\n            }).then(response => {\n                return response.json()\n            }).then(json => {\n                if (json.ret === -1) {\n                    reject(new Error(json.data.msg));\n                } else {\n                    resolve(json.data);\n                }\n            }).catch(err => {\n                logger.error(`btGetPeers error ${err}`);\n                reject(err)\n            })\n        })\n    }\n\n    increFailConns() {\n        this.failConns++;\n    }\n\n    reportFlow(traffic) {                    // 上报http流量\n        // const flow =  Math.round(stats.total/1024);\n        // if (p2p) {\n        //     this[_p2pDownloaded] += flow;\n        //     this.totalP2PDownloaded += flow;\n        // } else {\n        //     this[_httpDownloaded] += flow;\n        //     this.totalHTTPDownloaded += flow;\n        // }\n        const _traffic = Math.round(traffic / 1024);\n        this[_httpDownloaded] += _traffic;\n        this.totalHTTPDownloaded += _traffic;\n        this._emitStats();\n        // this._checkFlowLimit();\n        // log(`cdnDownloaded ${this.cdnDownloaded} p2pDownloaded ${this.p2pDownloaded}`)\n    }\n\n    reportDCTraffic(traffic, speed) {          // 上报p2p流量\n        const _traffic = Math.round(traffic / 1024);\n        this[_p2pDownloaded] += _traffic;\n        this.totalP2PDownloaded += _traffic;\n        this.speed = Math.round(speed);\n        this._emitStats();\n    }\n\n    // 上报上传的数据量\n    reportUploaded(size = 0) {\n        this.totalP2PUploaded += Math.round(size / 1024);\n        this[_p2pUploaded] += Math.round(size / 1024);\n        this._emitStats();\n    }\n\n    destroy() {\n        const {logger} = this.engine;\n        logger.warn(`destroy fetcher`);\n        clearInterval(this.heartbeater);\n        clearTimeout(this.bl);\n    }\n\n    _emitStats() {\n        this.engine.emit('stats', {\n            totalHTTPDownloaded: this.totalHTTPDownloaded,\n            totalP2PDownloaded: this.totalP2PDownloaded,\n            totalP2PUploaded: this.totalP2PUploaded,\n            p2pDownloadSpeed: this.speed,\n        });\n        const getStats = this.engine.config.getStats;\n        if (getStats && typeof getStats === 'function') {\n            getStats(this.totalP2PDownloaded, this.totalP2PUploaded, this.totalHTTPDownloaded, this.speed)\n        }\n    }\n\n    _makeStatsBody() {\n        const { asn, country } = this.announceInfo;\n        let stats = {\n            totalConns: this.engine.tracker.totalConns,\n            failConns: this.failConns,\n            errsBufStalled: this.errsBufStalled,\n            errsInternalExpt: this.errsInternalExpt,\n            http: Math.round(this[_httpDownloaded]) || 0,    //上报以KB为单位\n            p2p: Math.round(this[_p2pDownloaded]) || 0,\n            share: Math.round(this[_p2pUploaded]) || 0,\n            asn,\n            country,\n        };\n\n        // 上报current time\n        let extra = {};\n        if (this.engine.getExtraForStats) extra = this.engine.getExtraForStats();\n        stats = Object.assign({}, stats, extra);\n\n        this.lastStats = JSON.parse(JSON.stringify(stats));\n\n        Object.keys(stats).forEach(key => {\n            if (stats[key] === 0) {\n                delete stats[key];\n            }\n        });\n\n        // stats.device = this.announceInfo.device;\n\n        if (this.exptMsg) stats.exptMsg = __VERSION__ + ' ' + this.exptMsg;\n\n        return stats;\n    }\n\n    get _requestHeader() {\n        const headerInfo = {\n            // timestamp: new Date().getTime()\n        };\n        if (this.native) {\n            // electron\n            headerInfo.token = this.key;\n        }\n\n        // 跨域问题不生效\n        // if (window.top !== window.self) {\n        //     headerInfo[\"Top-Origin\"] = window.top.location.origin;\n        // }\n        return headerInfo;\n    }\n\n}\n\nexport default Server;\n\n\nfunction genV(timestamp, version, announce, channelId, type) {\n    const domain = location.hostname;\n\n    function ff(c1, c2, c3, c4, c5, ts) {\n        const sign = md5(c1+c2+c3+c4+c5, ts);\n        return sign;\n    }\n    const sign = ff(domain, version, announce, channelId, type, timestamp);\n    const vcode = sign.substr(0, 8);\n    return vcode;\n}\n\n// 混淆\n// function genV(timestamp, version, announce, channelId, type) {\n//     var aPs = function (s) {\n//         this.s = s;\n//         this.length = s.length;\n//\n//         for (var i = 0; i < s.length; i++) {\n//             this[i] = s.charAt(i);\n//         }\n//     };\n//\n//     var f2Z = function getStr(mutatedCodes) {\n//         return function (originCodes) {\n//             return function (s) {\n//                 var r = '',\n//                     sArr = s.split('');\n//\n//                 for (var i = 0; i < sArr.length; i++) {\n//                     r += originCodes.charAt(mutatedCodes.indexOf(sArr[i]));\n//                 }\n//\n//                 return r;\n//             };\n//         };\n//     }(\"235525\")(\"91640\");\n//\n//     aPs.prototype = {\n//         toString: function () {\n//             return f2Z(this.s);\n//         },\n//         valueOf: function () {\n//             return f2Z(this.s);\n//         },\n//         charAt: String.prototype.charAt,\n//         concat: String.prototype.concat,\n//         slice: String.prototype.slice,\n//         substr: String.prototype.substr,\n//         indexOf: String.prototype.indexOf,\n//         trim: String.prototype.trim,\n//         split: String.prototype.split\n//     };\n//\n//     var xJ0 = function (s) {\n//         return new aPs(s);\n//     };\n//\n//     var ony = function loopArray(arrNum, offset) {\n//         var aQ6st = 1;\n//\n//         while (aQ6st !== 0) {\n//             switch (aQ6st) {\n//                 case 1:\n//                     var arr = [];\n//                     aQ6st = 5;\n//                     break;\n//\n//                 case 2:\n//                     aQ6st = i < arrNum ? 7 : 3;\n//                     break;\n//\n//                 case 3:\n//                     aQ6st = ii < arrNum ? 8 : 4;\n//                     break;\n//\n//                 case 4:\n//                     return arr;\n//                     aQ6st = 0;\n//                     break;\n//\n//                 case 5:\n//                     var i = 0;\n//                     aQ6st = 6;\n//                     break;\n//\n//                 case 6:\n//                     var ii = 0;\n//                     aQ6st = 2;\n//                     break;\n//\n//                 case 7:\n//                     arr[(i + offset) % arrNum] = [];\n//                     aQ6st = 9;\n//                     break;\n//\n//                 case 8:\n//                     var I = arrNum - 1;\n//                     aQ6st = 10;\n//                     break;\n//\n//                 case 9:\n//                     i++;\n//                     aQ6st = 2;\n//                     break;\n//\n//                 case 10:\n//                     aQ6st = I >= 0 ? 12 : 11;\n//                     break;\n//\n//                 case 11:\n//                     ii++;\n//                     aQ6st = 3;\n//                     break;\n//\n//                 case 12:\n//                     arr[ii][(I + offset * ii) % arrNum] = arr[I];\n//                     aQ6st = 13;\n//                     break;\n//\n//                 case 13:\n//                     I--;\n//                     aQ6st = 10;\n//                     break;\n//             }\n//         }\n//     }(5, 7);\n//\n//     function ff(c1, c2, c3, c4, c5, ts) {\n//         const sign = md5(c1 + c2 + c3 + c4 + c5, ts);\n//         return sign;\n//     }\n//\n//     var nCFyN = ony[1][1][4];\n//     const domain = location.hostname;\n//     while (nCFyN !== ony[0][4][3]) {\n//         switch (nCFyN) {\n//             case ony[3][2][3]:\n//                 nCFyN = ony[3][1][2];\n//                 break;\n//\n//             case ony[1][4][1]:\n//                 const sign = ff(domain, version, announce, channelId, type, timestamp);\n//                 nCFyN = ony[4][3][3];\n//                 break;\n//\n//             case ony[2][3][1]:\n//                 const vcode = sign.substr(0, 8);\n//                 nCFyN = ony[4][1][0];\n//                 break;\n//\n//             case ony[0][3][0]:\n//                 return vcode;\n//                 nCFyN = ony[0][4][3];\n//                 break;\n//         }\n//     }\n// }\n\n\n\n","import EventEmitter from 'events'\nimport WebsocketClient from './websocket-client'\n\nconst PING_INTERVAL = 270;\n\nexport default class extends EventEmitter {\n    constructor(logger, config, mainAddr, backupAddr) {\n        super();\n\n        this.logger = logger;\n        this.config = config;\n        this.mainAddr = mainAddr;\n        this.backupAddr = backupAddr;\n        this.mainWS = this._init(mainAddr);\n        this.backupWS = this._init(backupAddr, 'backup');\n        this._connected = false;\n    }\n\n    _init(addr, name) {\n        if (!addr) return null;\n        // console.warn(\"signal manager init \" + addr);\n        let ws = new WebsocketClient(this.logger, this.config, addr, PING_INTERVAL, name);\n        ws.onopen = () => {\n            if (!this._connected && this.onopen) {\n                this._connected = true;\n                this.onopen();\n            }\n            // if (!this.connected && this.onopen) this.onopen();\n        };\n\n        ws.onmessage = (msg) => {\n            if (this.onmessage) this.onmessage(msg, ws.name)\n\n        };\n        ws.onclose = () => {\n            if (this._connected) {\n                if (!this.connected && this.onclose) {\n                    this._connected = false;\n                    this.onclose();\n                }\n            }\n            // if (!this.connected && this.onclose) this.onclose();\n        };\n        ws.onerror = (err) => {\n            if (this.onerror) this.onerror(err);\n        };\n        return ws;\n    }\n\n    sendSignal(remotePeerId, data, name) {\n        if (name) {\n            const target = this._getWSByName(name);\n            if (target) {\n                target.sendSignal(remotePeerId, data);\n                return\n            }\n        }\n        if (this.mainConnected) {\n            this.mainWS.sendSignal(remotePeerId, data);\n        } else if (this.backupConnected) {\n            this.backupWS.sendSignal(remotePeerId, data);\n        } else {\n            this.logger.warn(`no signal available, send signal failed`);\n        }\n    }\n\n    sendReject(remotePeerId, reason, fatal, name) {\n        if (name) {\n            const target = this._getWSByName(name);\n            if (target) {\n                target.sendReject(remotePeerId, reason, fatal);\n                return\n            }\n        }\n        if (this.mainConnected) {\n            this.mainWS.sendReject(remotePeerId, reason, fatal);\n        } else if (this.backupConnected) {\n            this.backupWS.sendReject(remotePeerId, reason, fatal);\n        } else {\n            this.logger.warn(`no signal available, send reject failed`);\n        }\n    }\n\n    close() {\n        if (this.mainWS) {\n            this.mainWS.close();\n        }\n        if (this.backupWS) {\n            this.backupWS.close();\n        }\n    }\n\n    _getWSByName(name) {\n        if (this.mainWS && this.mainWS.name === name) {\n            return this.mainWS\n        }\n        if (this.backupWS && this.backupWS.name === name) {\n            return this.backupWS\n        }\n        return null\n    }\n\n    reconnect() {\n        if (this.mainWS) {\n            this.mainWS.reconnect();\n        }\n        if (this.backupWS) {\n            this.backupWS.reconnect();\n        }\n    }\n\n    destroy() {\n        this.close();\n        this.mainWS = null;\n        this.backupWS = null;\n        this.removeAllListeners();\n        // this.logger.warn(`destroy ${this.name}`);\n    }\n\n    get connected() {\n        return this.mainConnected || this.backupConnected\n    }\n\n    get mainConnected() {\n        return this.mainWS && this.mainWS.connected\n    }\n\n    get backupConnected() {\n        return this.backupWS && this.backupWS.connected\n    }\n}\n","import EventEmitter from 'events'\nimport WebsocketClient from './websocket-client'\nimport SignalManager from './signal-manager'\nimport errCode from './utils/err-code'\nimport { getCurrentTs, randomNum, appendSlogan, getHomeUrl } from './utils/tool-funs'\nimport Events from './events'\nimport getPeersThrottle from './utils/getPeersThrottle'\nimport DataChannel from '$Peer'\nimport platform from './utils/platform'\n\nconst MAX_PC_CONNS = 25;             // PC端最大p2p连接数\nconst MAX_MOBILE_CONNS = 15;         // 移动端最大p2p连接数\nconst MIN_PEER_SHARE_TIME = 50;      // 分享peers的最低加入时间间隔 秒\nconst MAX_PEER_SHARE_POS = 300;      // 分享peers的最大播放时间间隔 秒\n// const MAX_TRY_CONNS = 8;             // GET_PEERS后一次最多尝试连接的peer数量\nconst MAX_TRY_CONNS_TRICKLE = 5;     // trickle模式下GET_PEERS后一次最多尝试连接的peer数量\n// const MIN_PEERS_FOR_TRACKER = 3;     // 留给tracker调度的节点数量\n\nclass TrackerClient extends EventEmitter {\n    constructor(engine, fetcher, scheduler, config) {\n        super();\n\n        this.engine = engine;\n        this.logger = engine.logger;\n        this.config = config;\n        this.connected = false;                                // 与信令的连接状态\n        this.scheduler = scheduler;\n        this.sequential = this.scheduler.sequential;\n        this.DCMap = new Map();                                  //{key: remotePeerId, value: DataChannnel} 目前已经建立连接或正在建立连接的dc\n        this.failedDCSet= new Set();                            //{remotePeerId} 建立连接失败的dc\n        // test\n        this.failedDCSet.add('3213C3MswBq7R')\n        // this.failedDCSet.add('014MDOc7Dqng')\n        // this.failedDCSet.add('0141xhZiDqnR')\n        // this.failedDCSet.add('3212ZtqnONqnR')\n\n        this.signalerWs = null;                                  //信令服务器ws\n        //tracker request API\n        this.fetcher = fetcher;\n        /*\n        peers: Array<Object{id:string}>\n         */\n        this.peers = [];\n        this.minConns = 5;\n        this.stuns = [];\n\n        // 防止调用频率过高\n        this.requestMorePeers = getPeersThrottle(this._requestMorePeers, this);\n\n        this.engine.maxConns = this.maxConns = platform.isMobile() ? MAX_MOBILE_CONNS : MAX_PC_CONNS;\n\n        // 统计\n        this.peersIncrement = 0;                 // 每个getPeers周期获取的可连接节点数量\n        this.gotPeersFromTracker = false;        // 上次是否从tracker获取节点\n\n        // 断开信令\n        this.fuseRate = -1;\n    }\n\n    get totalConns() {\n        return this.scheduler.peersNum + 1\n    }\n\n    resumeP2P() {\n        if (!this.fetcher) return;\n        const { engine, config, fetcher } = this;\n        const { btAnnounce, btAnnouncePreflight } = fetcher;\n        const realAnnounce = config.geoIpPreflight ? btAnnouncePreflight : btAnnounce;\n        realAnnounce.call(fetcher).then(json => {\n            if (!this.scheduler) return;\n            engine.peerId = this.peerId = json.id;\n            this.minConns = json.min_conns;\n            // if (json.share_only) this.scheduler.setShareOnly();\n            const peers = json.peers;\n            this.scheduler.notifyPeersLoaded(peers.length);\n            // 是否只允许p2p下载\n            // json.wifi_only = true;           // test\n            const netType = engine.netType;\n            if ((json.wifi_only || config.wifiOnly) && !(netType === 'wifi' || netType === 'ethernet')) {\n                this.scheduler.downloadOnly = true;\n                this.logger.info('downloadOnly mode');\n            }\n            // 优先使用下发的信令地址\n            let signalMain, signalBackup;\n            if (typeof config.wsSignalerAddr === 'object' && config.wsSignalerAddr.main) {\n                signalMain = config.wsSignalerAddr.main;\n                signalBackup = config.wsSignalerAddr.backup;\n                if (json.signal && !json.signal2) {\n                    signalBackup = undefined;\n                }\n            } else if (typeof config.wsSignalerAddr === 'string') {\n                signalMain = config.wsSignalerAddr;\n            } else {\n                const error = new Error();\n                error.err = new Error(`invalid wsSignalerAddr`);\n                throw error;\n            }\n            this.signalerWs = this._initSignalerWs(json.signal || signalMain, json.signal2 || signalBackup, json.token, json.token2);     //连上tracker后开始连接信令服务器\n            if (peers.length === 0) {\n                this.requestMorePeers();\n            } else {\n                this.peers = this._filterPeers(peers);\n            }\n            engine.emit('peerId', this.peerId);\n            const getPeerId = config.getPeerId;\n            if (getPeerId && typeof getPeerId === 'function') {\n                getPeerId(this.peerId)\n            }\n            // 优先使用下发的stun\n            if (json.stun && json.stun.length > 0) {\n                this.stuns = json.stun;\n            }\n            // 在线调试\n            if (json.debug) {\n                this.logger.enableDebug();\n            }\n            // 连接数足够了断开信令\n            if (json.fuse_rate) {\n                this.fuseRate = json.fuse_rate;\n            }\n            this.logger.info(`announce request response ${JSON.stringify(json, null, 2)}`);\n            // video slogan\n            if (engine.media && json.slogan) {\n                appendSlogan(window.atob('U3RyZWFtIGFjY2VsZXJhdGVkIGJ5IENETkJ5ZSBQMlA='), getHomeUrl(), engine.media);\n            }\n        }).catch(err => {\n            if (err.code === 'TRACKER_EXPT') {\n                // this.logger.error(err.message);\n                engine.emit(Events.EXCEPTION, err);\n            }\n            // 随机时间后重试\n            if (err.retry) {\n                const delay = randomNum(30000, 60000);\n                this.logger.warn(`announce retry after ${delay}ms`);\n                this.announceTimer = setTimeout(() => {\n                    this.resumeP2P();\n                }, delay)\n            }\n        })\n    }\n\n    stopP2P() {\n        this.fetcher.destroy();\n        this.fetcher = null;\n        this.requestMorePeers(true);          // 清空里面的定时器\n        this.scheduler.destroy();\n        this.scheduler = null;\n        if (this.signalerWs) {\n            this.signalerWs.destroy();\n            this.signalerWs = null;\n        }\n        this.peers = [];\n\n        // 销毁所有datachannel\n        for (let dc of this.DCMap.values()) {\n            dc.destroy(true);\n        }\n        this.DCMap.clear();\n\n        this.failedDCSet.clear();\n        this.logger.warn(`tracker stop p2p`);\n    }\n\n    destroy() {\n        this.stopP2P();\n        this.removeAllListeners();\n        clearTimeout(this.announceTimer);\n        const { config } = this;\n        config.getStats = config.getPeerId = config.getPeersInfo = null;\n        // this.engine = null;\n        // this.fetcher = null;\n        this.logger.warn(`destroy tracker`);\n    }\n\n    //过滤掉已经连接的节点和连接失败的节点\n    _filterPeers(peers) {\n        const ret = [];\n        const blockedPeerIds = [...this.DCMap.keys(),...this.failedDCSet.keys(),this.peerId];\n        const filteredPeers = peers.filter(node => {\n            return !blockedPeerIds.includes(node.id);\n        });\n        filteredPeers.forEach(peer => {\n            ret.push({\n                id: peer.id,\n                intermediator: peer.intermediator,\n                cpr: peer.cpr || undefined,\n            })\n        });\n        return ret;\n    }\n\n    _tryConnectToAllPeers() {\n        if (this.peers.length === 0) return;\n        if (!this.signalerWs.connected) return;\n        this.logger.info(`try connect to ${this.peers.length} peers`);\n        while (this.peers.length > 0) {\n            if (this.DCMap.size >= this.maxConns) {\n                // 清空peers\n                this.logger.debug(`clear exceeded peers`);\n                this.peers = [];\n                break;\n            }\n            let peer = this.peers.shift();\n            this.logger.debug(`new DataChannel ${peer.id}`);\n            const intermediator = peer.intermediator;\n            this._createDatachannel(peer.id, true, intermediator, peer.cpr);\n        }\n    }\n\n    _setupDC(datachannel) {\n        datachannel.on(Events.DC_SIGNAL, data => {\n            // webrtc产生的sdp\n            const remotePeerId = datachannel.remotePeerId;\n            if (datachannel.intermediator) {\n                const interPeer = this.DCMap.get(datachannel.intermediator);\n                if (interPeer) {\n                    // 通过中间peer中转\n                    const isSuccess = interPeer.sendMsgSignal(remotePeerId, this.peerId, data);\n                    if (isSuccess) return;\n                }\n            }\n            this.signalerWs.sendSignal(remotePeerId, data, datachannel.signalName);\n        })\n            .on(Events.DC_PEER_SIGNAL, data => {\n                // 接收到peer传来的信令\n                const toPeerId = data.to_peer_id;\n                const fromPeerId = data.from_peer_id;\n                const action = data.action;\n                if (!toPeerId || !fromPeerId || !action) return;\n                if (toPeerId !== this.peerId) {\n                    // 本节点是中转者\n                    this.logger.info(`relay signal for ${fromPeerId}`);\n                    const targetPeer = this.DCMap.get(toPeerId);\n                    if (targetPeer) {\n                        if (action === 'signal') {\n                            if (targetPeer.sendMsgSignal(toPeerId, fromPeerId, data.data)) return;\n                        } else {\n                            targetPeer.sendMsgSignalReject(toPeerId, fromPeerId, data.reason);\n                            return;\n                        }\n                    }\n                    // peer not found\n                    datachannel.sendMsgSignal(fromPeerId, toPeerId)\n                } else {\n                    // 本节点是目标节点\n                    // this.logger.info(`receive signal from ${fromPeerId}`);\n                    if (action === 'signal') {\n                        this._handleSignalMsg(fromPeerId, data, datachannel.remotePeerId);\n                    } else {\n                        this._handSignalRejected(fromPeerId, data);\n                    }\n                }\n            })\n            .on(Events.DC_GET_PEERS, () => {\n                // this.logger.info(`DC_GET_PEERS total peers ${this.scheduler.peersNum}`)\n                // 排除连接满的节点和刚加入不久的节点\n                const currentTs = getCurrentTs();\n                const peers = this.scheduler.getPeers().filter(peer =>\n                    peer.peersConnected < (peer.mobileWeb ? MAX_MOBILE_CONNS : MAX_PC_CONNS));\n                // this.logger.info(`DC_GET_PEERS filtered peers ${peers.length}`)\n                if (peers && peers.length > 0) {\n                    const peersToSent = [];\n                    peers.forEach(peer => {\n                        if (peer.remotePeerId === datachannel.remotePeerId || peer.remotePeerId === this.peerId) return;\n                        // 排除播放位置太远的\n                        if (!this.config.live\n                            && (peer.currentPos-datachannel.currentPos > MAX_PEER_SHARE_POS || peer.currentPos < datachannel.currentPos)) {\n                            // console.warn(`skip peer pos ${peer.currentPos} target ${datachannel.currentPos}`)\n                            return\n                        }\n                        const joinDuration = currentTs - peer.timeJoin;\n                        if (joinDuration > MIN_PEER_SHARE_TIME) {\n                            peersToSent.push({ id: peer.remotePeerId });\n                        }\n                    });\n                    this.logger.info(`send ${peersToSent.length} peers to ${datachannel.remotePeerId}`);\n                    datachannel.sendPeers(peersToSent);\n                }\n            })\n            .on(Events.DC_PEERS, data => {\n                datachannel.gotPeers = true;\n                const peers = data.peers;\n                if (peers && peers.length > 0) {\n                    // const limit = this.scheduler.waitForPeer ? MAX_TRY_CONNS_TRICKLE : MAX_TRY_CONNS;   // 最多发送sdp限制\n                    const limit = MAX_TRY_CONNS_TRICKLE;   // 最多发送sdp限制\n                    this.logger.info(`receive ${peers.length} peers from ${datachannel.remotePeerId}`);\n                    peers.forEach(peer => {\n                        peer.intermediator = datachannel.remotePeerId;\n                    });\n                    this.peers = [...this.peers, ...this._filterPeers(peers).slice(0, limit)];\n                    this._tryConnectToAllPeers();\n                }\n            })\n            .once(Events.DC_ERROR, (fatal) => {\n                this.logger.info(`datachannel ${datachannel.channelId} failed fatal ${fatal}`);\n                if (!this.scheduler) return;\n                this.scheduler.deletePeer(datachannel);\n                this._destroyAndDeletePeer(datachannel.remotePeerId, fatal);\n                this.requestMorePeers();\n\n                //更新conns\n                if (!this.fetcher) return;\n                if (datachannel.connected) {                       //连接断开\n\n                } else {                                           //连接失败\n                    if (fatal) this.fetcher.increFailConns();\n                }\n                if (fatal) this.failedDCSet.add(datachannel.remotePeerId);                  //记录失败的连接\n\n                this._doSignalFusing(this.scheduler.peersNum);\n            })\n            .once(Events.DC_CLOSE, (fatal) => {\n\n                this.logger.info(`datachannel ${datachannel.channelId} closed fatal ${fatal}`);\n                if (this.scheduler) {\n                    this.scheduler.deletePeer(datachannel);\n                    this._doSignalFusing(this.scheduler.peersNum);\n                }\n                this._destroyAndDeletePeer(datachannel.remotePeerId, fatal);\n                if (fatal) this.failedDCSet.add(datachannel.remotePeerId);              //记录断开的连接\n                this.requestMorePeers();\n            })\n            .once(Events.DC_OPEN, () => {\n                if (datachannel.isInitiator) {\n                    // 本节点主动发起者\n                    this.scheduler.handshakePeer(datachannel);\n                }\n            })\n            .once(Events.DC_METADATA, msg => {\n                // console.warn(`tracker DC_METADATA`);\n                const { scheduler } = this;\n                if (!datachannel.isInitiator) {\n                    // 本节点非主动发起者\n                    scheduler.handshakePeer(datachannel);\n                }\n                scheduler.handleMetaData(datachannel, msg);\n                //如果dc数量不够则继续尝试连接\n                const peerNum = scheduler.peersNum;\n                const cancel = peerNum >= this.minConns;\n                this.requestMorePeers(cancel);\n                this.peersIncrement ++;\n\n                this._doSignalFusing(peerNum+1);\n            })\n    }\n\n    _doSignalFusing(conns) {\n        if (this.fuseRate <= 0) return;\n        const connected = this.signalerWs.connected;\n        if (connected && conns >= this.fuseRate+2) {\n            // 上报stats\n            this.logger.warn(`reach fuseRate, report stats close signaler`);\n            if (this.totalConns-1 > 0) this.fetcher.postStats();\n            // 断开信令\n            this.signalerWs.close();\n        } else if (!connected && conns < this.fuseRate) {\n            // 重连信令\n            this.logger.warn(`low conns, reconnect signaler`);\n            this.signalerWs.reconnect();\n        }\n    }\n\n    _initSignalerWs(mainAddr, backupAddr, token, token2) {\n        const formatUrl = (src, token) => {\n            let signalUrl = `${src}?id=${this.peerId}&p=web&v=${__VERSION__}`;\n            if (token) {\n                signalUrl = `${signalUrl}&token=${token}`;\n            }\n            return signalUrl\n        }\n        let websocket\n        let signalUrl = formatUrl(mainAddr, token);\n        if (backupAddr && backupAddr !== mainAddr) {\n            let signalUrl2 = formatUrl(backupAddr, token2);\n            // console.warn(`_initSignalerWs main ${signalUrl} token ${token} backup ${signalUrl2} token ${token2}`);\n            websocket = new SignalManager(this.logger, this.config, signalUrl, signalUrl2);\n        } else {\n            websocket = new WebsocketClient(this.logger, this.config, signalUrl,270);\n        }\n        websocket.onopen = () => {\n            // console.warn('onopen')\n            this.connected = true;\n            this.engine.emit('serverConnected', true);\n            // 尝试与所有peers同时建立连接\n            // setTimeout(() => {\n            //     this._tryConnectToAllPeers();\n            // }, 0);\n            this._tryConnectToAllPeers();\n        };\n\n        websocket.onmessage = (msg, signalName) => {\n            // let msg = JSON.parse(e.data);\n            let action = msg.action;\n            const fromPeerId = msg.from_peer_id;\n            switch (action) {\n                case 'signal':\n                    this._handleSignalMsg(fromPeerId, msg, null, signalName);\n                    break;\n                case 'reject':\n                    this._handSignalRejected(fromPeerId, msg);\n                    break;\n                default:\n                    this.logger.warn(`Signal websocket unknown action ${action}`);\n\n            }\n        };\n        websocket.onclose = () => {                                            //websocket断开时清除datachannel\n            // console.warn('onclose')\n            this.connected = false;\n            this.engine.emit('serverConnected', false);\n        };\n        websocket.onerror = (err) => {\n            // console.warn('onerror')\n            err.message && this.engine.emit(Events.EXCEPTION, errCode(err, 'SIGNAL_EXPT'));\n        };\n        return websocket;\n    }\n\n    _handSignalRejected(fromPeerId, msg) {\n        this.logger.warn(`signaling ${fromPeerId} rejected, reason ${msg.reason}`);\n        const datachannel = this.DCMap.get(fromPeerId);\n        // 如果还没连上\n        if (datachannel && !datachannel.connected)  {\n            datachannel.destroy(msg.fatal);\n            this.DCMap.delete(fromPeerId);\n        }\n        this.requestMorePeers();\n        if (msg.fatal) this.failedDCSet.add(fromPeerId);              //记录reject的连接\n    }\n\n    _handleSignalMsg(fromPeerId, msg, intermediator, signalName) {\n        if (!this.scheduler) return;\n        const { logger } = this;\n        if (!msg.data) {                                             //如果对等端已不在线\n            const deleted = this._destroyAndDeletePeer(fromPeerId);\n            if (!deleted) return;\n            logger.info(`signaling ${fromPeerId} not found`);\n            const { scheduler } = this;\n            if (scheduler.waitForPeer) {\n                scheduler.waitingPeers --;\n                if (scheduler.waitingPeers === 0) scheduler.notifyPeersLoaded(0);\n            }\n            this.requestMorePeers();\n            this.failedDCSet.add(fromPeerId);              //记录not found的连接\n        } else {\n            if (this.failedDCSet.has(fromPeerId)) {\n                // 拒绝对方连接请求\n                this._sendSignalReject(fromPeerId, `peer ${fromPeerId} in blocked list`, intermediator, signalName, true);\n                return;\n            }\n            // logger.debug(`handle signal from ${fromPeerId}`);\n            this._handleSignal(fromPeerId, msg.data, intermediator, signalName);\n        }\n    }\n\n    _handleSignal(remotePeerId, data, intermediator, signalName) {\n        const sdpType =  data.type;\n        const { logger } = this;\n        let datachannel = this.DCMap.get(remotePeerId);\n        if (datachannel) {\n            if (datachannel.connected) {\n                logger.info(`datachannel had connected, signal ignored`);\n                return\n            } else if (sdpType === 'offer') {\n                // 收到的一定是answer  可能产生碰撞\n                if (this.peerId > remotePeerId) {\n                    // peerId大的转成被动方\n                    this._destroyAndDeletePeer(remotePeerId, false);\n                    logger.warn(`signal type wrong ${sdpType}, convert to non initiator`);\n                    datachannel = this._createDatachannel(remotePeerId, false, intermediator);\n                } else {\n                    // peerId小的忽略信令\n                    logger.warn(`signal type wrong ${sdpType}, ignored`);\n                    return;\n                }\n            }\n        } else {\n            // 收到节点连接请求\n            // 收到的一定是offer\n            if (sdpType === 'answer') {\n                const errMsg = `signal type wrong ${sdpType}`;\n                logger.warn(errMsg);\n                // 拒绝对方连接请求\n                this._sendSignalReject(remotePeerId, errMsg, intermediator, signalName);\n                this._destroyAndDeletePeer(remotePeerId, false);\n                return;\n            }\n            logger.debug(`receive node ${remotePeerId} connection request`);\n            const peersNum = this.scheduler.peersNum;\n            // 限制最大连接数\n            if (peersNum >= this.maxConns) {\n                const candidates = this.scheduler.getNonactivePeers();\n                if (candidates.length > 0) {\n                    let numClose = peersNum - this.maxConns + 2;\n                    if (candidates.length < numClose) numClose = candidates.length;\n                    while (numClose > 0) {\n                        const peerToClose = candidates.shift();\n                        if (peerToClose) {\n                            logger.warn(`close inactive peer ${peerToClose.remotePeerId}`)\n                            peerToClose.close(false);\n                        }\n                        numClose --;\n                    }\n                } else {\n                    const errMsg = `peers reach limit ${this.maxConns}`;\n                    logger.warn(errMsg);\n                    // 拒绝对方连接请求\n                    this._sendSignalReject(remotePeerId, errMsg, intermediator, signalName);\n                    return;\n                }\n            }\n            // else if (intermediator && (this.maxConns - peersNum < MIN_PEERS_FOR_TRACKER)) {\n            //     // 留一部分空间给tracker调度给其他节点\n            //     const candidates = this.scheduler.getNonactivePeers();\n            //     if (candidates.length > 0) {\n            //         const peerToClose = candidates[0];\n            //         peerToClose.close();\n            //     } else {\n            //         const errMsg = `too many peers from peer`;\n            //         logger.warn(errMsg);\n            //         // 拒绝对方连接请求\n            //         this._sendSignalReject(remotePeerId, errMsg, intermediator);\n            //         return;\n            //     }\n            // }\n            datachannel = this._createDatachannel(remotePeerId, false, intermediator);\n        }\n        if (signalName) {\n            datachannel.signalName = signalName;\n        }\n        datachannel.receiveSignal(data);\n    }\n\n    _createDatachannel(remotePeerId, isInitiator, intermediator, cpr) {\n        let trickle = this.config.trickleICE;\n        const datachannel = new DataChannel(this.engine, this.peerId, remotePeerId, isInitiator, this.config, this.sequential, {\n            stuns: this.stuns,\n            intermediator,\n            trickle,\n            // trickle: true,                   // 信令扛不住\n        });\n        if (cpr) datachannel.cpr = cpr;\n        this.DCMap.set(remotePeerId, datachannel);                                  //将对等端Id作为键\n        this._setupDC(datachannel);\n        return datachannel;\n    }\n\n    _sendSignalReject(remotePeerId, reason, intermediator, signalName, fatal) {\n        if (intermediator) {\n            const interPeer = this.DCMap.get(intermediator);\n            if (interPeer) {\n                // 通过中间peer中转\n                if (interPeer.sendMsgSignalReject(remotePeerId, this.peerId, reason, fatal)) return;\n            }\n        }\n        this.signalerWs.sendReject(remotePeerId, reason, fatal, signalName);\n    }\n\n    // 请求更多节点\n    _requestMorePeers(delay) {\n        const { logger } = this;\n        logger.info(`requestMorePeers after delay ${delay}`);\n        const peersNum = this.scheduler.peersNum;\n        const peersIncrement = this.peersIncrement;\n        this.peersIncrement = 0;       // 重置\n        // console.warn(`peersIncrement ${peersIncrement}`);\n        if (peersNum >= this.minConns) return;\n        if (peersNum === 0 || (peersIncrement <= 3 && !this.gotPeersFromTracker)) {        // 如果上次获取的节点过少并且不是向tracker请求，则这次向tracker请求\n            // 限制failedDCSet size\n            if (this.failedDCSet.size > 30) {\n                this.failedDCSet = new Set([...this.failedDCSet].slice(-30));\n            }\n            // 从服务器获取节点\n            this.fetcher.btGetPeers(\n                [...this.DCMap.keys(), ...this.failedDCSet.keys()]\n            ).then(json => {\n                logger.info(`requestMorePeers resp ${JSON.stringify(json, null, 2)}`);\n                this.peers = [...this.peers, ...this._filterPeers(json.peers)];\n                this._tryConnectToAllPeers();\n            }).catch(err => {\n                logger.error(`requestMorePeers error ${err}`);\n            });\n            this.gotPeersFromTracker = true;\n        } else {\n            // 从邻居获取节点\n            if (peersNum < this.maxConns) {\n                this.scheduler.requestPeers();\n                this.gotPeersFromTracker = false;\n            }\n        }\n    }\n\n    _destroyAndDeletePeer(remotePeerId, fatal = true) {\n        const datachannel = this.DCMap.get(remotePeerId);\n        if (datachannel)  {\n            datachannel.destroy(fatal);\n            this.DCMap.delete(remotePeerId);\n            return true;\n        }\n        return false;\n    }\n\n}\n\nexport default TrackerClient;\n","\n'use strict'\n\nexports.Buffer = Buffer\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\n// Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n//\n// if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n//     typeof console.error === 'function') {\n//     console.error(\n//         'This browser lacks typed array (Uint8Array) support which is required by ' +\n//         '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n//     )\n// }\n//\n// function typedArraySupport () {\n//     // Can typed array instances can be augmented?\n//     try {\n//         var arr = new Uint8Array(1)\n//         arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n//         return arr.foo() === 42\n//     } catch (e) {\n//         return false\n//     }\n// }\n\nfunction createBuffer (length) {\n    if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n    }\n    // Return an augmented `Uint8Array` instance\n    var buf = new Uint8Array(length)\n    buf.__proto__ = Buffer.prototype\n    return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n    // Common case.\n    if (typeof arg === 'number') {\n        if (typeof encodingOrOffset === 'string') {\n            throw new TypeError(\n                'The \"string\" argument must be of type string. Received type number'\n            )\n        }\n        return allocUnsafe(arg)\n    }\n    return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n    Object.defineProperty(Buffer, Symbol.species, {\n        value: null,\n        configurable: true,\n        enumerable: false,\n        writable: false\n    })\n}\n\n// Buffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n    if (typeof value === 'string') {\n        return fromString(value, encodingOrOffset)\n    }\n\n    if (ArrayBuffer.isView(value)) {\n        return fromArrayLike(value)\n    }\n\n    if (value == null) {\n        throw TypeError(\n            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n            'or Array-like Object. Received type ' + (typeof value)\n        )\n    }\n\n    if (isInstance(value, ArrayBuffer) ||\n        (value && isInstance(value.buffer, ArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length)\n    }\n\n    if (typeof value === 'number') {\n        throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n        )\n    }\n\n    var valueOf = value.valueOf && value.valueOf()\n    if (valueOf != null && valueOf !== value) {\n        return Buffer.from(valueOf, encodingOrOffset, length)\n    }\n\n    var b = fromObject(value)\n    if (b) return b\n\n    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n        typeof value[Symbol.toPrimitive] === 'function') {\n        return Buffer.from(\n            value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n        )\n    }\n\n    throw new TypeError(\n        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n        'or Array-like Object. Received type ' + (typeof value)\n    )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n    return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n    if (typeof size !== 'number') {\n        throw new TypeError('\"size\" argument must be of type number')\n    } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n    }\n}\n\nfunction alloc (size, fill, encoding) {\n    assertSize(size)\n    if (size <= 0) {\n        return createBuffer(size)\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === 'string'\n            ? createBuffer(size).fill(fill, encoding)\n            : createBuffer(size).fill(fill)\n    }\n    return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n    return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n    assertSize(size)\n    return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n    return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\n// Buffer.allocUnsafeSlow = function (size) {\n//     return allocUnsafe(size)\n// }\n\nfunction fromString (string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') {\n        encoding = 'utf8'\n    }\n\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('Unknown encoding: ' + encoding)\n    }\n\n    var length = byteLength(string, encoding) | 0\n    var buf = createBuffer(length)\n\n    var actual = buf.write(string, encoding)\n\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        buf = buf.slice(0, actual)\n    }\n\n    return buf\n}\n\nfunction fromArrayLike (array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0\n    var buf = createBuffer(length)\n    for (var i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255\n    }\n    return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds')\n    }\n\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds')\n    }\n\n    var buf\n    if (byteOffset === undefined && length === undefined) {\n        buf = new Uint8Array(array)\n    } else if (length === undefined) {\n        buf = new Uint8Array(array, byteOffset)\n    } else {\n        buf = new Uint8Array(array, byteOffset, length)\n    }\n\n    // Return an augmented `Uint8Array` instance\n    buf.__proto__ = Buffer.prototype\n    return buf\n}\n\nfunction fromObject (obj) {\n    if (Buffer.isBuffer(obj)) {\n        var len = checked(obj.length) | 0\n        var buf = createBuffer(len)\n\n        if (buf.length === 0) {\n            return buf\n        }\n\n        obj.copy(buf, 0, 0, len)\n        return buf\n    }\n\n    if (obj.length !== undefined) {\n        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n            return createBuffer(0)\n        }\n        return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data)\n    }\n}\n\nfunction checked (length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= K_MAX_LENGTH) {\n        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n            'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n    }\n    return length | 0\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n    return b != null && b._isBuffer === true &&\n        b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n    switch (String(encoding).toLowerCase()) {\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return true\n        default:\n            return false\n    }\n}\n\nBuffer.concat = function concat (list, length) {\n    if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n\n    if (list.length === 0) {\n        return Buffer.alloc(0)\n    }\n\n    var i\n    if (length === undefined) {\n        length = 0\n        for (i = 0; i < list.length; ++i) {\n            length += list[i].length\n        }\n    }\n\n    var buffer = Buffer.allocUnsafe(length)\n    var pos = 0\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i]\n        if (isInstance(buf, Uint8Array)) {\n            buf = Buffer.from(buf)\n        }\n        if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers')\n        }\n        buf.copy(buffer, pos)\n        pos += buf.length\n    }\n    return buffer\n}\n\nfunction byteLength (string, encoding) {\n    if (Buffer.isBuffer(string)) {\n        return string.length\n    }\n    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength\n    }\n    if (typeof string !== 'string') {\n        throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n            'Received type ' + typeof string\n        )\n    }\n\n    var len = string.length\n    var mustMatch = (arguments.length > 2 && arguments[2] === true)\n    if (!mustMatch && len === 0) return 0\n\n    // Use a for loop to avoid recursion\n    var loweredCase = false\n    for (;;) {\n        switch (encoding) {\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n                return len\n            case 'utf8':\n            case 'utf-8':\n                return utf8ToBytes(string).length\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return len * 2\n            case 'hex':\n                return len >>> 1\n            default:\n                if (loweredCase) {\n                    return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n                }\n                encoding = ('' + encoding).toLowerCase()\n                loweredCase = true\n        }\n    }\n}\nBuffer.byteLength = byteLength\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n    if (!start) start = 0\n    if (!end && end !== 0) end = this.length\n    if (targetStart >= target.length) targetStart = target.length\n    if (!targetStart) targetStart = 0\n    if (end > 0 && end < start) end = start\n\n    // Copy 0 bytes; we're done\n    if (end === start) return 0\n    if (target.length === 0 || this.length === 0) return 0\n\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError('targetStart out of bounds')\n    }\n    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n    if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n    // Are we oob?\n    if (end > this.length) end = this.length\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start\n    }\n\n    var len = end - start\n\n    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n        // Use built-in when available, missing from IE11\n        this.copyWithin(targetStart, start, end)\n    } else if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for (var i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start]\n        }\n    } else {\n        Uint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n        )\n    }\n\n    return len\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = 'utf8'\n        length = this.length\n        offset = 0\n        // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === 'string') {\n        encoding = offset\n        length = this.length\n        offset = 0\n        // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset >>> 0\n        if (isFinite(length)) {\n            length = length >>> 0\n            if (encoding === undefined) encoding = 'utf8'\n        } else {\n            encoding = length\n            length = undefined\n        }\n    } else {\n        throw new Error(\n            'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n        )\n    }\n\n    const remaining = this.length - offset\n    if (length === undefined || length > remaining) length = remaining\n\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n        throw new RangeError('Attempt to write outside buffer bounds')\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    let loweredCase = false\n    for (;;) {\n        switch (encoding) {\n            case 'hex':\n                return hexWrite(this, string, offset, length)\n\n            case 'utf8':\n            case 'utf-8':\n                return utf8Write(this, string, offset, length)\n\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n                return asciiWrite(this, string, offset, length)\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return ucs2Write(this, string, offset, length)\n\n            default:\n                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n                encoding = ('' + encoding).toLowerCase()\n                loweredCase = true\n        }\n    }\n}\n\nfunction hexWrite (buf, string, offset, length) {\n    offset = Number(offset) || 0\n    const remaining = buf.length - offset\n    if (!length) {\n        length = remaining\n    } else {\n        length = Number(length)\n        if (length > remaining) {\n            length = remaining\n        }\n    }\n\n    const strLen = string.length\n\n    if (length > strLen / 2) {\n        length = strLen / 2\n    }\n    let i\n    for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string.substr(i * 2, 2), 16)\n        if (numberIsNaN(parsed)) return i\n        buf[offset + i] = parsed\n    }\n    return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n    let i\n    for (i = 0; i < length; ++i) {\n        if ((i + offset >= dst.length) || (i >= src.length)) break\n        dst[i + offset] = src[i]\n    }\n    return i\n}\n\nfunction utf16leToBytes (str, units) {\n    let c, hi, lo\n    const byteArray = []\n    for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break\n\n        c = str.charCodeAt(i)\n        hi = c >> 8\n        lo = c % 256\n        byteArray.push(lo)\n        byteArray.push(hi)\n    }\n\n    return byteArray\n}\n\nfunction asciiToBytes (str) {\n    const byteArray = []\n    for (let i = 0; i < str.length; ++i) {\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF)\n    }\n    return byteArray\n}\n\nfunction utf8ToBytes (string, units) {\n    units = units || Infinity\n    var codePoint\n    var length = string.length\n    var leadSurrogate = null\n    var bytes = []\n\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i)\n\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n                    continue\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n                    continue\n                }\n\n                // valid lead\n                leadSurrogate = codePoint\n\n                continue\n            }\n\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n                leadSurrogate = codePoint\n                continue\n            }\n\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        }\n\n        leadSurrogate = null\n\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break\n            bytes.push(codePoint)\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break\n            bytes.push(\n                codePoint >> 0x6 | 0xC0,\n                codePoint & 0x3F | 0x80\n            )\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break\n            bytes.push(\n                codePoint >> 0xC | 0xE0,\n                codePoint >> 0x6 & 0x3F | 0x80,\n                codePoint & 0x3F | 0x80\n            )\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break\n            bytes.push(\n                codePoint >> 0x12 | 0xF0,\n                codePoint >> 0xC & 0x3F | 0x80,\n                codePoint >> 0x6 & 0x3F | 0x80,\n                codePoint & 0x3F | 0x80\n            )\n        } else {\n            throw new Error('Invalid code point')\n        }\n    }\n\n    return bytes\n}\n\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n    return obj instanceof type ||\n        (obj != null && obj.constructor != null && obj.constructor.name != null &&\n        obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n    // For IE11 support\n    return obj !== obj // eslint-disable-line no-self-compare\n}\n\n\n","'use strict';\n\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = undefined;\n    }\n\n    if (code != null) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        return assign(new ErrClass(), props);\n    }\n}\n\nmodule.exports = createError;\n","\n/*\n    函数节流\n    baseInterval: 初始时间间隔\n    factor: 增长指数\n */\nfunction getPeersThrottle(method, context, baseInterval = 70) {\n// function getPeersThrottle(method, context, baseInterval = 25) {\n    var handler = null;\n    var going = false;\n    var factor = 1.0;\n    var delay = baseInterval;\n    return function (cancel = false) {\n        if (cancel) {\n            clearTimeout(handler);\n            going = false;\n            return;\n        }\n        if (going) return;\n        going = true;\n        handler = setTimeout(function(){\n            method.call(context, delay);\n            going = false;\n            handler = null;\n        }, delay*1000);\n        delay *= factor;\n    }\n};\n\nexport default getPeersThrottle;\n","import { noop } from './tool-funs';\n\nconst logMap = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3,\n    none: 4,\n};\n\nclass Logger {\n    constructor(logLevel) {\n        this.logLevel = logLevel;\n        this.onlineDebug = false;\n        console.debug = console.log;\n\n        if ((logLevel === 'debug' || logLevel === 'info') && __RELEASE__) {\n            this.logLevel = __MIN_LOG_LEVEL__;\n        }\n\n        if (logLevel === true) {\n            this.logLevel = 'warn';\n        } else if (logLevel === false) {\n            this.logLevel = 'none';\n        } else if (!(logLevel in logMap)) {\n            this.logLevel = 'error';   // 默认error\n        }\n        this.resetLogger();\n    }\n\n    enableDebug() {\n        this.onlineDebug = true;\n        for (let key in logMap) {\n            this[key] = console[key];\n        }\n    }\n\n    resetLogger() {\n        this.onlineDebug = false;\n        for (let key in logMap) {\n            if (logMap[key] < logMap[this.logLevel]) {\n                this[key] = noop;\n            } else {\n                this[key] = console[key];\n            }\n        }\n    }\n\n    get isDebugLevel() {\n        return logMap[this.logLevel] <= 2 || this.onlineDebug;\n    }\n\n}\n\nexport default Logger;\n","/*\n * JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/* global define */\n\n;(function ($) {\n    'use strict'\n\n    /*\n     * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n     * to work around bugs in some JS interpreters.\n     */\n    function safeAdd (x, y) {\n        var lsw = (x & 0xffff) + (y & 0xffff)\n        var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n        return (msw << 16) | (lsw & 0xffff)\n    }\n\n    /*\n     * Bitwise rotate a 32-bit number to the left.\n     */\n    function bitRotateLeft (num, cnt) {\n        return (num << cnt) | (num >>> (32 - cnt))\n    }\n\n    /*\n     * These functions implement the four basic operations the algorithm uses.\n     */\n    function md5cmn (q, a, b, x, s, t) {\n        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\n    }\n    function md5ff (a, b, c, d, x, s, t) {\n        return md5cmn((b & c) | (~b & d), a, b, x, s, t)\n    }\n    function md5gg (a, b, c, d, x, s, t) {\n        return md5cmn((b & d) | (c & ~d), a, b, x, s, t)\n    }\n    function md5hh (a, b, c, d, x, s, t) {\n        return md5cmn(b ^ c ^ d, a, b, x, s, t)\n    }\n    function md5ii (a, b, c, d, x, s, t) {\n        return md5cmn(c ^ (b | ~d), a, b, x, s, t)\n    }\n\n    /*\n     * Calculate the MD5 of an array of little-endian words, and a bit length.\n     */\n    function binlMD5 (x, len) {\n        /* append padding */\n        x[len >> 5] |= 0x80 << (len % 32)\n        x[((len + 64) >>> 9 << 4) + 14] = len\n\n        var i\n        var olda\n        var oldb\n        var oldc\n        var oldd\n        var a = 1732584193\n        var b = -271733879\n        var c = -1732584194\n        var d = 271733878\n\n        for (i = 0; i < x.length; i += 16) {\n            olda = a\n            oldb = b\n            oldc = c\n            oldd = d\n\n            a = md5ff(a, b, c, d, x[i], 7, -680876936)\n            d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)\n            c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)\n            b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)\n            a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)\n            d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)\n            c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)\n            b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)\n            a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)\n            d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)\n            c = md5ff(c, d, a, b, x[i + 10], 17, -42063)\n            b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)\n            a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)\n            d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)\n            c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)\n            b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\n            a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)\n            d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)\n            c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)\n            b = md5gg(b, c, d, a, x[i], 20, -373897302)\n            a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)\n            d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)\n            c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)\n            b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)\n            a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)\n            d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)\n            c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)\n            b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)\n            a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)\n            d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)\n            c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)\n            b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\n            a = md5hh(a, b, c, d, x[i + 5], 4, -378558)\n            d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)\n            c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)\n            b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)\n            a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)\n            d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)\n            c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)\n            b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)\n            a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)\n            d = md5hh(d, a, b, c, x[i], 11, -358537222)\n            c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)\n            b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)\n            a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)\n            d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)\n            c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)\n            b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)\n\n            a = md5ii(a, b, c, d, x[i], 6, -198630844)\n            d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)\n            c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)\n            b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)\n            a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)\n            d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)\n            c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)\n            b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)\n            a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)\n            d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)\n            c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)\n            b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)\n            a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)\n            d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)\n            c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)\n            b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)\n\n            a = safeAdd(a, olda)\n            b = safeAdd(b, oldb)\n            c = safeAdd(c, oldc)\n            d = safeAdd(d, oldd)\n        }\n        return [a, b, c, d]\n    }\n\n    /*\n     * Convert an array of little-endian words to a string\n     */\n    function binl2rstr (input) {\n        var i\n        var output = ''\n        var length32 = input.length * 32\n        for (i = 0; i < length32; i += 8) {\n            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xff)\n        }\n        return output\n    }\n\n    /*\n     * Convert a raw string to an array of little-endian words\n     * Characters >255 have their high-byte silently ignored.\n     */\n    function rstr2binl (input) {\n        var i\n        var output = []\n        output[(input.length >> 2) - 1] = undefined\n        for (i = 0; i < output.length; i += 1) {\n            output[i] = 0\n        }\n        var length8 = input.length * 8\n        for (i = 0; i < length8; i += 8) {\n            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << (i % 32)\n        }\n        return output\n    }\n\n    /*\n     * Calculate the MD5 of a raw string\n     */\n    function rstrMD5 (s) {\n        return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\n    }\n\n    /*\n     * Calculate the HMAC-MD5, of a key and some data (raw strings)\n     */\n    function rstrHMACMD5 (key, data) {\n        var i\n        var bkey = rstr2binl(key)\n        var ipad = []\n        var opad = []\n        var hash\n        ipad[15] = opad[15] = undefined\n        if (bkey.length > 16) {\n            bkey = binlMD5(bkey, key.length * 8)\n        }\n        for (i = 0; i < 16; i += 1) {\n            ipad[i] = bkey[i] ^ 0x36363636\n            opad[i] = bkey[i] ^ 0x5c5c5c5c\n        }\n        hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n        return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\n    }\n\n    /*\n     * Convert a raw string to a hex string\n     */\n    function rstr2hex (input) {\n        var hexTab = '0123456789abcdef'\n        var output = ''\n        var x\n        var i\n        for (i = 0; i < input.length; i += 1) {\n            x = input.charCodeAt(i)\n            output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)\n        }\n        return output\n    }\n\n    /*\n     * Encode a string as utf-8\n     */\n    function str2rstrUTF8 (input) {\n        return unescape(encodeURIComponent(input))\n    }\n\n    /*\n     * Take string arguments and return either raw or hex encoded strings\n     */\n    function rawMD5 (s) {\n        return rstrMD5(str2rstrUTF8(s))\n    }\n    function hexMD5 (s) {\n        return rstr2hex(rawMD5(s))\n    }\n    function rawHMACMD5 (k, d) {\n        return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\n    }\n    function hexHMACMD5 (k, d) {\n        return rstr2hex(rawHMACMD5(k, d))\n    }\n\n    function md5 (string, key, raw) {\n        if (!key) {\n            if (!raw) {\n                return hexMD5(string)\n            }\n            return rawMD5(string)\n        }\n        if (!raw) {\n            return hexHMACMD5(key, string)\n        }\n        return rawHMACMD5(key, string)\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        define(function () {\n            return md5\n        })\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = md5\n    } else {\n        $.md5 = md5\n    }\n})(this)\n","\nfunction getMediaSource () {\n    if (typeof window !== 'undefined') {\n        return window.MediaSource || window.WebKitMediaSource;\n    }\n}\n\nexport function isMSESupported () {\n    const mediaSource = getMediaSource();\n    const sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;\n    const isTypeSupported = mediaSource &&\n        typeof mediaSource.isTypeSupported === 'function' &&\n        mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n\n    // if SourceBuffer is exposed ensure its API is valid\n    // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n    const sourceBufferValidAPI = !sourceBuffer ||\n        (sourceBuffer.prototype &&\n            typeof sourceBuffer.prototype.appendBuffer === 'function' &&\n            typeof sourceBuffer.prototype.remove === 'function');\n    return !!isTypeSupported && !!sourceBufferValidAPI;\n}\n","\nconst device = {\n    ANDROID_WEB: 'android-web',\n    IOS_WEB: 'iOS-web',\n    PC_NATIVE: 'PC-native',\n    PC_WEB: 'PC-web'\n};\n\nvar os = {\n    //网络类型 wifi 4g 3g 2g unknown or '' non_network cellular\n    getNetType: function () {\n        let netType = ((new RegExp('nettype\\\\/(\\\\w*)').exec(_getUA()) || [, ''])[1]).toLowerCase();\n        if (!netType && navigator.connection) {\n            /*\n                \"bluetooth\",\n                \"cellular\",\n                \"ethernet\",\n                \"mixed\",\n                \"none\",\n                \"other\",\n                \"unknown\",\n                \"wifi\",\n                \"wimax\"\n             */\n            const type = navigator.connection.type;\n            switch (type) {\n                case 'ethernet':\n                    netType = 'ethernet';\n                    break;\n                case 'cellular':\n                    // netType = '4g';\n                    netType = 'cellular';\n                    break;\n                default:\n                    netType = 'wifi'\n            }\n        }\n        return netType;\n    },\n    //获取设备类型\n    getPlatform: function () {\n        if (os.isAndroid()) {\n            return device.ANDROID_WEB;\n        } else if (os.isIOS()) {\n            return device.IOS_WEB;\n        } else if (os.isElectron()) {\n            return device.PC_NATIVE;\n        } else {\n            return device.PC_WEB;\n        }\n    },\n    isX5: function () {\n        return this.isAndroid() && /\\s(TBS|X5Core)\\/[\\w\\.\\-]+/i.test(_getUA());\n    },\n    isPC: function () {\n        return !_toNum(_platform('os ')) && !_toNum(_platform('android[/ ]'));\n    },\n    isIOS: function () {\n        return _toNum(_platform('os '));\n    },\n    isAndroid: function () {\n        return _toNum(_platform('android[/ ]'));\n    },\n    isIOSSafari: function () {\n        return this.isIOS() && this.isSafari();\n    },\n    isElectron: function () {\n        return /electron/i.test(_getUA());\n    },\n    isMobile: function () {\n        return os.isAndroid() || os.isIOS();\n    },\n    isSafari: function () {\n        return /^((?!chrome|android).)*safari/i.test(_getUA());\n    },\n    isFirefox: function() {\n        return /firefox/i.test(_getUA());\n    },\n    isChrome: function() {\n        return /chrome/i.test(_getUA());\n    },\n    isLocalHost: function() {\n        return location.hostname === 'localhost';\n    },\n\n    device,\n\n    getBrowser: function () {\n        if (os.isX5()) {\n            return 'X5'\n        } else if (os.isChrome()) {\n            return 'Chrome'\n        } else if (os.isFirefox()) {\n            return 'Firefox'\n        } else if (os.isIOSSafari()) {\n            return 'iOS-Safari'\n        } else if (os.isSafari()) {\n            return 'Mac-Safari'\n        } else {\n            return 'Unknown'\n        }\n    }\n};\n\nfunction _getUA() {\n    return navigator.userAgent.toLowerCase();\n}\n\nfunction _platform(os) {\n    var ver = ('' + (new RegExp(os + '(\\\\d+((\\\\.|_)\\\\d+)*)').exec(_getUA()) || [, 0])[1]);\n    // undefined < 3 === false, but null < 3 === true\n    return ver || undefined;\n}\n\nfunction _toNum(str) {\n    return parseFloat((str || \"\").replace(/\\_/g, '.')) || 0;\n}\n\nmodule.exports = os;\n","\nconst players = {\n    'DPlayer': 'dplayer',\n    'CBPlayer': 'cbplayer',\n    'jwplayer': 'jwplayer',\n    'videojs': 'videojs',\n    'Clappr': 'clappr',\n    'ckplayer': 'ckplayer',\n    'MediaElementPlayer': 'mediaelement',\n    'MediaElement': 'mediaelement',\n    'TcPlayer': 'tcplayer',\n    'flowplayer': 'flowplayer',\n    'Chimee': 'chimee',\n    'ChimeePlayer': 'chimee',\n    'HlsJsPlayer': 'xgplayer',\n    'fluidPlayer': 'fluidplayer',\n    'OpenPlayer': 'openplayer',\n    'Plyr': 'plyr',\n    'Playerjs': 'playerjs',\n    'Aliplayer': 'aliplayer',\n    'shaka': 'shakaplayer',\n};\n\nexport default function () {\n    let ret;\n    for (let player in players) {\n        if (window[player]) {\n            ret = players[player];\n            break;\n        }\n    }\n    return ret;\n}\n","let promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n    ? queueMicrotask.bind(globalThis)\n    // reuse resolved promise, and allocate it lazily\n    : cb => (promise || (promise = Promise.resolve()))\n        .then(cb)\n        .catch(err => setTimeout(() => { throw err }, 0))\n","/**\n * 存储数据\n */\nexport const setItem = (key, value) => {\n    // 将数组、对象类型的数据转化为 JSON 字符串进行存储\n    if (typeof value === 'object') {\n        value = JSON.stringify(value)\n    }\n    localStorage.setItem(key, value)\n}\n\n/**\n * 是否有未过期数据\n */\nexport const hasItemUnexpired = key => {\n    const data = localStorage.getItem(key)\n    try {\n        const item = JSON.parse(data)\n        if (item.duration && item.startTime) {\n            let date = new Date().getTime();\n            // if (date - item.startTime >= item.duration) {\n            //     console.warn(`ipdate expired`)\n            // }\n            return date - item.startTime < item.duration\n        } else {\n            return false\n        }\n    } catch (err) {\n        return false\n    }\n}\n\n/**\n * 获取数据\n */\nexport const getItem = key => {\n    const data = localStorage.getItem(key)\n    try {\n        const item = JSON.parse(data)\n        if (item.value) {\n            return item.value\n        } else {\n            return item;\n        }\n    } catch (err) {\n        return data\n    }\n}\n\n/**\n * 删除数据\n */\nexport const removeItem = key => {\n    localStorage.removeItem(key)\n}\n\n/**\n * 删除所有数据\n */\nexport const removeAllItem = () => {\n    localStorage.clear()\n}\n\n/**\n * 存储数据（带过期时间）ms\n */\nexport const setItemWithExpiration = (key, value, duration) => {\n    let obj = {\n        value,\n        duration,\n        startTime: new Date().getTime()//记录何时将值存入缓存，毫秒级\n    }\n    setItem(key, obj)\n}\n","import { Buffer } from './buffer'\nimport Peer from \"../peer\";\n\nconst CHECK_PEERS_INTERVAL = 3;                   // 定时p2p下载的时间间隔 单位秒\n\nexport function noop() {\n    return true;\n}\n\n// export function getQueryParam(name) {\n//     var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\");\n//     var r = location.search.substr(1).match(reg);\n//     if (r != null && r[2] !== '') return r[2].toString();\n//     return '';\n// }\n\nexport function getQueryParam(name) {\n    return new URL(location.href).searchParams.get(name)\n}\n\n// 向url追加参数\nexport function updateQueryStringParam(uri, key, value) {\n    // if(!value) {\n    //     return uri;\n    // }\n    var re = new RegExp(\"([?&])\" + key + \"=.*?(&|$)\", \"i\");\n    var separator = uri.indexOf('?') !== -1 ? \"&\" : \"?\";\n    if (uri.match(re)) {\n        return uri.replace(re, '$1' + key + \"=\" + value + '$2');\n    }\n    else {\n        return uri + separator + key + \"=\" + value;\n    }\n}\n\n// 获取当前时间戳 秒\nexport function getCurrentTs() {\n\n    return Date.parse(new Date()) / 1000;\n}\n\n// 生成从minNum到maxNum的随机数\nexport function randomNum(minNum, maxNum) {\n    return parseInt(Math.random() * ( maxNum - minNum + 1 ) + minNum, 10);\n}\n\n// 计算check peers的delay\nexport function calCheckPeersDelay(peerNum) {\n    if (peerNum === 0) return CHECK_PEERS_INTERVAL;\n    return 0.33*peerNum + 0.67;         // 假设最高下载peer数为10\n}\n\nexport function performRangeRequest(uri, range, xhrSetup) {\n    const xhr = new XMLHttpRequest();\n    return new Promise(((resolve, reject) => {\n        xhr.open('GET', uri, true);\n        xhr.responseType = 'arraybuffer';\n        xhr.timeout = 3500;\n        xhr.onreadystatechange = (event) => {\n            const readyState = xhr.readyState;\n            if (readyState === 4) {\n                const status = xhr.status;\n                if (status >= 200 && status < 300) {\n                    resolve(xhr.response)\n                } else {\n                    reject(`status ${status}`);\n                }\n            }\n        }\n        xhr.onerror = (event) => {\n            reject(`request error`);\n        };\n        xhr.ontimeout = (event) => {\n            reject('timeout');\n        };\n        xhr.setRequestHeader('Range', range || 'bytes=0-0');\n        if (xhrSetup) {\n            xhrSetup(xhr, uri);\n        }\n        xhr.send();\n    }));\n}\n\n// export function fetchRangeRequest(uri) {\n//     return new Promise((resolve, reject) => {\n//         fetch(uri, {\n//             headers: {\n//                 Range: 'bytes=0-0',\n//             },\n//         }).then(response => {\n//             if (response.status === 206) {\n//                 // CDN支持Range请求\n//                 resolve();\n//             } else {\n//                 reject();\n//             }\n//         }).catch(err => {\n//             reject();\n//         })\n//     })\n// }\n\nexport function navLang() {\n    var lang = navigator.language || navigator.userLanguage //常规浏览器语言和IE浏览器\n    // lang = lang.substr(0, 2) //截取lang前2位字符\n    return lang === 'zh-CN' ? 'cn' : 'en'\n}\n\nexport function dontWaitFor(promise) {\n    // Effective no-op.\n    promise.then(() => {});\n}\n\nexport function timeout(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function getBrowserRTC () {\n    if (typeof window === 'undefined') return null\n    var wrtc = {\n        RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection ||\n            window.webkitRTCPeerConnection,\n        RTCSessionDescription: window.RTCSessionDescription ||\n            window.mozRTCSessionDescription || window.webkitRTCSessionDescription,\n        RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate ||\n            window.webkitRTCIceCandidate\n    }\n    if (!wrtc.RTCPeerConnection) return null\n    return wrtc\n}\n\nexport function copyBuffer(source) {\n    const payloadBuf = Buffer.from(source);\n    const targetBuffer = new Buffer(source.byteLength);\n    payloadBuf.copy(targetBuffer);\n    return targetBuffer\n}\n\nexport function getMaxSequence(m3u8) {\n    const lines = m3u8.split('\\n');\n    let start = 0;\n    const tsTag = '#EXTINF';\n    let count = 0;\n    for (let line of lines) {\n        const match = (/^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/).exec(line);\n        if (match) {\n            if (match[1]) {\n                start = parseInt(match[1], 10);\n                break\n            }\n        }\n    }\n    for (let line of lines) {\n        if (line.startsWith(tsTag)) {\n            count ++;\n        }\n    }\n    return start+count-1\n}\n\nexport function isHttps() {\n    return location.protocol.startsWith('https')\n}\n\nexport function isInteger(obj) {\n    return typeof obj === 'number' && obj%1 === 0\n}\n\n/*\ndisplay: block;\nbackground-image: -webkit-linear-gradient(left, #3498db, #f47920 10%, #d71345 20%, #f7acbc 30%,\n#ffd400 40%, #3498db 50%, #f47920 60%, #d71345 70%, #f7acbc 80%, #ffd400 90%, #3498db);\ncolor: transparent;\n-webkit-text-fill-color: transparent;\n-webkit-background-clip: text;\nbackground-size: 200% 100%;\nanimation: masked-animation 4s infinite linear;\n */\nexport function appendSlogan(text, href, target) {\n    var div = document.createElement( \"div\" );\n    div.style.position = 'absolute'\n    div.style.top = '8px'\n    div.style.left = '8px'\n    div.style.zIndex = '999'\n    div.style.fontSize = '10px'\n    // var h4 = document.createElement( \"h4\" );\n    var a = document.createElement( \"a\" );\n    a.href= href\n    a.target=\"_blank\"\n    a.innerText= text;\n    a.style.color = 'white'\n    a.style.textDecoration = 'none'\n    a.style.textShadow = '0 0 5px white,0 0 10px #00FFFF,0 0 15px #7FFF00,0 0 20px white'\n    // const s = h4.style\n    // s.display = 'block'\n    // s.backgroundImage = '-webkit-linear-gradient(left, #3498db, #f47920 10%, #d71345 20%, #f7acbc 30%, #ffd400 40%, #3498db 50%, #f47920 60%, #d71345 70%, #f7acbc 80%, #ffd400 90%, #3498db)'\n    // s.color = 'transparent'\n    // s.animation = 'masked-animation 4s infinite linear'\n    // s.backgroundSize = '200% 100%'\n    // s.webkitTextFillColor = 'transparent'\n    // s.backgroundClip = 'text'\n    var i = document.createElement( \"i\" )\n    i.style.width = '5px'\n    i.style.height = '5px'\n    i.style.borderRadius = '50%'\n    i.style.display = 'inline-block'\n    i.style.backgroundColor = '#67C23A'\n    i.style.marginBottom = '2px'\n    i.style.marginRight = '4px'\n    div.appendChild(i)\n    div.appendChild(a)\n    // insertAfter(div, target)\n    var parent = target.parentNode;\n    if (parent) {\n        parent.insertBefore(div, target)\n    }\n}\n\n// function insertAfter(newElement, targetElement){\n//     var parent = targetElement.parentNode\n//     parent.style.position = 'relative'\n//     if (parent.lastChild === targetElement) {\n//         // 如果最后的节点是目标元素，则直接添加。因为默认是最后\n//         parent.appendChild(newElement)\n//     }\n//     else {\n//         parent.insertBefore(newElement, targetElement.nextSibling)\n//         //如果不是，则插入在目标元素的下一个兄弟节点 的前面。也就是目标元素的后面\n//     }\n// }\n\nexport function getHomeUrl() {\n    return window.atob('aHR0cHM6Ly9zd2FybWNsb3VkLm5ldC9lbi8=')\n}\n\n// 从from开始将sink分成若干个，每个大小packetSize\nexport function splitBytes(sink, from) {\n    const packetSize = Peer.defaultPacketSize;\n    const dataSize = sink.byteLength - from;\n    const bufList = [];\n    let offset = from;\n    let packetsCompleted = Math.floor(dataSize / packetSize);\n    let remainder = dataSize % packetSize;\n    for (let i=0; i < packetsCompleted; i++) {\n        const buffer = Buffer(packetSize);\n        sink.copy(buffer, 0, offset, offset + packetSize)\n        bufList.push(buffer);\n        offset += packetSize;\n    }\n    if (remainder > 0) {\n        const buffer = Buffer(remainder);\n        sink.copy(buffer, 0, offset, offset + remainder)\n        bufList.push(buffer);\n    }\n    return bufList\n}\n\n\n","import EventEmitter from 'events'\nimport ReconnectingWebSocket from 'reconnecting-websocket'\nimport { randomNum } from './utils/tool-funs'\n\nconst PING_INTERVAL = 60;\nconst PONG_TIMEOUT = 15;\n\nclass WebsocketClient extends EventEmitter{\n    constructor(logger, config, addr, interval, name='main') {\n        super();\n        this.logger = logger;\n        this.config = config;\n        // console.warn(\"SignalClient \" + addr);\n        this.wsAddr = addr;     // 已经加了查询参数\n        this.serverVersion = 0;\n        this.pingInterval = interval || PING_INTERVAL;\n        // this.pingInterval = 30;           // test\n        this._ws = this._init();\n        this.name = name;\n    }\n\n    _init() {\n        const wsOptions = {\n            // debug: true,\n            maxRetries: this.config.wsMaxRetries,\n            minReconnectionDelay: randomNum(10000, 60000), // 生成15到40秒的随机数\n            maxReconnectionDelay: 600*1000,\n            maxEnqueuedMessages: 20,\n        };\n        // console.warn(\"ws init \" + this.wsAddr + \" minReconnectionDelay \" + wsOptions.minReconnectionDelay);\n        let ws = new ReconnectingWebSocket(this.wsAddr, undefined, wsOptions);\n        ws.addEventListener('open', () => {\n            this.logger.info(`signal ${this.name} ${this.wsAddr} connection opened`);\n            if (this.onopen) this.onopen();\n            this._startPing(this.pingInterval);    // 开始发送心跳包\n        })\n\n        ws.push = ws.send;\n        ws.send = msg => {\n            // let msgStr = JSON.stringify(Object.assign({peer_id: id}, msg));\n            let msgStr = JSON.stringify(msg);\n            ws.push(msgStr);\n\n            // this._resetPing();    // 重置心跳\n        };\n        ws.addEventListener('message', (e) => {\n            let data = e.data;\n            const msg = JSON.parse(data);\n\n            const action = msg.action;\n            if (action === 'pong') {\n                clearTimeout(this.pongTimer);\n                return\n            } else if (action === 'ver') {\n                this.serverVersion = msg.ver;\n                return\n            } else if (action === 'close') {\n                this.logger.warn(`server close signal ${this.name} reason ${msg.reason}`);\n                this.close();\n                return;\n            }\n\n            if (this.onmessage) this.onmessage(msg, this.name)\n\n        })\n\n        ws.addEventListener('close', (e) => {\n            this.logger.warn(`signal ${this.name} ${this.wsAddr} closed ${e.code} ${e.reason}`);\n            if (this.onclose) this.onclose();\n            this._stopPing();                      // 停止心跳\n            // if (e.code === 1000) {\n            //     // 正常关闭\n            //\n            // } else {\n            //     this.connecting = true;            // 防止调用reconnect\n            // }\n        })\n\n        ws.addEventListener('error', (err) => {\n            this.logger.error(`signal ${this.name} ${this.wsAddr} error`);\n            this._stopPing();                      // 停止心跳\n            if (this.onerror) this.onerror(err);\n        })\n\n        return ws;\n    }\n\n    sendSignal(remotePeerId, data) {\n        const msg = {\n            action: 'signal',\n            to_peer_id: remotePeerId,\n            data: data\n        };\n        this._send(msg);\n    }\n\n    sendReject(remotePeerId, reason, fatal) {\n        const msg = {\n            action: 'reject',\n            to_peer_id: remotePeerId,\n            reason,\n            fatal,\n        };\n        this._send(msg);\n    }\n\n    _send(msg) {\n        if (this._ws) {\n            // this.logger.info(`${this.name} send ${JSON.stringify(msg)}`);\n            this._ws.send(msg);\n        }\n\n    }\n\n    _startPing(interval = 120) {\n        if (this.connected) {\n            this.pingTimer = setInterval(() => {\n                const msg = {\n                    action: 'ping',\n                };\n                this._send(msg);\n                if (this.serverVersion >= 22) {\n                    this._waitForPong();\n                }\n            }, interval * 1000)\n        }\n    }\n\n    _waitForPong() {\n        this.pongTimer = setTimeout(() => {\n            this.logger.warn(`signal ${this.name} wait for pong timeout, reconnect`);\n            this.close();\n            this.reconnect();\n        }, PONG_TIMEOUT * 1000)\n    }\n\n    _resetPing() {\n        this._stopPing();\n        this._startPing(this.pingInterval);\n    }\n\n    _stopPing() {\n        clearInterval(this.pingTimer);\n        clearTimeout(this.pongTimer);\n        this.pingTimer = null;\n        this.pongTimer = null;\n    }\n\n    close() {\n        const closeWs = () => {\n            if (this._ws) this._ws.close(1000, 'normal close');\n        }\n        this.logger.info(`close signal ${this.name}`);\n        this._stopPing();                           // 停止心跳\n        // if (this._ws.readyState === ReconnectingWebSocket.CONNECTING) {\n        //     this._ws.addEventListener('open', () => {\n        //         closeWs();\n        //     });\n        //     return;\n        // }\n        // if (!this.connected) return;\n        // this.connected = false;\n        closeWs();\n    }\n\n    reconnect() {\n        if (!this._ws) return;\n        this.logger.info(`reconnect signal ${this.name}`);\n        this._ws.reconnect();\n    }\n\n    destroy() {\n        this.close();\n        this._ws = null;\n        this.removeAllListeners();\n        // this.logger.warn(`destroy ${this.name}`);\n    }\n\n    get connected() {\n        if (!this._ws) return false\n        return this._ws.readyState === ReconnectingWebSocket.OPEN\n    }\n}\n\nexport default WebsocketClient;\n","\nexport default class BitCountsManager {\n    constructor() {\n        this.levelMap = new Map();        // level -> bitCounts\n    }\n\n    totalLevels() {\n        return this.levelMap.size\n    }\n\n    has(sn, level) {\n        const bitCounts = this._createOrGetMap(level);\n        return bitCounts.has(sn)\n    }\n\n    delete(sn, level) {\n        const bitCounts = this._createOrGetMap(level);\n        return bitCounts.delete(sn)\n    }\n\n    decre(sn, level) {\n        const bitCounts = this._createOrGetMap(level);\n        if (bitCounts.has(sn)) {\n            let last = bitCounts.get(sn);\n            if (last === 1) {\n                bitCounts.delete(sn);\n            } else {\n                bitCounts.set(sn, last-1);\n            }\n        }\n    }\n\n    incre(sn, level) {\n        const bitCounts = this._createOrGetMap(level);\n        if (!bitCounts.has(sn)) {\n            bitCounts.set(sn, 1);\n        } else {\n            let last = bitCounts.get(sn);\n            bitCounts.set(sn, last+1);\n        }\n    }\n\n    clear() {\n        this.levelMap.forEach((bitCounts) => {\n            bitCounts.clear()\n        })\n    }\n\n    size(level) {\n        const bitCounts = this._createOrGetMap(level);\n        return bitCounts.size\n    }\n\n    _createOrGetMap(level) {\n        // if (level === undefined) {\n        //     console.error(`bitCounts level is undefined`)\n        //     level = 0;\n        // } else\n        if (typeof level !== 'number') {\n            // console.error(`bitCounts level is not number`)\n            level = Number(level);\n        }\n        let bitCounts = this.levelMap.get(level);\n        if (!bitCounts) {\n            bitCounts = new Map();\n            this.levelMap.set(level, bitCounts);\n        }\n        return bitCounts\n    }\n\n}\n","import { SegmentState } from \"./segment-state\"\nimport {isInteger} from \"../../core/utils/tool-funs\"\n\nconst LIVE_SN_LIMIT = 20;                         // LIVE保存的最多SN数\n\nexport default class BitsetManager {\n\n    constructor(isLive = false, map) {\n        this.isLive = isLive;\n        this.levelMap = new Map();        // level -> map<sn, SegmentState>\n        for (let level in map) {\n            const levelN = Number(level)\n            if (levelN < 0) continue\n            const bitmap = new Map()\n            for (let sn of map[level]) {\n                // 状态都是 COMPLETE\n                bitmap.set(sn, SegmentState.COMPLETE)\n            }\n            this.levelMap.set(levelN, bitmap);\n        }\n    }\n\n    totalLevels() {\n        return this.levelMap.size\n    }\n\n    has(sn, level, state = SegmentState.ANY) {\n        if (level < 0) return false\n        const bitmap = this._createOrGetSet(level);\n        if (state === SegmentState.ANY) {\n            return bitmap.has(sn)\n        }\n        const realState = bitmap.get(sn)\n        return realState === state\n    }\n\n    hasCompleteOr(sn, level, state = SegmentState.COMPLETE) {\n        const bitmap = this._createOrGetSet(level);\n        const realState = bitmap.get(sn)\n        return realState === SegmentState.COMPLETE || realState === state\n    }\n\n    getState(sn, level) {\n        const bitmap = this._createOrGetSet(level);\n        return bitmap.get(sn)\n    }\n\n    /*\n        level -1 删除所有level的sn\n     */\n    delete(sn, level) {\n        const bitmap = this._createOrGetSet(level);\n        if (level === -1) {\n            this.levelMap.forEach((bitmap) => {\n                bitmap.delete(sn)\n            })\n            return true\n        }\n        return bitmap.delete(sn)\n    }\n\n    add(sn, level, state) {\n        if (!isInteger(sn)) return\n        const bitmap = this._createOrGetSet(level);\n        bitmap.set(sn, state);\n        if (this.isLive) {\n            this._trimBitset(sn)\n        }\n    }\n\n    array(level) {\n        const bitmap = this._createOrGetSet(level);\n        return this._keysForStateComplete(bitmap)\n    }\n\n    allArray() {\n        let map = {}\n        this.levelMap.forEach((bitmap, level) => {\n            map[level] = this._keysForStateComplete(bitmap);\n        })\n        return map\n    }\n\n    clear() {\n        this.levelMap.forEach(bitmap => {\n            bitmap.clear()\n        })\n    }\n\n    size(level) {\n        const bitmap = this._createOrGetSet(level);\n        return bitmap.size\n    }\n\n    _createOrGetSet(level) {\n        // if (level === undefined) {\n        //     console.error(`bitset level is undefined`)\n        //     level = 0;\n        // } else\n        if (typeof level !== 'number') {\n            // console.error(`bitset level is not number`)\n            level = Number(level);\n        }\n        let bitmap = this.levelMap.get(level);\n        if (!bitmap) {\n            bitmap = new Map();\n            this.levelMap.set(level, bitmap);\n        }\n        return bitmap\n    }\n\n    _trimBitset(sn) {\n        const oldest = sn - LIVE_SN_LIMIT;\n        if (oldest > 0) {\n            this.levelMap.forEach(bitmap => {\n                bitmap.delete(oldest);\n            })\n            // logger.debug(`datachannel bitset delete ${oldest}`);\n        }\n    }\n\n    _keysForStateComplete(bitmap) {\n        const array = [];\n        for (let [key, value] of bitmap) {\n            if (value === SegmentState.COMPLETE) {\n                array.push(key);\n            }\n        }\n        return array\n    }\n}\n","import EngineBase from \"../../core/engine-base\"\nimport URLToolkit from 'url-toolkit'\nimport {device} from \"../../core/utils/platform\"\nimport defaultP2PConfig from \"../config\"\nimport SegmentStore from \"./segment-store\";\nimport SegmentCache from \"./segment-cache\";\n\nexport default class Engine extends EngineBase {\n\n    constructor(p2pConfig = {}) {\n        super(p2pConfig);\n        window.__swP2pEngineHlsActive = true;\n        this.config = Object.assign({}, defaultP2PConfig, p2pConfig);\n        this.rangeTested = false;                         // 是否已经测试了range请求\n        this.lastLevel = 0;\n        this.multiBitrate = false;\n    }\n\n    setup() {\n        let {token, channelId, segmentId} = this.config;\n        let channelIdMaker = (url) => {\n            const streamParsed = URLToolkit.parseURL(url);\n            const streamId = streamParsed.netLoc.substr(2) + streamParsed.path.substring(0, streamParsed.path.lastIndexOf('.'));\n            return `${streamId}`;\n        };\n        let segmentIdMaker = (streamId, sn, segmentUrl, range) => {\n            // let netUrl = segmentUrl.split('?')[0];\n            // if (netUrl.startsWith('http')) {\n            //     netUrl = netUrl.split('://')[1];\n            // }\n            // if (range) {\n            //     return `${netUrl}|${range}`\n            // }\n            // return `${netUrl}`\n            return `${streamId}-${sn}`\n        };\n        if (channelId && typeof channelId === 'function') {\n            channelIdMaker = this.makeChannelId(token, channelId);\n            // if (!segmentId) {\n            //     segmentIdMaker = (streamId, sn, segmentUrl, range) => {\n            //         return `${sn}`;\n            //     };\n            // }\n        }\n        if (!segmentId) {\n            this.config.segmentId = segmentIdMaker;\n        }\n        const signalId = this.makeSignalId();\n        // 浏览器信息\n        const browserInfo = {\n            ...this.commonBrowserInfo,\n            tag: this.config.tag || undefined,\n        };\n        return {\n            channelIdMaker,\n            signalId,\n            browserInfo\n        }\n    }\n\n    setupElectron() {\n        if (this.browserInfo.device === device.PC_NATIVE) {\n            this.browserInfo = {\n                ...this.browserInfo,\n                app: this.config.appName,\n                bundle: this.config.appId,\n            }\n        }\n    }\n\n    getExtraForStats() {\n        const json = {};\n        if (!this.config.live && this.media) {\n            json.pos = Math.round(this.media.currentTime);\n        }\n        if (this.multiBitrate && this.currentLevel !== this.lastLevel) {\n            json.level = this.currentLevel + \"\";\n            this.lastLevel = this.currentLevel;\n        }\n        return json;\n    }\n\n    getExtraForPeersRequest() {\n        const json = {};\n        if (this.multiBitrate) {\n            json.level = this.currentLevel + \"\";\n        }\n        return json;\n    }\n\n    destroy() {\n        window.__swP2pEngineHlsActive = false;\n        super.destroy();\n    }\n\n    async initSegmentManager() {\n        const { logger, config } = this;\n        //实例化SegmentManager\n        if (window.indexedDB && config.useDiskCache && !config.live) {\n            const store = new SegmentStore(this, config);\n            try {\n                await store.setupStore()\n                this.bufMgr = store;\n            } catch (e) {\n                logger.warn(e);\n                this.bufMgr = new SegmentCache(this, config);\n            }\n        } else {\n            this.bufMgr = new SegmentCache(this, config);\n        }\n    }\n\n}\n","import EventEmitter from 'events'\nimport Events from \"../events\"\n\nexport default class RequestingMap extends EventEmitter{\n\n    constructor() {\n        super();\n        this.internalMap = new Map();                        // 正在p2p下载的SN   level-sn -> destroyer\n    }\n\n    has(sn, level) {\n        return this.internalMap.has(this._generateId(sn, level))\n    }\n\n    set(sn, level, destroyer) {\n        const id = this._generateId(sn, level);\n        this.internalMap.set(id, destroyer);\n        this.emit(`${Events.REQUESTING_MAP_HAVE}${sn}-${level}`, destroyer);\n    }\n\n    get(sn, level) {\n        return this.internalMap.get(this._generateId(sn, level));\n    }\n\n    delete(sn, level) {\n        const id = this._generateId(sn, level);\n        const destroyer = this.internalMap.get(id);\n        if (destroyer) {\n            destroyer.destroy();\n            this.internalMap.delete(id);\n            return true\n        }\n        return false\n    }\n\n    clear() {\n        this.internalMap.clear()\n        this.removeAllListeners();\n    }\n\n    _generateId(sn, level) {\n        // if (level === undefined) {\n        //     console.error(`RequestingMap level is undefined`)\n        //     level = 0;\n        // } else\n        if (typeof level !== 'number') {\n            // console.error(`RequestingMap level is not number`)\n            level = Number(level);\n        }\n        return `${level}-${sn}`\n    }\n}\n","import BitsetManager from \"./bitset-manager\"\nimport BitCountsManager from \"./bitcounts-manager\"\nimport SchedulerBase from \"../../core/scheduler-base\"\nimport { calCheckPeersDelay, getMaxSequence, randomNum } from \"../../core/utils/tool-funs\"\nimport RequestingMap from \"./requesting-map\"\nimport Events from \"../events\"\nimport { tryGetMediaElement } from \"./utils/tool-funs\"\nimport { generateStateId, getBestPairForDownload, SegmentState, findPeersWithState } from \"./segment-state\"\nimport Synthesizer from \"./synthesizer\"\n\nconst MIN_P2P_LOAD_TIME = 2.0;                   // 保留给p2p下载的最小时间\nconst VOD_MAX_PREFETCH_COUNT = 150;               // VOD模式checkPeers遍历的次数\nconst Live_MAX_PREFETCH_COUNT = 10;               // LIVE模式checkPeers遍历的次数\n\nexport default class Scheduler extends SchedulerBase {\n    constructor(engine, config) {\n        super(engine, config);\n\n        this.bitset = new BitsetManager(config.live || false);                  // 本节点的bitfield  sn\n        this.bitCounts = new BitCountsManager();               // 记录peers的每个buffer的总和 index -> count\n        this.requestingMap = new RequestingMap();                        // 正在p2p下载的合成器   level-sn -> Synthesizer\n        this.segmentBuilderMap = new RequestingMap();                // level-sn -> SegmentBuilder\n        this.allowP2pLimit = config.httpLoadTime + MIN_P2P_LOAD_TIME;\n        this.playlistInfo = new Map();           // url -> { seq }\n        this.loadedPeerNum = 0;                                    // 上次下载的peer的数量\n        this.isUploader = false;\n        this.isReceiver = false;\n        this.targetPeers = {}                                  // { forwardPeer, reversePeer }\n        this.mBufferedDuration = 0;                            // 防止重复计算\n        this.sequential = true;\n\n        // 传输控制\n        this.loadingSegId = '';\n        this.loadingSN = 0;\n        this.currPlaySN = 0;\n        this.currLostSN = -1;\n        this.nextLostSN = -1;\n\n        if (!this.config.live) {\n            this.maxPrefetchCount = VOD_MAX_PREFETCH_COUNT;\n            // 点播模式下开启定时器\n            this.startCheckPeersTimer();\n        } else {\n            this.maxPrefetchCount = Live_MAX_PREFETCH_COUNT;\n        }\n    }\n\n    handshakePeer(dc) {\n        this._setupDC(dc);\n        dc.sendMetaData(this.bitset.allArray(), true, this.peersNum)            //向peer发送bitfield\n    }\n\n    _setupDC(dc) {\n        super._setupDC(dc);\n        dc.on(Events.DC_HAVE, msg => {\n            if (dc.bitset && msg.sn >= 0) {\n                // logger.info('DC_HAVE ' + msg.sn);\n                const { sn, level, complete } = msg;\n                if (!this.bitset.has(sn, level)) {              //防止重复下载\n                    this.bitCounts.incre(sn, level);\n                }\n                const state = complete ? SegmentState.COMPLETE : SegmentState.PARTIAL_FORWARD\n                dc.bitset.add(sn, level, state);\n                this.emit(Events.SCH_DCHAVE, msg.seg_id);\n                if (dc.isAvailableUrgently) {\n                    this._handleDCHave(dc, sn, level, state);\n                }\n            }\n        })\n            .on(Events.DC_HAVE_REVERSE, msg => {\n                if (dc.bitset && msg.sn >= 0) {\n                    // logger.info('DC_HAVE ' + msg.sn);\n                    const { sn, level } = msg;\n                    if (!this.bitset.has(sn, level)) {              //防止重复下载\n                        this.bitCounts.incre(sn, level);\n                    }\n                    if (!dc.bitset.hasCompleteOr(sn, level, SegmentState.PARTIAL_REVERSE)) {\n                        dc.bitset.add(sn, level, SegmentState.PARTIAL_REVERSE);\n                    }\n                    this.emit(Events.SCH_DCHAVE, msg.seg_id);\n                    if (dc.isAvailableUrgently) {\n                        this._handleDCHave(dc, sn, level, SegmentState.PARTIAL_REVERSE);\n                    }\n                }\n            })\n            .on(Events.DC_LOST, msg => {\n                if (!dc.bitset) return;\n                const { sn, level } = msg;\n                if (dc.bitset.has(sn, level)) {\n                    dc.bitset.delete(sn, level);\n                    this.bitCounts.decre(sn, level);\n                }\n            })\n            .on(Events.DC_PIECE, msg => {\n                this.notifyAllPeers(msg.sn, msg.level, msg.seg_id, msg.reverse ? SegmentState.PARTIAL_REVERSE : SegmentState.PARTIAL_FORWARD);\n            })\n            .on(Events.DC_PIECE_NOT_FOUND, msg => {\n                const { sn, level } = msg;\n                dc.bitset.delete(sn, level);\n                this.bitCounts.decre(sn, level);\n                dc.checkIfNeedChoke(true);\n            })\n            .on(Events.DC_REQUEST, async msg => {\n                // console.warn(`DC_REQUEST from ${dc.remotePeerId} msg ${JSON.stringify(msg)}`);\n                const { logger } = this;\n                const { sn, level, reverse } = msg;\n                this.isUploader = true;\n\n                let segId = msg.seg_id;\n                if (!segId) {                                    //请求sn的request\n                    segId = await this.bufMgr.getSegIdBySN(sn);\n                }\n                // console.warn(`msg.sn ${sn} requestingMap.has ${this.requestingMap.has(sn)}`);\n                const synthesizer = this.requestingMap.get(sn, level)\n                let listenUpStream = false;\n                if (synthesizer && synthesizer.isDownloading()) {\n                    listenUpStream = (reverse && synthesizer.hasReversePeer()) || (!reverse && synthesizer.hasForwardPeer());\n                }\n                const seg = await this.bufMgr.getSegById(segId);\n                if (seg) {\n                // if (false) {\n                    // seg已经完成下载\n                    logger.info(`found seg from bufMgr`);\n                    // const seg = this.bufMgr.getSegById(segId);\n                    if (seg.level === level) {\n                        dc.sendBuffer(seg.sn, seg.segId, seg.data, {from: 'FromCache', level: seg.level, reverse});\n                    } else {\n                        dc.sendPieceNotFound(sn, segId, { level })\n                    }\n                } else if (listenUpStream) {\n                    // synthesizer已经下载了一部分\n                    logger.info(`synthesizer had ${synthesizer.loadedPackets()} packets, wait remain from upstream ${synthesizer.getFromPeerId()}`);\n                    const target = reverse ? synthesizer.reversePeer : synthesizer.forwardPeer;\n                    dc.sendPartialBuffer(target.pieceMsg, target.bufArr, {from: synthesizer.isFull() ? 'WaitPartialDouble' : 'WaitPartialSingle'});\n                    addStreamListener(synthesizer, dc, reverse);\n                } else {\n                    const builder = this.segmentBuilderMap.get(sn, level);\n                    if (builder) {\n                        logger.info(`peer request ${sn} wait from builder, sent ${builder.bufferList.length}`);\n                        streamFromBuilder(builder, dc);\n                    } else if (this.isHlsjs) {\n                        logger.info(`peer request ${sn} wait from fragLoader`);\n                        this.segmentBuilderMap.once(`${Events.REQUESTING_MAP_HAVE}${sn}-${level}`, (builder) => {\n                            streamFromBuilder(builder, dc);\n                        })\n                    } else if (sn >= this.loadingSN) {\n                        // 找不到target 等待frag下载完再发送 http下载！\n                        logger.info(`peer request ${sn} wait for seg`);\n                        this.bufMgr.once(`${Events.BM_ADDED_SN_}${sn}`, seg => {\n                            if (seg && seg.level === level) {\n                                logger.info(`peer request notify seg ${seg.sn}`);\n                                dc.sendBuffer(seg.sn, seg.segId, seg.data, {from: 'NotifySegment', level: seg.level, reverse});\n                            } else {\n                                dc.sendPieceNotFound(sn, segId, { level })\n                            }\n                        });\n                    } else {\n                        dc.sendPieceNotFound(sn, segId, { level })\n                    }\n\n                }\n                function streamFromBuilder(target, self) {\n                    self.sendPartialBuffer(target.pieceMsg, target.bufferList, {from: 'FromHttpStream'});\n                    if (target.bufferList.length < target.pieceMsg.attachments) {\n                        addStreamListener(target, self, false);\n                    } else {\n                        self.uploading = false;\n                    }\n                }\n                function addStreamListener(target, self, reverse) {\n                    target.addStreamListener(reverse, (sn, segId, aborted, data, finished) => {\n                        if (aborted) {\n                            self.sendMsgPieceAbort(data);\n                        } else {\n                            // console.warn(`notify dc ${dc.remotePeerId} send ${data.byteLength}`);\n                            self.send(data);\n                        }\n                        if (finished) {\n                            // console.warn(`dc_request addStreamListener finished`)\n                            self.uploading = false;\n                        }\n                    })\n                }\n            })\n    }\n\n    handleMetaData(dc, msg) {\n        // console.warn(`bt DC_METADATA`);\n        if (!msg.field) return;\n        dc.bitset = new BitsetManager(this.config.live, msg.field)\n        for (let key in msg.field) {\n            const level = Number(key);\n            if (level < 0) continue\n            const array = msg.field[level];\n            array.forEach(value => {\n                if (!this.bitset.has(value, level)) {              //防止重复下载\n                    this.bitCounts.incre(value, level)\n                }\n            });\n        }\n        this.addPeer(dc);                               //只有获取bitfield之后才加入peerMap\n        if (this.downloadOnly) {\n            // console.warn(\"choke peer\");\n            this.chokePeerRequest(dc);                  // 不分享\n        }\n    }\n\n    peersHas(sn, level) {\n        // console.warn(`bitCounts.has ${sn} ${this.bitCounts.has(sn, level)}`)\n        return this.bitCounts.has(sn, level);\n    }\n\n    // override\n    deletePeer(dc) {\n        if (this.peerManager.hasPeer(dc.remotePeerId)) {\n            const field = dc.bitset.allArray();\n            for (let key in field) {\n                const level = Number(key);\n                const array = field[level];\n                if (array) {\n                    array.forEach(value => {\n                        this.bitCounts.decre(value, level)\n                    });\n                }\n            }\n        }\n        this.cleanRequestingMap(dc.remotePeerId);\n        super.deletePeer(dc);\n    }\n\n    hasAndSetTargetPeer(sn, level, bufferedDuration) {\n        const { logger, config } = this;\n        const remainLoadTime = (bufferedDuration - config.httpLoadTime)*1000;\n        // 如果buffer time小于allowP2pLimit，则用http请求\n        if (bufferedDuration <= this.allowP2pLimit) {\n            const synthesizer = this.requestingMap.get(sn, level);\n            if (synthesizer && synthesizer.shouldWaitForRemainUrgent(remainLoadTime)) {\n                // 如果已经在下载并且预估可以完成   TODO 验证\n                logger.info(`prefetch ${sn} wait for remain urgently`);\n                return true\n            }\n            return false;\n        }\n        // 如果正在请求此sn\n        if (this.requestingMap.has(sn, level)) {\n            const synthesizer = this.requestingMap.get(sn, level);\n            if (!synthesizer) return this._searchAvailablePeers(sn, level);\n            if (!synthesizer.shouldWaitForRemain(remainLoadTime)) {\n                logger.warn(`syn prefetch timeout at ${sn}`);\n                if (synthesizer.isFull()) {\n                    logger.warn(`syn is full`);\n                    return false\n                }\n                const peers = this.peerManager.getPeersOrderByWeight();\n                const completeGroup = findPeersWithState(peers, SegmentState.COMPLETE, sn, level)\n                if (synthesizer.hasReversePeer()) {\n                    const forwardGroup = completeGroup.concat(findPeersWithState(peers, SegmentState.PARTIAL_FORWARD, sn, level));\n                    if (forwardGroup.length > 0) {\n                        this.targetPeers.forwardPeer = forwardGroup[0];\n                        return true\n                    }\n                } else {\n                    const reverseGroup = completeGroup.concat(findPeersWithState(peers, SegmentState.PARTIAL_REVERSE, sn, level));\n                    if (reverseGroup.length > 0) {\n                        this.targetPeers.reversePeer = reverseGroup[0];\n                        return true\n                    }\n                }\n                return config.httpRangeSupported && (bufferedDuration > this.allowP2pLimit + 2.0)       // 如果支持range则继续等待\n            }\n            logger.info(`prefetch ${sn} wait for remain`);\n            return true\n        }\n        return this._searchAvailablePeers(sn, level);\n    }\n\n    _searchAvailablePeers(sn, level) {\n        // console.warn(`this.peersHas ${sn} ${this.peersHas(sn, level)}`)\n        if (!(this.hasIdlePeers && this.peersHas(sn, level))) {\n            return false;\n        }\n        const peers = this.peerManager.getPeersOrderByWeight();\n        // this.logger.info(`searchAvailablePeers ${peers.length}`);\n        const [forwardPeer, reversePeer] = getBestPairForDownload(peers, sn, level);\n        // console.warn([forwardPeer, reversePeer])\n        this.targetPeers = {\n            forwardPeer,\n            reversePeer,\n        }\n        return [forwardPeer, reversePeer].some(peer => !!peer)\n    }\n\n    reportTraffic(http, p2p, speed) {\n        const { fetcher } = this.engine;\n        if (!fetcher) {\n            this.logger.error(\"DC report failed\");\n            return;\n        }\n        if (http > 0) fetcher.reportFlow(http);\n        if (p2p > 0) fetcher.reportDCTraffic(p2p, speed);\n    }\n\n    notifyAllPeers(sn, level, segId, state = SegmentState.COMPLETE) {\n        // console.warn(`notifyAllPeers`);\n        const { live } = this.config;\n        if (this.bitset.has(sn, level, state)) return;                      // 防止重复广播\n        const notifyId = generateStateId(sn, level, state);\n        let complete;\n        if (state !== SegmentState.PARTIAL_REVERSE) {\n            complete = state === SegmentState.COMPLETE;\n        }\n        const synthesizer = this.requestingMap.get(sn, level);\n        for (let peer of this.peerManager.getPeerValues()) {\n            if (synthesizer && synthesizer.hasPeer(peer)) {\n                continue\n            }\n            if (!peer.notifySet.has(notifyId) && !peer.bitset.hasCompleteOr(sn, level, state)) {              // 对方没有并且没有notify过时才发送\n                peer.sendMsgHave(sn, segId, { level, reverse: state === SegmentState.PARTIAL_REVERSE, complete });\n                peer.notifySet.add(notifyId);\n                if (live) {\n                    const LIMIT = 20;\n                    while (peer.notifySet.size > LIMIT) {\n                        const id = [...peer.notifySet.values()].shift();\n                        peer.notifySet.delete(id);\n                        // this.logger.debug(`datachannel notifySet delete ${segId}`);\n                    }\n                }\n            }\n        }\n    }\n\n    startCheckPeersTimer(checkDelay = 1) {\n        this.logger.info(`loaded peers ${this.loadedPeerNum} next checkDelay ${checkDelay}`);\n        this.loadedPeerNum = 0;                             // 重置\n        if (this.checkTimer) return;\n        this.checkTimer = setTimeout(() => {\n            this.checkPeers();\n            this.checkTimer = null;\n            this.startCheckPeersTimer(calCheckPeersDelay(this.loadedPeerNum));\n        }, checkDelay * 1000)\n    }\n\n    checkPeers() {\n        // return;\n        // const size = this.requestingMap.internalMap.size;\n        // if (size >= 5) {\n        //     this.logger.error(`requestingMap size ${this.requestingMap.internalMap.size}`)\n        // }\n\n        if (!this.hasPeers) {\n            return;\n        }\n        const { logger, config, engine } = this;\n        const isLive = config.live;\n        const { currentLevel } = engine;\n        logger.info(`currentLevel ${currentLevel}`);\n        if (this.bitCounts.size(currentLevel) === 0) {\n            return;\n        }           // 已经下载完了\n        // console.warn(`this.nextLostSN ${this.nextLostSN} this.currPlaySN ${this.currPlaySN}`)\n        if (!isLive && this.nextLostSN >= 0 && this.nextLostSN >= this.currPlaySN - 10) {\n            return;\n        }\n        if (this.mBufferedDuration < this.allowP2pLimit) {\n            logger.info(`low buffer time, skip prefetch`);\n            return;\n        }\n        const availablePeers = this.peerManager.getPeersOrderByWeight();\n\n        if (availablePeers.length === 0) return;\n        const requestedPeers = [];\n        let { prefetchNum, endSN, startSN } = config;\n        if (isLive) prefetchNum = 1;\n        let prefetchCount = 0;\n        // let offset = isLive ? this.loadingSN + 1 : this.loadingSN + 2;\n        let offset =  this.loadingSN + 1;\n        if (!isLive) {\n            // 排除endSN比offset小的peer，然后获取所有peer最小的startSN\n            // console.warn(availablePeers.map(peer => peer.startSN));\n            if (this.loadingSN >= endSN && !this.bufMgr.overflowed) {\n                // 点播如果缓存没满，继续请求没有下载的sn\n                offset = startSN;\n            } else {\n                const minStartSN = Math.min(...availablePeers\n                    .filter(peer => peer.endSN >= offset)\n                    .map(peer => peer ? peer.startSN : Infinity));\n                // console.warn(`minStartSN ${minStartSN}`);\n                if (!isFinite(minStartSN)) return;                   // 没有可以请求的SN\n                // console.warn(`after minStartSN ${minStartSN}`);\n                // if (this.currLostSN >= 0 && offset < minStartSN-30) return;\n                if (offset < minStartSN) {\n                    offset = minStartSN;\n                }\n            }\n\n            // console.warn(`offset ${offset}`)\n        }\n        // console.warn(`overflowed ${this.bufMgr.overflowed} loadingSN ${this.loadingSN} endSN ${endSN} bitCounts ${this.bitCounts.size}`)\n        while (requestedPeers.length < prefetchNum && requestedPeers.length < availablePeers.length && prefetchCount < this.maxPrefetchCount) {\n            if (!isLive && offset > endSN) {\n                return;\n            } else if (isLive && offset > this.loadingSN + 1) {\n                return;\n            }\n            if (this.bitset.has(offset, currentLevel)) {\n                offset ++;\n                continue;\n            }\n            // console.warn(`this.maxPrefetchCount ${this.maxPrefetchCount}`);\n            if (offset !== this.loadingSN && this.bitCounts.has(offset, currentLevel) && !this.requestingMap.has(offset, currentLevel)) {                  //如果这个块没有缓存并且peers有并且没有在请求\n                for (let peer of availablePeers) {                           //找到拥有这个块并且空闲的peer\n                    if (!requestedPeers.includes(peer) && peer.bitset.has(offset, currentLevel)) {\n                        const state = peer.bitset.getState(offset, currentLevel);\n                        let reverse;\n                        if (state === SegmentState.COMPLETE) {\n                            reverse = randomNum(0, 1) === 0\n                        } else {\n                            reverse = state === SegmentState.PARTIAL_REVERSE\n                        }\n                        requestedPeers.push(peer);\n                        const synthesizer = new Synthesizer(this.logger, offset, currentLevel, config.httpRangeSupported);\n                        this._setupSynthesizer(synthesizer);\n                        if (reverse) {\n                            synthesizer.setReversePeer(peer);\n                        } else {\n                            synthesizer.setForwardPeer(peer);\n                        }\n                        this.requestingMap.set(offset, currentLevel, synthesizer);        // 标记正在请求\n                        peer.requestDataBySN(offset, false, { level: currentLevel, reverse });\n                        logger.info(`request prefetch ${offset} level ${currentLevel} from peer ${peer.remotePeerId} downloadNum ${peer.downloadNum} reverse ${reverse}`);\n                        break;\n                    }\n                }\n            }\n            // logger.info(`prefetchCount ${prefetchCount} offset ${offset} requestedPeers ${requestedPeers.length}`);\n            prefetchCount ++;             // 遍历的segment数量\n            offset ++;\n        }\n        this.loadedPeerNum = requestedPeers.length;\n    }\n\n    // override\n    onBufferManagerLost(sn, segId, next, level) {\n        // this.logger.debug(`onBufferManagerLost`);\n        this.currLostSN = sn;\n        if (next) this.nextLostSN = next;\n        // 删除内存对应的SN\n        this.bitset.delete(sn, level);\n        this.bitCounts.delete(sn, level);\n    }\n\n    cleanRequestingMap(peerIdToDelete) {\n        const peer = this.peerManager.getPeer(peerIdToDelete);\n        if (!peer) return\n        for (let [id, synthesizer] of this.requestingMap.internalMap) {\n            const arr = id.split('-');\n            const sn = Number(arr[1]);\n            const level = Number(arr[0]);\n            if (synthesizer.hasPeerId(peerIdToDelete)) {\n                this.logger.info(`delete ${id} in requestingMap`);\n                synthesizer.deletePeer(peer)\n                this.bitCounts.decre(sn, level);\n                peer.bitset.delete(sn, level);\n            }\n        }\n    }\n\n    shouldWaitForNextSeg() {\n        let flag;\n        if (this.isUploader) {\n            flag = false;\n        } else {\n            if (this.isReceiver) {\n                flag = true;\n            } else {\n                // 都不是的话80%概率等\n                flag = randomNum(0, 100) > 20;\n            }\n        }\n        this.isReceiver = this.isUploader = false;\n        return flag;\n    }\n\n    updateLoaded(sn, level) {\n        if (this.bitset.hasCompleteOr(sn, level)) return;\n        this.bitset.add(sn, level, SegmentState.COMPLETE);                      //在bitset中记录\n\n        this.bitCounts.delete(sn, level)             //在bitCounts清除，防止重复下载\n        // const { logger } = this;\n        // logger.debug(\"updateLoadedSN \" + sn);\n\n    }\n\n    // 广播playlist\n    broadcastPlaylist(url, data) {\n        if (!this.config.live) return;\n        // console.warn(`url ${url} loadedByPeer ${loadedByPeer}`);\n        const seq = getMaxSequence(data);\n        for (let peer of this.peerManager.getPeerValues()) {\n            peer.sendMsgPlaylist(url, data, seq);\n        }\n        // console.warn(`broadcastPlaylist seq ${seq}`)\n        this.playlistInfo.set(url, {\n            seq,\n        });\n    }\n\n    getPlaylistFromPeer(url) {\n        if (!this.config.live) return null;\n        const { seq } = this.playlistInfo.get(url);\n        for (let peer of this.peerManager.getPeerValues()) {\n            const playlist = peer.getLatestPlaylist(url, seq);\n            if (playlist) {\n                // console.warn(`getPlaylistFromPeer url ${url} last ${seq} curr ${playlist.seq}`);\n                return playlist\n            }\n        }\n        return null;\n    }\n\n    // 可供p2p下载的时间\n    getBufferedDuration() {\n        let { media } = this.engine;\n        if (!media) {\n            this.logger.info(`try get video element`);\n            media = tryGetMediaElement(this.config.mediaElem);\n            if (!media) {\n                return 5.0;\n            }\n            this.engine.media = media;\n        }\n        let duration = 0;\n        let currentTime = media.currentTime;\n        let buffered = media.buffered;\n        for (let i=buffered.length-1; i>=0; i--) {\n            // console.warn(`${i} start ${buffered.start(i)} end ${buffered.end(i)}`);\n            if (currentTime >= buffered.start(i) && currentTime <= buffered.end(i)) {\n                duration = buffered.end(i) - currentTime;\n                break;\n            }\n        }\n        this.logger.info(`bufferedDuration ${duration}`);\n        this.mBufferedDuration = duration;\n        return duration > 0 ? duration : 0;\n    }\n\n    destroy() {\n        super.destroy();\n        clearTimeout(this.checkTimer);\n        this.requestingMap.clear();\n        this.segmentBuilderMap.clear();\n    }\n\n    _notifySynthesizer(peer, segId, sn, level, state, urgent = true) {\n        const synthesizer = this.requestingMap.get(sn, level);\n        if (!synthesizer) return\n        if (!synthesizer.hasForwardPeer() && (state === SegmentState.PARTIAL_FORWARD || state === SegmentState.COMPLETE)) {\n            synthesizer.setForwardPeer(peer);\n            request(false, urgent);\n        }\n        if (!synthesizer.hasReversePeer() && (state === SegmentState.PARTIAL_REVERSE || state === SegmentState.COMPLETE)) {\n            synthesizer.setReversePeer(peer);\n            request(true, urgent);\n        }\n        function request(reverse, urgent) {\n            if (urgent) {\n                peer.requestDataById(segId, sn, true, { level, reverse });\n            } else {\n                peer.requestDataBySN(sn, false, { level , reverse });\n            }\n        }\n    }\n\n    // override\n    _setupEngine() {}\n\n    // override\n    getStatsForPeer() {\n        const { currentLevel } = this.engine;\n        const { currentTime } = this.engine.media;\n        return {\n            level: currentLevel,\n            pos: !this.config.live ? Math.round(currentTime) : undefined,\n        }\n    }\n\n}\n","import EventEmitter from 'events'\nimport Events from '../../core/events'\nimport platform from '../../core/utils/platform'\n\nconst LIVE_MAX_BUFFER_SIZE = 1024*1024*35;          // 直播模式的最大缓存大小\n// const LIVE_MAX_BUFFER_SIZE = 1024*1024*15;        // 直播模式的最大缓存大小       test\n\nconst MIN_SEGMENTS_KEEP = 5;                    // 最少保留多少个segment\n\nclass SegmentCache extends EventEmitter {\n    constructor(engine, config) {\n        super();\n\n        this.logger = config.logger;\n        this.logger.info(`use SegmentCache`)\n        const device = engine.browserInfo.device;\n        this.maxBufSize = device === platform.device.PC_WEB || device === platform.device.PC_NATIVE ?\n            config.memoryCacheLimit.pc\n            : config.memoryCacheLimit.mobile;\n        if (config.live) this.maxBufSize = LIVE_MAX_BUFFER_SIZE;\n        /* segment\n        sn: number\n        segId: string\n        data: Buffer\n        size: string\n        fromPeerId: string\n         */\n        this._segPool = new Map();             //存放seg的Map            segId (sn) -> [segment]\n        this._currBufSize = 0;                 //目前的buffer总大小\n        this.id2Sn = new Map();                //以segId查找sn             segId -> sn\n        this.overflowed = false;               //缓存是否已满\n    }\n\n    get currBufSize() {\n        return this._currBufSize;\n    }\n\n    hasSegOfId(segId) {\n        return new Promise((resolve, reject) => {\n            const sn = this.id2Sn.get(segId);\n            if (!this._segPool.has(sn)) {\n                resolve(false)\n                return\n            }\n            resolve(this._segPool.get(sn).some(seg => seg.segId === segId))\n        })\n    }\n\n    getSegById(segId) {\n        const sn = this.id2Sn.get(segId);\n        return new Promise((resolve, reject) => {\n            if (!this._segPool.has(sn)) {\n                resolve(null)\n                return\n            }\n            const segs = this._segPool.get(sn);\n            for (let seg of segs) {\n                if (seg.segId === segId) {\n                    resolve(seg)\n                    break\n                }\n            }\n            resolve(null)\n        })\n\n    }\n\n    getSegIdBySN(sn) {\n        return new Promise((resolve, reject) => {\n            if (this._segPool.has(sn)) {\n                const segs = this._segPool.get(sn)\n                resolve(segs[0].segId)                 // 返回数组第一个segId\n            }\n            resolve(null)\n        })\n\n    }\n\n    _calSegPoolSize() {\n        let totalSize = 0;\n        this._segPool.forEach(segs => {\n            segs.forEach(seg => {\n                totalSize += seg.size;\n            })\n        });\n        return totalSize;\n    }\n\n    putSeg(segment) {\n        if (this._currBufSize >= this.maxBufSize*1.5) {\n            this._currBufSize = this._calSegPoolSize();\n            if (this._currBufSize >= this.maxBufSize*1.5) {\n                this.clear();\n                this.overflowed = false;\n            }\n        }\n\n        // if (this._segPool.has(segment.sn)) return;\n        this._addSeg(segment);\n    }\n\n    _addSeg(seg) {\n        const { logger } = this;\n        const { segId, sn, size } = seg;\n        this.id2Sn.set(segId, sn);\n        if (!this._segPool.has(sn)) {\n            this._segPool.set(sn, [seg])\n        } else {\n            const segs = this._segPool.get(sn)\n            segs.push(seg)\n        }\n        this._currBufSize += parseInt(size);\n\n        const poolSize = this._segPool.size;\n        // logger.info(`segment pool add seg ${sn} size ${size} currBufSize ${this._currBufSize} cacheLimit ${this.maxBufSize} poolSize ${poolSize}`);\n\n        this.emit(`${Events.BM_ADDED_SN_}${seg.sn}`, seg);\n        this.emit(Events.BM_SEG_ADDED, seg);\n\n        if (this._currBufSize < this.maxBufSize || poolSize <= MIN_SEGMENTS_KEEP) return;\n\n        // console.warn(Array.from(this._segPool.keys()).sort((a, b) => a-b));\n        const sorted = Array.from(this._segPool.keys()).sort((a, b) => a-b);  // 从小到大排序\n        let count = 0;\n        do {\n            if (count++ > 10) {\n                console.error('too much loops in SegmentCache');\n                break\n            }\n            // 释放溢出的buffer\n            const oldestSN = sorted.shift();\n            if (oldestSN === undefined) {\n                logger.error(`lastSN not found`);\n                continue;\n            }\n            const nextSN = sorted[0];\n            const oldestSegs = this._segPool.get(oldestSN);\n            if (!oldestSegs) {\n                logger.error(`lastSeg not found`);\n                continue;\n            }\n            let size = 0;\n            oldestSegs.forEach(oldestSeg => {\n                size += oldestSeg.size;\n            })\n            this._currBufSize -= parseInt(size);\n            this._segPool.delete(oldestSN);\n            oldestSegs.forEach(oldestSeg => {\n                this.id2Sn.delete(oldestSeg.segId);\n                logger.info(`pop seg ${oldestSeg.segId} size ${oldestSeg.size}`);\n                this.emit(Events.BM_LOST, {sn: oldestSN, segId: oldestSeg.segId, next: nextSN, level: oldestSeg.level});\n            })\n            logger.info(`pop sn ${oldestSN} size ${size} currBufSize ${this._currBufSize}`);\n            if (!this.overflowed) this.overflowed = true;\n            // this.emit(Events.BM_LOST, oldestSN, oldestSeg.segId, nextSN);\n\n        } while (this._currBufSize >= this.maxBufSize && this._segPool.size > MIN_SEGMENTS_KEEP)\n    }\n\n    clear() {\n        this.logger.warn(`clear segment cache`);\n        this._segPool.clear();\n        this.id2Sn.clear();\n        this._currBufSize = 0;\n    }\n\n    destroy() {\n        this.clear();\n        this.removeAllListeners();\n    }\n}\n\nexport default SegmentCache;\n","import { randomNum } from '../../core/utils/tool-funs'\n\nconst SegmentState = {\n    ANY: 0,\n    COMPLETE: 1,\n    PARTIAL_FORWARD: 2,\n    PARTIAL_REVERSE: 3,\n}\n\nconst generateStateId = (sn, level, state) => {\n    return `${sn}-${level}-${state}`\n}\n\n/*\n    1. 优先寻找完整下载的peer，如果有2个直接返回\n    2. 如果只有一个完整的，寻找是否有正向或者反向的，配对后返回；没有的话这个完整的给正向后返回\n    3. 如果没有一个完整的，分别寻找正向和反向，配对后返回\n */\nconst getBestPairForDownload = (peers, sn, level) => {\n    const completeGroup = findPeersWithState(peers, SegmentState.COMPLETE, sn, level);\n    if (completeGroup.length >= 2) {\n        return [completeGroup[0], completeGroup[1]]\n    }\n    if (completeGroup.length === 1) {\n        const forwardGroup = findPeersWithState(peers, SegmentState.PARTIAL_FORWARD, sn, level);\n        if (forwardGroup.length >= 1) {\n            return [forwardGroup[0], completeGroup[0]]\n        }\n        const reverseGroup = findPeersWithState(peers, SegmentState.PARTIAL_REVERSE, sn, level);\n        if (reverseGroup.length >= 1) {\n            return [completeGroup[0], reverseGroup[0]]\n        }\n        return randomNum(0, 1) === 0 ? [null, completeGroup[0]] : [completeGroup[0], null]\n        // test\n        // return 1 === 0 ? [null, completeGroup[0]] : [completeGroup[0], null]\n    }\n    const forwardGroup = findPeersWithState(peers, SegmentState.PARTIAL_FORWARD, sn, level);\n    if (forwardGroup.length >= 1) {\n        return [forwardGroup[0], null]\n    }\n    const reverseGroup = findPeersWithState(peers, SegmentState.PARTIAL_REVERSE, sn, level);\n    if (reverseGroup.length >= 1) {\n        return [null, reverseGroup[0]]\n    }\n    return [null, null]\n}\n\nconst findPeersWithState = (peers, state, sn, level) => {\n    return peers.filter(peer => peer.bitset.has(sn, level, state))\n}\n\nexport {\n    SegmentState,\n    generateStateId,\n    getBestPairForDownload,\n    findPeersWithState\n}\n","import EventEmitter from 'events'\nimport Events from '../../core/events'\nimport platform from '../../core/utils/platform'\nimport * as diskCache from '../../common/idb-keyval/index'\nimport Segment from \"../../core/segment\";\n\nconst KEY_METADATA_SIZE = 'size';\n\nclass SegmentStore extends EventEmitter {\n    constructor(engine, config) {\n        super();\n\n        this.logger = config.logger;\n        this.logger.info(`use SegmentStore`)\n        this.channel = engine.channel;\n        const device = engine.browserInfo.device;\n        // 磁盘存储限制\n        this.maxBufSize = device === platform.device.PC_WEB || device === platform.device.PC_NATIVE ?\n            config.diskCacheLimit.pc : config.diskCacheLimit.mobile;\n        /* segment\n        sn: number\n        segId: string\n        data: Buffer\n        size: string\n        fromPeerId: string\n         */\n        // this.id2Sn = new Map();                //以segId查找sn             segId -> sn\n        this.overflowed = false;               //缓存是否已满\n    }\n\n    async setupStore() {\n        if (navigator.storage) {\n            const estimate = await navigator.storage.estimate(),\n                // calculate remaining storage in MB\n                available = Math.floor((estimate.quota - estimate.usage));\n            if (available < this.maxBufSize) {\n                this.maxBufSize = available  - 10*1024*1024;\n            }\n            // console.warn(`${ available } Byte remaining this.maxBufSize ${this.maxBufSize}`);\n        }\n        return new Promise((resolve, reject) => {\n            if (this.maxBufSize < 300*1024*1024) {\n                reject(`disk storage not enough`)\n                return\n            }\n            const storeFuns = diskCache.createStore(this.channel)\n            this.segmentsStore = storeFuns[0];\n            this.id2SnStore = storeFuns[1];\n            this.metaStore = storeFuns[2];\n            const timer = setTimeout(() => {\n                reject('setupStore timeout')\n            }, 250);\n            this._clearDisk(this.channel).then(() =>  {\n                this._initMetaStore().then(() => {\n                    clearTimeout(timer);\n                    resolve()\n                }).catch(e => {\n                    reject(e)\n                });\n            }).catch(e => {\n                reject(e)\n            })\n        })\n    }\n\n    _initMetaStore() {\n        return new Promise((resolve, reject) => {\n            diskCache.get(KEY_METADATA_SIZE, this.metaStore).then(size => {\n                if (!size) {\n                    this.logger.info('init MetaStore size');\n                    diskCache.set(KEY_METADATA_SIZE, 0, this.metaStore);\n                }\n                resolve()\n            }).catch(e => {\n                reject()\n            })\n        })\n\n    }\n\n    currBufSize() {\n        return diskCache.get(KEY_METADATA_SIZE, this.metaStore);\n    }\n\n    async hasSegOfId(segId) {\n        const sn = await diskCache.get(segId, this.id2SnStore);\n        return new Promise((resolve, reject) => {\n            if (!sn) {\n                resolve(false);\n                return\n            }\n            diskCache.get(sn, this.segmentsStore).then((segs) => {\n                // console.warn(segs)\n                if (segs && segs.length > 0 && segs.some(seg => seg.segId === segId)) {\n                    // console.warn(`resolve(true)`)\n                    resolve(true)\n                } else {\n                    // console.warn(`resolve(false)`)\n                    resolve(false)\n                }\n            }).catch((e) => {\n                this.logger.error(e)\n                resolve(false)\n            })\n        })\n    }\n\n    async getSegById(segId) {\n        if (!segId) return null;\n        const sn = await diskCache.get(segId, this.id2SnStore);\n        return new Promise((resolve, reject) => {\n            if (!sn) {\n                resolve(null);\n                return\n            }\n            diskCache.get(sn, this.segmentsStore).then((segs) => {\n                if (segs && segs.length > 0) {\n                    resolve(Segment.fromSegment(segs[0]))\n                } else {\n                    resolve(null)\n                }\n            }).catch((e) => {\n                this.logger.error(e)\n                resolve(null)\n            })\n        })\n    }\n\n    getSegIdBySN(sn) {\n        return new Promise((resolve, reject) => {\n            diskCache.get(sn, this.segmentsStore).then((segs) => {\n                if (segs && segs.length > 0) {\n                    resolve(segs[0].segId)\n                } else {\n                    resolve(null)\n                }\n            }).catch((e) => {\n                this.logger.error(e)\n                resolve(null)\n            })\n        })\n    }\n\n    putSeg(segment) {\n        // if (this._segPool.has(segment.sn)) return;\n        this._addSeg(segment);\n    }\n\n    _addSeg(seg) {\n        const { logger } = this;\n        const { segId, sn, size } = seg;\n        diskCache.set(segId, sn, this.id2SnStore);\n\n        diskCache.get(sn, this.segmentsStore).then((segs) => {\n            if (segs) {\n                if (segs.filter(seg => seg.segId === segId).length === 0) {\n                    segs.push(this._segmentToCache(seg))\n                    diskCache.set(sn, segs, this.segmentsStore).then(() => {\n                        this._increaseBufSize(seg.data.byteLength);\n                    }).catch((e) => {\n                        this.logger.error(e)\n                    })\n                }\n            } else {\n                diskCache.set(sn, [this._segmentToCache(seg)], this.segmentsStore).then(() => {\n                    this._increaseBufSize(seg.data.byteLength);\n                }).catch((e) => {\n                    this.logger.error(e)\n                })\n            }\n        }).catch((e) => {\n            this.logger.error(e)\n        })\n\n        this.emit(`${Events.BM_ADDED_SN_}${seg.sn}`, seg);\n        this.emit(Events.BM_SEG_ADDED, seg);\n    }\n\n    async _trimDisk() {\n        const { logger } = this;\n        let currentSize = await this.currBufSize()\n        // console.warn(`_trimDisk currentSize ${currentSize}`)\n        if (currentSize < this.maxBufSize) return\n        diskCache.keys(this.segmentsStore).then(async (keys) => {\n            const sorted = keys.sort((a, b) => a-b);  // 从小到大排序\n            let count = 0;\n            do {\n                if (count++ > 10) {\n                    console.error('too much loops in SegmentStore');\n                    break\n                }\n                // 释放溢出的buffer\n                const oldestSN = sorted.shift();\n                if (oldestSN === undefined) {\n                    logger.error(`lastSN not found`);\n                    continue;\n                }\n                const nextSN = sorted[0];\n                const oldestSegs = await diskCache.get(oldestSN, this.segmentsStore);\n                if (!oldestSegs) {\n                    logger.error(`lastSeg not found`);\n                    continue;\n                }\n                let size = 0;\n                oldestSegs.forEach(oldestSeg => {\n                    size += oldestSeg.data.byteLength;\n                })\n                diskCache.del(oldestSN, this.segmentsStore).then(() => {\n                    this._decreaseBufSize(parseInt(size));\n                });\n                oldestSegs.forEach(oldestSeg => {\n                    diskCache.del(oldestSeg.segId, this.id2SnStore);\n                    logger.info(`pop seg ${oldestSeg.segId} size ${oldestSeg.data.byteLength}`);\n                    this.emit(Events.BM_LOST, {sn: oldestSN, segId: oldestSeg.segId, next: nextSN, level: oldestSeg.level});\n                })\n                currentSize = await this.currBufSize();\n                logger.info(`pop sn ${oldestSN} size ${size} currBufSize ${currentSize}`);\n                if (!this.overflowed) this.overflowed = true;\n            } while (currentSize >= this.maxBufSize)\n        })\n    }\n\n    _decreaseBufSize(byteLength) {\n        diskCache.get(KEY_METADATA_SIZE, this.metaStore).then(size => {\n            if (size) {\n                diskCache.set(KEY_METADATA_SIZE, size - byteLength, this.metaStore);\n            }\n        }).catch(e => {\n            this.logger.error(e);\n        })\n    }\n\n    _increaseBufSize(byteLength) {\n        diskCache.get(KEY_METADATA_SIZE, this.metaStore).then(size => {\n            diskCache.set(KEY_METADATA_SIZE, size + byteLength, this.metaStore);\n            this._trimDisk();\n        }).catch(e => {\n            this.logger.error(e);\n        })\n    }\n\n    _segmentToCache(seg) {\n        return {\n            data: seg.data,\n            level: seg.level,\n            segId: seg.segId,\n            sn: seg.sn,\n        }\n    }\n\n    clear() {\n        this.logger.warn(`clear segment cache`);\n        // this.id2Sn.clear();\n        this._clearDisk();\n    }\n\n    // 清空disk\n    _clearDisk(excluded) {\n        // console.warn(`_clearDisk`)\n        return diskCache.clearAll(excluded)\n    }\n\n    destroy() {\n        this.clear();\n        this.removeAllListeners();\n    }\n}\n\nexport default SegmentStore;\n","import EventEmitter from 'events'\nimport Events from '../events'\nimport { Buffer } from '../../core/utils/buffer'\nimport Segment from '../../core/segment'\nimport { performRangeRequest, splitBytes } from '../../core/utils/tool-funs'\nimport { calRangeWithForwardReverseOffset } from './utils/tool-funs'\n\nexport default class Synthesizer extends EventEmitter {\n    constructor(logger, sn, level, rangeSupported = false, ext) {\n        super();\n        this.logger = logger;\n        this.rangeSupported = rangeSupported;\n        this.rangeStart = 0;\n        this.rangeEnd = 0;\n        this.httpLoadTime = 1500;              // ms\n        this.allowLoadPartial = false;\n        if (ext) this.setExtra(ext);\n        this.forwardPeer = null;          // 负责正向下载\n        this.reversePeer = null;          // 负责反向下载\n        this.bufArr = [];\n        this.pieceMsg = { sn, level }      // attachments, seg_id, sn, level, size, reverse\n        this.forwardOffset = -1;    // 指向当前正向已填充的idx\n        this.reverseOffset = 10000;    // 指向当前反向已填充的idx\n        this.timeStart = 0;   // 开始的时刻 毫秒\n        this.timeReceivePiece = 0;        // 接收到piece的时刻 毫秒    用于shouldWaitForRemain\n        this.timer = undefined;\n        this.destroyed = false;\n        this.forwardStreamListeners = [];\n        this.reverseStreamListeners = [];\n        this.rangeRequesting = false;\n        this.httpLoaded = 0;\n        this.p2pLoaded = 0;\n    }\n\n    isDownloading() {\n        return this.timeReceivePiece > 0\n    }\n\n    hasPeer(target) {\n        if (!target) return false\n        return target === this.forwardPeer || target === this.reversePeer\n    }\n\n    _notifyStreamListeners(reverse, data, idx) {\n        const { sn, seg_id, attachments } = this.pieceMsg;\n        const finished = (reverse && idx === 0) || (!reverse && idx === attachments-1)\n        // console.warn(`_notifyStreamListeners sn ${sn} length ${data.byteLength} finished ${finished}`);\n        const listeners = reverse ? this.reverseStreamListeners : this.forwardStreamListeners;\n        for (let item of listeners) {\n            const { handler } = item;\n            handler(sn, seg_id, false, data, finished);\n        }\n        if (finished) {\n            // console.warn(`_notifyStreamListeners finished`)\n            listeners.length = 0;\n        }\n    }\n\n    _notifyStreamListenersAbort() {\n        const { sn, seg_id } = this.pieceMsg;\n        const listeners = [...this.reverseStreamListeners, ...this.forwardStreamListeners];\n        for (let item of listeners) {\n            const { handler } = item;\n            handler(sn, seg_id, true, 'aborted by synthesizer');\n        }\n        listeners.length = 0;\n    }\n\n    _notifyStreamListenersRemain() {\n        // forward\n        if (this.forwardStreamListeners.length > 0) {\n            for (let i=this.forwardOffset+1; i<this.bufArr.length; i++) {\n                this._notifyStreamListeners(false, this.bufArr[i], i)\n                // console.warn(`notifyStreamListeners sn ${i} length ${this.bufArr[i].byteLength} finished ${i===this.bufArr.length-1}`);\n            }\n            this.forwardStreamListeners = [];\n        }\n        // reverse\n        if (this.reverseStreamListeners.length > 0) {\n            for (let i=this.reverseOffset-1; i>=0; i--) {\n                this._notifyStreamListeners(true, this.bufArr[i], i)\n                // console.warn(`notifyStreamListeners sn ${i} length ${this.bufArr[i].byteLength} finished ${i===0}`);\n            }\n            this.reverseStreamListeners = [];\n        }\n    }\n\n    addStreamListener(reverse, handler) {\n        const listeners = reverse ? this.reverseStreamListeners : this.forwardStreamListeners;\n        listeners.push({ handler });\n    }\n\n    setTimeout(timeout = 0) {\n        if (timeout <= 0) {\n            setTimeout(() => {\n                this._handleTimeout(false)\n            }, 0)\n            return\n        }\n        this._startTimer(timeout);\n    }\n\n    setExtra(ext = {}) {\n        if (ext.url) this.url = ext.url;\n        if (ext.rangeStart) this.rangeStart = ext.rangeStart;\n        if (ext.rangeEnd) this.rangeEnd = ext.rangeEnd;\n        if (ext.httpLoadTime) this.httpLoadTime = ext.httpLoadTime;\n        if (ext.allowLoadPartial) this.allowLoadPartial = true;\n        if (ext.xhrSetup) this.xhrSetup = ext.xhrSetup;\n    }\n\n    hasForwardPeer() {\n        return !!this.forwardPeer\n    }\n\n    hasReversePeer() {\n        return !!this.reversePeer\n    }\n\n    hasPeerId(peerId) {\n        return (this.forwardPeer && this.forwardPeer.remotePeerId === peerId) || (this.reversePeer && this.reversePeer.remotePeerId === peerId)\n    }\n\n    isEmpty() {\n        return this.forwardPeer === null && this.reversePeer === null\n    }\n\n    isFull() {\n        return this.forwardPeer && this.reversePeer\n    }\n\n    setForwardPeer(target) {\n        this.forwardPeer = target;\n        if (this.reversePeer) this._print();\n        this._setupPeer(target, false);\n    }\n\n    setReversePeer(target) {\n        this.reversePeer = target;\n        if (this.forwardPeer) this._print();\n        this._setupPeer(target, true);\n    }\n\n    deletePeer(target, clean = false) {\n        const reverse = target === this.reversePeer;\n        this._detachPeer(target);\n        if (reverse) {\n            this.reversePeer = null;\n            if (clean) {\n                this.reverseOffset = this.pieceMsg.attachments || 10000;\n            }\n        } else {\n            this.forwardPeer = null;\n            if (clean) this.forwardOffset = -1;\n        }\n        if (this.isEmpty()) {\n            // this._emitPartialOrError();\n            this._handleTimeout(false);\n        }\n    }\n\n    _emitPartialOrError() {\n        if (this.allowLoadPartial && this.hasPartialBuffer()) {\n            const [bufferLeft, bufferRight] = this.getPartialBuffer();\n            this.emit(Events.SYN_PARTIAL, this.pieceMsg, bufferLeft, bufferRight);\n        } else {\n            this.emit(Events.SYN_ERROR, this.pieceMsg);\n        }\n    }\n\n    hasPartialBuffer() {\n        return this.forwardOffset >= 0 || (this.pieceMsg && this.reverseOffset < this.pieceMsg.attachments)\n    }\n\n    getPartialBuffer() {\n        const bufferLeft = this.forwardOffset >= 0 ? Buffer.concat(this.bufArr.slice(0, this.forwardOffset+1)) : null;\n        const bufferRight = (this.pieceMsg && this.reverseOffset < this.pieceMsg.attachments) ? Buffer.concat(this.bufArr.slice(this.reverseOffset)) : null;\n        return [bufferLeft, bufferRight]\n    }\n\n    destroy() {\n        clearTimeout(this.timer);\n        this.removeAllListeners();\n        this.destroyed = true;\n        this._detachPeer(this.forwardPeer);\n        this.forwardPeer = null;\n        this.forwardOffset = -1;\n        this._detachPeer(this.reversePeer);\n        this.reversePeer = null;\n        this.reverseOffset = 10000;\n        this.bufArr = [];\n        this.forwardStreamListeners = [];\n        this.reverseStreamListeners = [];\n    }\n\n    _detachPeer(target) {\n        if (!target) return\n        // console.warn(`off peer ${this.pieceMsg.sn} ${target.remotePeerId}`)\n        const reverse = target === this.reversePeer;\n        const events = reverse ? this.reverseEvents : this.forwardEvents;\n        target\n            .off(Events.DC_PIECE_DATA, events.onPieceData)\n            .off(Events.DC_PIECE, events.onPiece)\n            .off(Events.DC_PIECE_NOT_FOUND, events.onPieceNotFound)\n            .off(Events.DC_PIECE_ABORT, events.onPieceAbort)\n    }\n\n    _receivePacket(reverse, dataSn, data, byP2p = true) {\n        // console.warn(`_receivePacket reverse ${reverse} dataSn ${dataSn} byteLength ${data.byteLength} byP2p ${byP2p}`)\n        const { seg_id: segId, sn, level, size } = this.pieceMsg\n        const idx = dataSn-1;\n        if (this.bufArr[idx]) {\n            this.logger.warn(`syn bufArr already has ${idx}`);\n            return\n        }\n        if (byP2p) {\n            this.p2pLoaded += data.byteLength;\n        } else {\n            this.httpLoaded += data.byteLength;\n        }\n        // console.warn(`set ${idx} size ${data.byteLength} to bufArr ${sn} reverse ${reverse} from ${peer.remotePeerId}`)\n        this.bufArr[idx] = data;\n        if (reverse) {\n            this.reverseOffset = idx;\n        } else {\n            this.forwardOffset = idx;\n        }\n        this._notifyStreamListeners(reverse, data, idx);\n\n        // 检查完成条件是否满足\n        if (this.forwardOffset !== this.reverseOffset - 1) return\n\n        if (this.forwardPeer) this.forwardPeer.miss = 0;\n        if (this.reversePeer) this.reversePeer.miss = 0;\n        // 清除定时器\n        clearTimeout(this.timer);\n        // stream listeners\n        this._notifyStreamListenersRemain();\n        // 计算速度\n        const speed = size / (performance.now() - this.timeStart);\n        let payload = Buffer.concat(this.bufArr);\n        // this.logger.debug(`expectedSize ${this.expectedSize}, byteLength ${payload.byteLength}`);\n        const byteLength = payload.byteLength;\n        if (byteLength === size) {     //校验数据\n            // let arrayBuffer = new Uint8Array(payload).buffer;       // 将uint8array转为arraybuffer\n            let arrayBuffer = payload.buffer;       // 将uint8array转为arraybuffer\n            const segment = new Segment(sn, segId, arrayBuffer, this.getFromPeerId(), level);\n            this.emit(Events.SYN_OUTPUT, segment, {\n                speed,\n                p2p: this.p2pLoaded,\n                http: this.httpLoaded,\n            });\n        } else {\n            this.logger.error(`${level}-${sn} expectedSize ${size} not equal to byteLength ${byteLength} forwardOffset ${this.forwardOffset} reverseOffset ${this.reverseOffset}`);\n            this.emit(Events.SYN_ERROR, this.pieceMsg);\n        }\n    }\n\n    _setupPeer(peer, reverse) {\n        if (this.timeStart === 0) this.timeStart = performance.now();\n        // let count = 0;     // test\n        const onPieceData = (sn, segId, data, dataSn, finished, pieceMsg) => {\n            if (this.destroyed) return\n            if (!this._validateMsg(sn, pieceMsg.level)) {\n                this.logger.error(`onPieceData ${pieceMsg.level}-${sn} not match ${JSON.stringify(this.pieceMsg)}`);\n                return\n            }\n            // 填充buffer array\n            const { reverse } = pieceMsg;\n            this._receivePacket(reverse, dataSn, data);\n        }\n        const onPiece = msg => {\n            if (this.destroyed) return\n            if (this.timeReceivePiece === 0) this.timeReceivePiece = performance.now();\n            const { attachments, size, sn, level, seg_id } = msg;\n            if (!this._validateMsg(sn, level)) {\n                this.logger.error(`onPiece ${msg.level}-${msg.sn} not match ${JSON.stringify(this.pieceMsg)}`);\n                this.deletePeer(peer);\n                return\n            }\n            if (this.pieceMsg.size && size !== this.pieceMsg.size) {\n                // size 不一致\n                this.logger.error(`onPiece ${msg.level}-${msg.sn} size not match`);\n                this.emit(Events.SYN_ERROR, this.pieceMsg);\n                return;\n            }\n            if (this.bufArr.length === 0) {\n                this.pieceMsg = {\n                    ...this.pieceMsg,\n                    seg_id,\n                    size,\n                    attachments,\n                }\n                this.reverseOffset = attachments;\n                this.bufArr = new Array(attachments);\n            }\n        }\n        const onPieceNotFound = msg => {\n            if (this.destroyed) return\n            if (!this._validateMsg(msg.sn, msg.level)) {\n                this.logger.error(`onPieceNotFound ${msg.level}-${msg.sn} not match ${JSON.stringify(this.pieceMsg)}`);\n                return\n            }\n            // 将peer淘汰\n            this.deletePeer(peer);\n        }\n        const onPieceAbort = () => {\n            if (this.destroyed) return\n            // 将peer淘汰\n            this.deletePeer(peer);\n        }\n        const events = {\n            onPieceData,\n            onPiece,\n            onPieceNotFound,\n            onPieceAbort\n        }\n        if (reverse) {\n            this.reverseEvents = events;\n        }  else {\n            this.forwardEvents =events;\n        }\n        peer\n            .on(Events.DC_PIECE_DATA, onPieceData)\n            .once(Events.DC_PIECE, onPiece)\n            .once(Events.DC_PIECE_NOT_FOUND, onPieceNotFound)\n            .once(Events.DC_PIECE_ABORT, onPieceAbort)\n    }\n\n    _validateMsg(sn, level) {\n        return sn === this.pieceMsg.sn && level === this.pieceMsg.level\n    }\n\n    _startTimer(timeout, shouldWait = true) {\n        this.timer = setTimeout(this._handleTimeout.bind(this, shouldWait), timeout)\n    }\n\n    loadedPackets() {\n        return this.pieceMsg.attachments - (this.reverseOffset - this.forwardOffset-1);\n    }\n\n    _handleTimeout(shouldWait = false) {\n        const { level, sn, size, attachments } = this.pieceMsg;\n        if (!size || this.timeReceivePiece === 0) {\n            this.logger.warn(`syn load timeout ${level}-${sn} url ${this.url}`);\n            this.emit(Events.SYN_ERROR, this.pieceMsg);\n            return\n        }\n        if (shouldWait && this.timeReceivePiece > 0) {\n            this.logger.warn(`syn ${this.loadedPackets()} of ${attachments} packets loaded`);\n            // 计算下载速度 byte/ms = KB/s\n            if (this.shouldWaitForRemain(this.httpLoadTime)) {\n                const timeout = this.httpLoadTime;\n                this.logger.info(`syn wait for remain ${timeout}`);\n                this._startTimer(timeout, false)\n                return\n            }\n        }\n        const badOne = [this.forwardPeer, this.reversePeer]\n            .filter(p=>!!p).sort((a, b)=>a.currentLoadSpeed()-b.currentLoadSpeed())\n            .shift()\n        if (badOne) badOne.loadtimeout();\n        if (this.rangeSupported && this.url) {\n            return this._loadRemainBufferByHttp();\n        }\n        // abort\n        this._notifyStreamListenersAbort();\n        this._emitPartialOrError();\n    }\n\n    shouldWaitForRemain(remainLoadTime) {\n        if (remainLoadTime <= 0) return false\n        const now = performance.now();\n        const sinceStart = now - this.timeStart;\n        // if (sinceStart < 1000) return true\n        if (sinceStart < 1500 && this.timeReceivePiece > 0 && remainLoadTime > 3000) return true     // 在1.5秒内收到piece\n        return this.shouldWaitForRemainUrgent(remainLoadTime)\n    }\n\n    shouldWaitForRemainUrgent(remainLoadTime) {\n        if (this.timeReceivePiece === 0 || remainLoadTime <= 0) return false\n        let downloadSpeed = 0;\n        let loadedBytes = 0;\n        [this.forwardPeer, this.reversePeer].forEach(peer => {\n            if (peer) {\n                downloadSpeed += peer.currentLoadSpeed();\n                loadedBytes += peer.loadedBytes();\n            }\n        })\n        const minRequiredSpeed = (this.pieceMsg.size-loadedBytes)/remainLoadTime;\n        this.logger.info(`syn remainTime ${remainLoadTime} speed ${downloadSpeed} required ${minRequiredSpeed}`);\n        return downloadSpeed >= minRequiredSpeed\n    }\n\n    getFromPeerId() {\n        const { forwardPeer, reversePeer } = this;\n        if (this.isFull() && forwardPeer !== reversePeer) return `${forwardPeer.remotePeerId}:${reversePeer.remotePeerId}`;\n        if (forwardPeer) return `${forwardPeer.remotePeerId}`;\n        if (reversePeer) return `${reversePeer.remotePeerId}`;\n        return ''\n    }\n\n    _loadRemainBufferByHttp() {\n        if (this.rangeRequesting) return;\n        const { size, sn, level } = this.pieceMsg;\n        // 补片\n        const rangeEnd = this.rangeEnd > 0 ? this.rangeEnd-1 : 0;\n        // 计算range\n        const currentForwardOffset = this.forwardOffset\n        const range = calRangeWithForwardReverseOffset(currentForwardOffset, this.reverseOffset, size, this.rangeStart, rangeEnd);\n        // 发起http请求\n        this.logger.info(`continue download ${level}-${sn} from ${this.url} range: ${range}`);\n        this.rangeRequesting = true;\n        performRangeRequest(this.url, range, this.xhrSetup).then(buffer => {\n            if (this.destroyed) return\n            this.rangeRequesting = false;\n            let httpPayload = Buffer.from(buffer);\n            const bufList = splitBytes(httpPayload, 0);\n            let fromIndex = currentForwardOffset + 1;\n            for (let i=0; i < bufList.length; i++) {\n                if (!this.bufArr[fromIndex]) {           // 防止在http请求期间已经下载\n                    this._receivePacket(false, fromIndex+1, bufList[i], false);\n                }\n                fromIndex ++;\n            }\n        }).catch(err => {\n            if (this.destroyed) return\n            this.rangeRequesting = false;\n            this.logger.error(`http partial download ${sn} error ${err}`);\n            this.emit(Events.SYN_ERROR, this.pieceMsg);\n        })\n    }\n\n    _print() {\n        const { level, sn } = this.pieceMsg;\n        this.logger.info(`syn parallel loading ${level}-${sn}`);\n    }\n\n}\n","import Peer from \"../../../core/peer\";\n\nexport function tryGetMediaElement(mediaElem) {\n    if (mediaElem) {\n        if (typeof mediaElem === 'string') {\n            return document.querySelector(mediaElem);\n        } else if (mediaElem instanceof HTMLMediaElement) {\n            return mediaElem;\n        }\n    }\n    return document.getElementsByTagName('video')[0] || document.getElementsByTagName('audio')[0]\n}\n\n// rangeStart-rangeEnd 闭区间\nexport function calRangeWithDoubleBuffer(bufferLeft, bufferRight, totalSize, rangeStart = 0, rangeEnd = 0) {\n    let range = `bytes=`;\n    if (!bufferRight) {\n        // 只有左边有数据\n        if (rangeEnd === 0) {\n            range = `${range}${rangeStart}-`;\n        } else {\n            range = `${range}${rangeStart}-${rangeEnd}`;\n        }\n    } else {\n        // 右边有数据或者两边都有数据\n        if (rangeEnd === 0) {\n            range = `${range}${rangeStart}-${totalSize-1-bufferRight.byteLength}`;\n        } else {\n            range = `${range}${rangeStart}-${rangeEnd-bufferRight.byteLength}`;\n        }\n    }\n    return range\n}\n\nexport function calRangeWithForwardReverseOffset(forwardOffset, reverseOffset, dataSize, rangeStart = 0, rangeEnd = 0) {\n    const packetSize = Peer.defaultPacketSize;\n    let range = `bytes=`;\n    let byteStart = rangeStart;\n    let byteEnd = rangeEnd || dataSize - 1;\n    const packetsCompleted = Math.floor(dataSize / packetSize);\n    const totalPackets = dataSize % packetSize > 0 ? packetsCompleted + 1 : packetsCompleted;\n    if (forwardOffset >= 0) {\n        byteStart += (forwardOffset+1) * packetSize;\n    }\n    range = `${range}${byteStart}-`;\n    if (reverseOffset >= 0 && reverseOffset < totalPackets) {\n        const reversePackets = totalPackets - reverseOffset;\n        byteEnd -= (dataSize % packetSize) + (reversePackets - 1) * packetSize;\n        range = `${range}${byteEnd}`;\n    } else if (rangeEnd !== 0) {\n        range = `${range}${byteEnd}`;\n    }\n    return range\n}\n\n","import commonConfig from '../core/config'\n\n//时间单位统一为秒\nlet defaultP2PConfig = {\n\n    ...commonConfig,\n    httpLoadTime: 2.0,                 // 需要保留给http下载的时间\n    sharePlaylist: false,\n    useHttpRange: true,\n\n    // hlsjs\n    hlsjsInstance: null,\n    proxyOnly: false,\n    p2pBlackList: ['aac', 'mp3', 'vtt', 'webvtt', 'key'],                // 不参与P2P的文件类型，防止报错\n    live: true,\n\n    // hls-sw\n    swFile: './sw.js',      // service worker文件路径\n    swScope: './',        // service worker作用范围\n    swAutoRegister: true,\n    mediaElem: undefined,\n    httpStreamEnabled: true,\n    diskCacheLimit: {\n        pc: 1500 * 1024 * 1024,\n        mobile: 800 * 1024 * 1024,\n    },\n    useDiskCache: true,\n};\n\nexport default defaultP2PConfig;\n","import defaultEvents from '../core/events'\n\nexport default {\n    ...defaultEvents,\n\n    SCH_DCHAVE: 'SCH_DCHAVE',\n    REQUESTING_MAP_HAVE: 'REQUESTING_MAP_HAVE',\n\n    SW_PLAYLIST: 'SW_PLAYLIST',\n    SW_GET_PLAYLIST: 'SW_GET_PLAYLIST',\n    SW_MEDIA: 'SW_MEDIA',\n    SW_GET_MEDIA: 'SW_GET_MEDIA',\n\n    LEVEL_LOADED: 'LEVEL_LOADED',\n    MANIFEST_PARSED: 'MANIFEST_PARSED',\n    FRAG_LOADED: 'FRAG_LOADED',\n\n    SYN_OUTPUT: 'SYN_OUTPUT',\n    SYN_ERROR: 'SYN_ERROR',\n    SYN_PARTIAL: 'SYN_PARTIAL',\n}\n\n","import EngineBase from \"../core/engine-base\"\nimport Events from './events'\nimport { tryGetMediaElement } from \"./common/utils/tool-funs\"\nimport Peer from \"../core/peer\"\nimport { isHttps, performRangeRequest } from \"../core/utils/tool-funs\"\nimport Engine from \"./common/engine\"\nimport M3U8Parser from \"../common/hls/m3u8-parser\"\nimport Server from \"../core/server\"\nimport HlsSwScheduler from \"./hls-sw/scheduler\"\nimport Tracker from \"../core/tracker-client\"\nimport URLToolkit from 'url-toolkit'\n\nclass HlsSwP2pEngine extends Engine {\n    static get name() {\n        return 'HlsSwP2pEngine'\n    }\n\n    static isServiceWorkerSupported() {\n        return ('serviceWorker' in navigator)\n    }\n\n    constructor(p2pConfig = {}) {\n        super(p2pConfig);\n        this.swSupported = isSecureContext;\n        this.levels = [];\n        this.currentLevelIndex = 0;\n        this.rangeTestUrl = '';                         // range请求的url\n        this.currentSrc = '';\n        this.swVersion = '';\n        this.media = tryGetMediaElement(this.config.mediaElem)\n        this.fragMap = new Map();                 // url -> {duration, sn, baseurl }\n\n        if (!HlsSwP2pEngine.isServiceWorkerSupported()) {\n            this.swSupported = false;\n            console.warn('service worker is not supported');\n            // this.p2pEnabled = false;\n        }\n\n        const { channelIdMaker, signalId, browserInfo } = this.setup();\n\n        this.onLevelLoaded = (level) => {\n            const { config } = this;\n            const isLive = level.live;\n            config.live = isLive;\n            // console.warn(JSON.stringify(level, null, 2));\n            this.targetDuration = level.averagetargetduration;\n            if (!isLive) {\n                config.trickleICE = true;\n            }\n            // 浏览器信息\n            this.browserInfo = {\n                ...browserInfo,\n                live: isLive,\n                abr: this.multiBitrate || undefined,\n                type: 'hls_sw',\n            };\n\n            this.channel = `${channelIdMaker(this.currentSrc)}|${signalId}[${Peer.VERSION}]`;\n\n            // electron\n            this.setupElectron();\n\n            const logger = this.initLogger();\n            logger.info(`use HlsSwP2pEngine`);\n            logger.info(`engine version: ${EngineBase.version} hls-proxy version: ${this.swVersion}`);\n            logger.info(`channel ${this.channel}`);\n            if (!isLive) {\n                config.startSN = level.startSN;\n                config.endSN = level.endSN;\n                logger.info(`startSN ${level.startSN} endSN ${level.endSN}`);\n            }\n\n            this._init(this.channel, this.browserInfo);\n\n            this.off(Events.LEVEL_LOADED, this.onLevelLoaded);\n        };\n\n        this.on(Events.LEVEL_LOADED, this.onLevelLoaded);\n\n        this.onManifestParsed = (levels, url) => {\n            // console.warn(`onManifestParsed`)\n            // console.warn(levels)\n            // console.warn(url)\n            this.multiBitrate = levels.length > 1;\n            this.currentSrc = url;\n            this.off(Events.MANIFEST_PARSED, this.onManifestParsed);\n        };\n\n        this.on(Events.MANIFEST_PARSED, this.onManifestParsed);\n\n        this.onFragLoaded = ({ url }) => {\n            // 发起Range请求\n            if (!this.rangeTested && this.config.useHttpRange) {\n                this.rangeTestUrl = url;\n                performRangeRequest(url).then(() => {\n                    this.config.httpRangeSupported = true;\n                    this.config.logger.info(`http range is supported`);\n                }).catch(() => {\n                    this.config.httpRangeSupported = false;\n                    this.config.logger.warn(`http range is not supported`);\n                });\n                this.rangeTested = true;\n            }\n            this.off(Events.FRAG_LOADED, this.onFragLoaded);\n        }\n\n        this.once(Events.FRAG_LOADED, this.onFragLoaded);\n\n        if (this.swSupported) {\n            navigator.serviceWorker.onmessage = (event) => {\n                const { action, data } = event.data;\n                if (this.logger) this.logger.info(`engine onmessage action ${action}`);\n                const sender = event.ports[0];\n                sender.postMessage({\n                    action,\n                    pong: true,\n                })\n                if (!this.p2pEnabled || !data) {\n                    return sender.postMessage({\n                        action,\n                    })\n                }\n                switch (action) {\n                    case Events.SW_PLAYLIST:\n                        this.handlePlaylist(data, sender);\n                        break;\n                    case Events.SW_GET_PLAYLIST:\n                        this.handleGetPlaylist(data, sender);\n                        break;\n                    default:\n                        if (this.config.scheduler) {\n                            this.config.scheduler.notifySWMessage(action, data, sender);\n                        } else {\n                            return sender.postMessage({\n                                action,\n                            })\n                        }\n                }\n            };\n        }\n\n        if (this.config.swAutoRegister) {\n            this.registerServiceWorker().then(function (registration) {\n                // console.info('ServiceWorker registration successful with scope: ', registration.scope);\n            }).catch((err) => {\n                console.warn('ServiceWorker registration failed ', err)\n            })\n        }\n    }\n\n    get currentLevel() {\n        return this.currentLevelIndex\n    }\n\n    handlePlaylist(data, sender) {\n        // console.warn(`currentLevelIndex ${this.currentLevelIndex}`);\n        const { config, logger } = this;\n        const { url, redirectedUrl, text, ver } = data;\n        // console.warn(text)\n        this.swVersion = ver;\n        if (text.indexOf('#EXTM3U') !== 0) {\n            console.warn('no EXTM3U delimiter');\n            return sender.postMessage({\n                action: Events.SW_PLAYLIST,\n            })\n        }\n        sender.postMessage({\n            action: Events.SW_PLAYLIST,\n            data: {\n                active: true,\n                debug: logger && logger.isDebugLevel,\n                sharePlaylist: !!config.sharePlaylist,\n            }\n        })\n        // console.warn(`handlePlaylist ${url}`)\n        this._parsePlaylist(text, url.split('?')[0], redirectedUrl)\n    }\n\n    _parsePlaylist(text, url, redirectedUrl) {\n        const originalUrl = url;\n        if (redirectedUrl) url = redirectedUrl;\n        const { config, logger } = this;\n        // console.warn(`url ${url}`)\n        // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)\n        if (text.indexOf('#EXTINF:') > 0 || text.indexOf('#EXT-X-TARGETDURATION:') > 0) {\n            let playlistLevel = 0;\n            const level = M3U8Parser.parseLevelPlaylist(text, url);\n            if (this.levels.length > 0) {\n                playlistLevel = this.levels.indexOf(level.url);\n                // console.warn(`playlistLevel ${playlistLevel}`);\n                if (playlistLevel === -1) {\n                    this.restartP2p();\n                    this.currentSrc = originalUrl;\n                    playlistLevel = 0;\n                } else {\n                    this.currentLevelIndex = playlistLevel;\n                }\n            } else {\n                // 播放的是单码率\n                if (this.currentSrc !== '' && url !== this.currentSrc) {\n                    this.restartP2p();\n                }\n                this.currentSrc = originalUrl;\n                this.levels = [url];\n            }\n            // console.warn(`emit LEVEL_LOADED ${level.url}`)\n            this.emit(Events.LEVEL_LOADED, level);\n            // const { fragMap } = config.scheduler;\n            if (config.live) {\n                this.fragMap.clear();\n            }\n            level.fragments.forEach(frag => {\n                frag.level = playlistLevel;\n                // console.warn(JSON.stringify(frag))\n                let url = URLToolkit.buildAbsoluteURL(frag.baseurl, frag.relurl, { alwaysNormalize: true });\n                const byteRange = frag.byteRange;\n                if (byteRange.length === 2) {\n                    url = `${url}|bytes=${byteRange[0]}-${byteRange[1]-1}`;\n                }\n                // console.warn(`fragMap.set ${url}`);\n                this.fragMap.set(url, frag);\n            });\n            if (config.sharePlaylist && config.scheduler) {\n                config.scheduler.broadcastPlaylist(url.split('?')[0], text);\n            }\n            // console.warn(fragMap.keys())\n        } else {\n            const levels = M3U8Parser.parseMasterPlaylist(text, url)\n            // console.warn(JSON.stringify(levels, null, 2))\n            if (this.currentSrc !== '') {\n                this.restartP2p();\n            }\n            if (levels.length > 0) {\n                // sort level on bitrate\n                levels.sort((a, b) => a.bitrate - b.bitrate);\n                this.levels = levels.map(level => level.url);\n                // console.warn(JSON.stringify(this.levels))\n            }\n            this.emit(Events.MANIFEST_PARSED, levels, originalUrl);\n        }\n    }\n\n    handleGetPlaylist(data, sender) {\n        const { config, logger } = this;\n        if (!logger) {\n            return sender.postMessage({\n                action: Events.SW_GET_PLAYLIST,\n            })\n        }\n        const { scheduler } = config;\n        if (!scheduler) {\n            logger.warn(`scheduler not found`);\n            return\n        }\n        const { url } = data;\n        const netUrl = url.split('?')[0];\n        if (scheduler.playlistInfo.has(netUrl)) {\n            const playlist = scheduler.getPlaylistFromPeer(netUrl);\n            if (playlist && playlist.data) {\n                const { data, seq } = playlist;\n                logger.info(`got playlist from peer seq ${seq}`);\n                sender.postMessage({\n                    action: Events.SW_GET_PLAYLIST,\n                    data: {\n                        text: data,\n                    }\n                })\n                this._parsePlaylist(data, url.split('?')[0]);\n                return\n            }\n        }\n        return sender.postMessage({\n            action: Events.SW_GET_PLAYLIST,\n        })\n    }\n\n    async registerServiceWorker() {\n        const { logger, config } = this;\n        if (!this.swSupported) {\n            let msg =  `sw is not supported`;\n            if (!isHttps) {\n                msg = `https is required when using ServiceWorker`\n                logger.error(msg)\n            }\n            return Promise.reject(msg);\n        }\n        this.media = tryGetMediaElement(this.config.mediaElem)\n        if (!this.media) {\n            if (logger) logger.warn(`no video element found`);\n        }\n        const { serviceWorker } = navigator;\n        return serviceWorker.getRegistration(config.swFile).then(reg => {\n            // if (reg) {\n            //     console.warn('getRegistration')\n            // }\n            return reg || serviceWorker.register(config.swFile, { scope: config.swScope })\n                .then((reg) => {\n                    const swRegTmp = reg.installing || reg.waiting;\n                    if (reg.active) {\n                        // console.warn('reg.active')\n                        return reg\n                    }\n                    return new Promise((resolve, reject) => {\n                        // console.warn(`statechange`);\n                        const fn = () => {\n                            if (swRegTmp.state === 'activated') {\n                                swRegTmp.removeEventListener('statechange', fn);\n                                resolve(reg)\n                            } else if (swRegTmp.state === 'redundant') {\n                                reject(`sw is redundant`);\n                            }\n                        }\n                        swRegTmp.addEventListener('statechange', fn);\n                    })\n                })\n        });\n    }\n\n    unregisterServiceWorker() {\n        const { config } = this;\n        const msg = 'serviceWorker is not registered';\n        return new Promise((resolve, reject) => {\n            const { serviceWorker } = navigator;\n            if (!serviceWorker) reject(msg);\n            serviceWorker.getRegistration(config.swFile).then(reg => {\n                if (reg) {\n                    reg.unregister().then(() => {\n                        resolve();\n                    }).catch(() => {\n                        reject(msg)\n                    })\n                } else {\n                    reject(msg)\n                }\n            });\n        })\n    }\n\n    async _init(channel, browserInfo) {\n        if (!this.p2pEnabled) return;\n\n        await this.initSegmentManager();\n\n        //实例化Fetcher\n        let fetcher = new Server(this, this.config.token, encodeURIComponent(channel), this.config.announce || '', browserInfo);\n        this.fetcher = fetcher;\n        this.config.fetcher = fetcher;\n        let scheduler = new HlsSwScheduler(this, this.config);\n        scheduler.bufferManager = this.bufMgr;\n        scheduler.fragMap = this.fragMap;\n        //实例化tracker服务器\n        this.tracker = new Tracker(this, fetcher, scheduler, this.config);\n\n        this.config.scheduler = this.tracker.scheduler;\n\n        // 连接tracker\n        if (this.p2pEnabled && !this.tracker.connected) {\n            this.tracker.resumeP2P();\n        }\n\n        this.setupWindowListeners();\n    }\n\n    restartP2p() {\n        if (this.logger) this.logger.warn(`restart P2P`);\n        this.disableP2P();\n        this.enableP2P();\n        this.on(Events.LEVEL_LOADED, this.onLevelLoaded);\n        this.on(Events.MANIFEST_PARSED, this.onManifestParsed);\n        this.on(Events.FRAG_LOADED, this.onFragLoaded);\n    }\n\n    // override\n    enableP2P() {\n        if (!this.p2pEnabled) {\n            if (this.logger) this.logger.info(`enable P2P`);\n            this.config.p2pEnabled = this.p2pEnabled = true;\n            return this;\n        }\n        return null;\n    }\n\n    disableP2P() {\n        if (this.logger) this.logger.warn(`disable P2P`);       // 防止在未初始化时就调用\n        // this.removeAllListeners();\n        // console.warn(`this.p2pEnabled ${this.p2pEnabled}`)\n        if (this.p2pEnabled) {\n            this.config.p2pEnabled = this.p2pEnabled = false;\n            if (this.tracker) {\n                // console.warn('this.tracker.stopP2P')\n                this.tracker.stopP2P();\n                this.tracker = {};\n                this.fetcher = null;\n                this.bufMgr.destroy();\n                this.bufMgr = null;\n            }\n        }\n        this.levels = [];\n        this.currentLevelIndex = 0;\n        this.lastLevel = 0;\n        this.multiBitrate = false;\n        this.rangeTested = false;\n        this.rangeTestUrl = '';\n        this.currentSrc = '';\n        this.media = undefined;\n        this.config.live = false;\n        this.removeAllListeners(Events.MANIFEST_PARSED);\n        this.removeAllListeners(Events.LEVEL_LOADED);\n    }\n}\n\nexport default HlsSwP2pEngine\n","import Scheduler from \"../common/scheduler\"\nimport Events from '.././events'\nimport Segment from \"../../core/segment\"\nimport queueMicrotask from \"../../core/utils/queue-microtask\"\nimport Synthesizer from \"../common/synthesizer\"\n\nconst MIN_TIME_FOR_LOAD = 7.5;             // 留给scheduler下载的最少时间\nconst MAX_TIME_FOR_WAIT = 4.0;            // 等待have信号的最大时间\n\nclass HlsSwScheduler extends Scheduler {\n\n    constructor(engine, config) {\n        super(engine, config);\n        this.server = config.fetcher;\n        this.p2pEnabled = engine.p2pEnabled;\n\n        // 传输控制\n        this.resolveMap = new Map();                           // sn -> promise\n        this.dcDownloadTimeout = 10;\n\n        // this.fragMap = new Map();                 // url -> {duration, sn, baseurl }\n        this.segmentId = config.segmentId;\n    }\n\n    async handleGetMediaData(data, sender) {\n        const { logger, config } = this;\n        let { url, range } = data;\n        if (range) {\n            url = `${url}|${range}`;\n        }\n        // console.warn(`handleGetMediaData url ${url}`);\n        // await timeout(3000)        // test\n        const frag = this.fragMap.get(url);\n        if (!frag) {\n            logger.warn(`cannot get frag ${url}`);\n            return sender.postMessage({\n                action: Events.SW_GET_MEDIA\n            })\n        }\n        this.engine.currentLevelIndex = frag.level;\n        const { sn, baseurl, level } = frag;\n        // console.warn(`frag request url ${url} sn ${sn} range ${range} baseurl ${baseurl}`);\n        const segId = this.segmentId(String(level), sn, data.url, range);\n        this.loadingSN = sn;\n        this.loadingSegId = segId;\n        const seg = await this.bufMgr.getSegById(segId);\n        if (seg) {\n            logger.info(`bufMgr found seg sn ${sn} segId ${segId}`);\n            // const seg = this.bufMgr.getSegById(segId);\n            frag.loaded = seg.data.byteLength;\n            frag.fromPeerId = seg.fromPeerId;\n            this.engine.emit(Events.FRAG_LOADED, {\n                url: data.url,\n                sn,\n                level,\n                segId,\n                loaded: frag.loaded,\n                duration: frag.duration,\n                byP2p: !!seg.fromPeerId,\n                fromPeerId: seg.fromPeerId,\n            });\n            this._onFragLoaded(data.url, frag);\n            return sender.postMessage({\n                action: Events.SW_GET_MEDIA,\n                data: {\n                    url: data.url,\n                    buffer: seg.data,\n                    incomplete: false,\n                }\n            })\n        }\n        if (this.resolveMap.has(sn)) {\n            logger.warn(`${sn} is requesting, fallback`)\n            // http download\n            sender.postMessage({\n                action: Events.SW_GET_MEDIA\n            })\n            return\n        }\n        const bufferedDuration = this.getBufferedDuration();\n        if (this.hasAndSetTargetPeer(sn, level, bufferedDuration)) {\n            // if (false) {\n            const loaded = await this._loadFragByP2p(frag, sender, sn, segId, data.url, level);\n            if (!loaded) {\n                // http download\n                // this.notifyAllPeers(sn, level, segId);\n                sender.postMessage({\n                    action: Events.SW_GET_MEDIA\n                })\n            }\n        } else {\n            // console.warn(`live ${config.live} this.hasIdlePeers ${this.hasIdlePeers} bufferedDuration ${bufferedDuration}`)\n            if (config.live\n                && this.waitTimer === undefined\n                && bufferedDuration > MIN_TIME_FOR_LOAD && this.shouldWaitForNextSeg()\n            ) {\n                let waitFor = bufferedDuration - MIN_TIME_FOR_LOAD;\n                if (waitFor > MAX_TIME_FOR_WAIT) waitFor = MAX_TIME_FOR_WAIT;\n                let loaded;\n                const onPeerHave = async segIdHave => {\n                    // console.warn(`SCH_DCHAVE ${segIdHave}`);\n                    if (segId === segIdHave) {\n                        this.off(Events.SCH_DCHAVE, onPeerHave);    // 防止重复触发\n                        clearTimeout(this.waitTimer);\n                        this.waitTimer = undefined;\n                        if (this.hasAndSetTargetPeer(sn, level, bufferedDuration)) {\n                            loaded = await this._loadFragByP2p(frag, sender, sn, segId, data.url, level);\n                        }\n                        if (!loaded) {\n                            // http download\n                            // this.notifyAllPeers(sn, level, segId);\n                            sender.postMessage({\n                                action: Events.SW_GET_MEDIA\n                            })\n                        }\n                    }\n                };\n                logger.info(`wait peer have ${segId} for ${waitFor}s`);\n                this.on(Events.SCH_DCHAVE, onPeerHave);\n                this.waitTimer = setTimeout(() => {\n                    this.off(Events.SCH_DCHAVE, onPeerHave);\n                    // http download\n                    // this.notifyAllPeers(sn, level, segId);\n                    sender.postMessage({\n                        action: Events.SW_GET_MEDIA\n                    })\n                    this.waitTimer = undefined;\n                }, waitFor*1000);\n            } else {\n                // http download\n                sender.postMessage({\n                    action: Events.SW_GET_MEDIA\n                })\n                // await timeout(3000)        // test wait peer have\n                // console.warn(`await timeout(4000)`)\n                // this.notifyAllPeers(sn, level, segId);\n            }\n        }\n    }\n\n    async _loadFragByP2p(frag, sender, sn, segId, url, level) {\n        const { logger } = this;\n        logger.info(`p2p load sn ${sn} segId ${segId} level ${level}`);\n        const resp = await this.load(sn, segId, level);\n        if (resp && (resp.data || resp.incomplete)) {\n            // 下载完整的才缓存\n            const { data, incomplete, fromPeerId, bufferLeft, bufferRight, size } = resp;\n            if (!incomplete) {\n                logger.info(`p2p loaded segId ${segId} level ${level} size ${data.byteLength} incomplete ${incomplete}`);\n                if (!await this.bufMgr.hasSegOfId(segId)) {\n                    const segment = new Segment(sn, segId, data, fromPeerId, level);\n                    logger.info(`bufMgr putSeg ${sn} level ${level}`);\n                    this.bufMgr.putSeg(segment);\n                }\n                frag.loaded = data.byteLength;\n            } else {\n                logger.info(`p2p loaded partial segId ${segId} level ${level} size ${size}`);\n                frag.loaded = (bufferLeft ? bufferLeft.byteLength : 0) + (bufferRight ? bufferRight.byteLength : 0);\n            }\n\n            frag.fromPeerId = fromPeerId;\n            this.engine.emit(Events.FRAG_LOADED, {\n                url,\n                sn,\n                level,\n                segId,\n                loaded: frag.loaded,\n                duration: frag.duration,\n                byP2p: true,\n                fromPeerId,\n            });\n            this._onFragLoaded(url, frag);\n            sender.postMessage({\n                action: Events.SW_GET_MEDIA,\n                data: {\n                    url,\n                    buffer: data,\n                    bufferLeft,\n                    bufferRight,\n                    incomplete,\n                    size,\n                }\n            })\n            return true\n        }\n        // p2p下载超时\n        logger.warn(`P2P timeout load segId ${segId}`);\n        const seg = await this.bufMgr.getSegById(segId);\n        if (seg) {\n            // 已经下载过了 复用\n            logger.info(`already loaded seg sn ${sn} segId ${segId}`);\n            // const seg = this.bufMgr.getSegById(segId);\n            sender.postMessage({\n                action: Events.SW_GET_MEDIA,\n                data: {\n                    url: url,\n                    buffer: seg.data,\n                    incomplete: false,\n                }\n            })\n            return true\n        }\n        return false\n    }\n\n    async handleMediaData(data, sender) {\n        const { logger, engine } = this;\n        let { url, buffer, range } = data;\n        if (engine.rangeTestUrl === url) {\n            engine.rangeTestUrl = '';\n            return;\n        }\n        logger.info(`SW_MEDIA url ${url} size ${buffer.byteLength} range ${range}`);\n        if (range) {\n            url = `${url}|${range}`;\n        }\n        this.server.reportFlow(buffer.byteLength);\n        // 缓存ts\n        const frag = this.fragMap.get(url);\n        if (frag) {\n            const { sn, level, baseurl } = frag;\n            // console.warn(`frag url ${url} sn ${sn} range ${range} baseurl ${baseurl}`);\n            const segId = this.segmentId(String(level), sn, data.url, range);\n            this.notifyAllPeers(sn, level, segId);\n            frag.segId = segId;\n            frag.loaded = buffer.byteLength;\n            engine.emit(Events.FRAG_LOADED, {\n                url: data.url,\n                sn,\n                level,\n                segId,\n                loaded: frag.loaded,\n                duration: frag.duration,\n                byP2p: false,\n            });\n            this._onFragLoaded(data.url, frag);\n            if (!await this.bufMgr.hasSegOfId(segId)) {\n                const segment = new Segment(sn, segId, buffer, '', level);\n                this.bufMgr.putSeg(segment);\n                logger.info(`bufMgr putSeg ${segId} level ${level}`)\n            }\n        }\n        sender.postMessage({\n            action: Events.SW_MEDIA\n        })\n    }\n\n    notifySWMessage(action, data, sender) {\n        switch (action) {\n            case Events.SW_MEDIA:\n                this.handleMediaData(data, sender);\n                break;\n            case Events.SW_GET_MEDIA:\n                this.handleGetMediaData(data, sender);\n                break;\n            default:\n                this.logger.warn(`unknown action ${action}`);\n        }\n    }\n\n    // override\n    destroy() {\n        super.destroy();\n        this.logger.warn(`destroy HlsSwScheduler`);\n    }\n\n    _onFragLoaded(url, frag) {\n        this.updateLoaded(frag.sn, frag.level);\n        // update play sn\n        if (!this.engine) return\n        const { media, targetDuration } = this.engine;\n        if (!this.config.live && media && targetDuration) {\n            this.currPlaySN = Math.ceil(media.currentTime/targetDuration);\n            // console.warn(`currPlaySN ${this.currPlaySN}`)\n        }\n    }\n\n    load(sn, segId, level) {\n        const { logger, config } = this;\n        this.isReceiver = true;\n        let loadTimeout = this.mBufferedDuration - this.config.httpLoadTime;   // second\n        if (loadTimeout > this.dcDownloadTimeout) {\n            loadTimeout = this.dcDownloadTimeout;\n        }\n        const {forwardPeer, reversePeer} = this.targetPeers;\n        if (!forwardPeer && !reversePeer) {\n            loadTimeout -= 1.0\n        }\n        let synthesizer = this.requestingMap.get(sn, level);\n        let ext = {\n            allowLoadPartial: config.httpRangeSupported\n        }\n        if (!synthesizer) {\n            synthesizer = new Synthesizer(this.logger, sn, level, config.httpRangeSupported, ext);\n            this._setupSynthesizer(synthesizer);\n            this.requestingMap.set(sn, level, synthesizer);\n        } else {\n            synthesizer.setExtra(ext)\n        }\n        synthesizer.setTimeout(loadTimeout * 1000);\n        if (forwardPeer) {\n            synthesizer.setForwardPeer(forwardPeer);\n            forwardPeer.requestDataById(segId, sn, true, { level });\n        }\n        if (reversePeer) {\n            synthesizer.setReversePeer(reversePeer);\n            reversePeer.requestDataById(segId, sn, true, { level, reverse: true });\n        }\n        const promise = new Promise((resolve => {\n            const promise = {\n                resolve,\n                sn,\n                level,\n                segId,\n                incomplete: false,      // 没有下载完整\n            };\n            this.resolveMap.set(sn, promise);\n        }));\n        this.targetPeers = {};          // 重置\n        return promise;\n    }\n\n    _setupSynthesizer(synthesizer) {\n        synthesizer.on(Events.SYN_OUTPUT, (segment, info) => {\n            const { config, logger } = this;\n            const { segId, sn, data, level } = segment;\n            // console.warn(`SYN_OUTPUT ${level}-${sn}`)\n            const { speed } = info;\n            const isCritical = this.resolveMap.has(sn);\n            const verified = config.validateSegment(segId, new Uint8Array(data));    // 对数据进行校验，防止节点作恶\n            if (verified) {\n                this.notifyAllPeers(sn, level, segId);\n                if (!this.bitset.has(sn, level)) {\n                    // 上报流量\n                    this.reportTraffic(info.http, info.p2p, speed)\n                }\n                const fromPeerId = synthesizer.getFromPeerId();\n                if (isCritical) {\n                    logger.info(`receive criticalSeg seg_id ${segId}`);\n                    const promise = this.resolveMap.get(sn);\n                    this.resolveMap.delete(sn);\n                    promise.resolve({ data, fromPeerId: fromPeerId });\n                } else {\n                    // 判断是否已经存储过了\n                    if (this.bitset.has(sn, level)) return;\n                    // const segment = new Segment(sn, segId, data, fromPeerId, level);\n                    this.bufMgr.putSeg(segment);\n                    this.updateLoaded(sn, level);                                // 只有预加载请求需要\n                }\n            } else {\n                logger.error(`segment ${segId} validate failed`);\n                if (isCritical) {\n                    const promise = this.resolveMap.get(sn);\n                    this.resolveMap.delete(sn);\n                    promise.resolve();\n                }\n            }\n            this.requestingMap.delete(sn, level);\n            if (config.live && this.resolveMap.size === 0) this.checkPeers();\n        })\n            .on(Events.SYN_PARTIAL, (pieceMsg, bufferLeft, bufferRight) => {\n                // console.warn(pieceMsg)\n                // if (bufferLeft) console.warn(`bufferLeft ${bufferLeft.byteLength}`)\n                // if (bufferRight) console.warn(`bufferRight ${bufferRight.byteLength}`)\n                const { sn, level, size } = pieceMsg;\n                // console.warn(`SYN_PARTIAL ${level}-${sn}`)\n                if (this.resolveMap.has(sn)) {\n                    const promise = this.resolveMap.get(sn);\n                    promise.resolve({ bufferLeft, bufferRight, fromPeerId: synthesizer.getFromPeerId(), incomplete: true, size });\n                    this.resolveMap.delete(sn);\n                }\n                this.requestingMap.delete(sn, level);\n            })\n            .on(Events.SYN_ERROR, (pieceMsg) => {\n                const { sn, level } = pieceMsg;\n                // console.warn(`SYN_ERROR ${level}-${sn}`)\n                if (this.resolveMap.has(sn)) {\n                    const promise = this.resolveMap.get(sn);\n                    this.resolveMap.delete(sn);\n                    promise.resolve();\n                }\n                this.requestingMap.delete(sn, level);\n            })\n    }\n\n    _handleDCHave(peer, sn, level, state) {\n        const isCritical = this.resolveMap.size !== 0;\n        if (isCritical && this.resolveMap.has(sn)) {\n            const { segId } = this.resolveMap.get(sn)\n            this._notifySynthesizer(peer, segId, sn, level, state);\n        }\n        // else if (sn === this.loadingSN + 1) {\n        //     this._notifySynthesizer(peer, null, sn, level, state, false);\n        // }\n        if (this.config.live && !isCritical) {\n            queueMicrotask(() => {                                                   //必须是异步回调\n                this.checkPeers();\n            })\n        }\n    }\n}\n\nexport default HlsSwScheduler\n","import Engine from \"./common/engine\"\nimport Events from './events'\nimport Peer from \"../core/peer\"\nimport Server from \"../core/server\"\nimport Tracker from \"../core/tracker-client\"\nimport FragLoader from \"./hlsjs/frag-loader\"\nimport PlaylistLoader from \"./hlsjs/playlist-loader\"\nimport { isBlockType } from \"./hlsjs/utils/tool-funs\"\nimport { performRangeRequest } from \"../core/utils/tool-funs\"\nimport errCode from \"../core/utils/err-code\"\nimport HlsjsScheduler from \"./hlsjs/scheduler\"\nimport {fetchSupported} from \"./hlsjs/utils/fetch-loader\"\n\nclass HlsjsP2pEngine extends Engine {\n    static get name() {\n        return 'HlsjsP2pEngine'\n    }\n    constructor(hlsjs, p2pConfig = {}) {\n        super(p2pConfig);\n        if (!hlsjs) {\n            throw new TypeError('hlsjs instance is null')\n        }\n        this.hlsjs = hlsjs;\n        this.HLSEvents = hlsjs.constructor.Events;\n\n        this.config.isHlsV0 = hlsjs.constructor.version.split('.')[0] === '0';\n        // console.warn(`isHlsV0 ${this.config.isHlsV0}`);\n        this.config.xhrSetup = hlsjs.config.xhrSetup;\n        // console.warn(`this.config.streamEnabled ${this.config.streamEnabled}`);\n        if (this.config.httpStreamEnabled === true) {\n            hlsjs.config.streamEnabled = fetchSupported();\n        }\n        const { channelIdMaker, signalId, browserInfo } = this.setup();\n\n        hlsjs.config.segmentId = this.config.segmentId;\n\n        const onLevelLoaded = (event, data) => {\n            const { config } = this;\n            const details = data.details;\n            const isLive = details.live;\n            config.live = this.hlsjs.config.live = isLive;\n            if (!isLive) {\n                config.trickleICE = true;\n            }\n            // 浏览器信息\n            this.browserInfo = {\n                ...browserInfo,\n                live: isLive,\n                abr: this.multiBitrate || undefined,\n                type: 'hls',\n            };\n\n            // test 分布式信令\n            // this.channel = `${channelIdMaker(hlsjs.url, this.browserInfo)}[${Peer.VERSION}]`;\n            this.channel = `${channelIdMaker(hlsjs.url)}|${signalId}[${Peer.VERSION}]`;\n\n            // electron\n            this.setupElectron();\n\n            //初始化logger\n            const logger = this.initLogger();\n            logger.info(`use HlsjsP2pEngine`);\n            this.logger = this.hlsjs.config.logger = logger;\n            logger.info(`channel ${this.channel}`);\n            if (!isLive) {\n                config.startSN = details.startSN;\n                config.endSN = details.endSN;\n                logger.info(`startSN ${details.startSN} endSN ${details.endSN}`);\n            }\n            this.eventListened = false;\n\n            this._init(this.channel, this.browserInfo);\n\n            // logger.info(JSON.stringify(details));\n\n            hlsjs.off(this.HLSEvents.LEVEL_LOADED, onLevelLoaded);\n\n        };\n\n        hlsjs.on(this.HLSEvents.LEVEL_LOADED, onLevelLoaded);\n\n        const onManifestParsed = (event, data) => {\n            // console.warn(data)\n            const levels = data.levels.length;\n            this.multiBitrate = levels > 1;\n\n            hlsjs.off(this.HLSEvents.MANIFEST_PARSED, onManifestParsed);\n        };\n\n        hlsjs.on(this.HLSEvents.MANIFEST_PARSED, onManifestParsed);\n    }\n\n    async _init(channel, browserInfo) {\n        const { logger, config } = this;\n        if (!this.p2pEnabled) return;\n\n        this.hlsjs.config.p2pEnabled = this.p2pEnabled;\n        this.hlsjs.config.sharePlaylist = config.sharePlaylist;\n\n        await this.initSegmentManager();\n\n        this.hlsjs.config.bufMgr = this.bufMgr;\n\n        // 获取media\n        this.media = this.hlsjs.media;\n\n        //实例化Fetcher\n        let fetcher = new Server(this, config.token, encodeURIComponent(channel), config.announce || '', browserInfo);\n        this.fetcher = fetcher;\n\n        const scheduler = new HlsjsScheduler(this, config);\n\n        // 实例化tracker服务器\n        this.tracker = new Tracker(this, fetcher, scheduler, config);\n        // this.tracker.scheduler.bufferManager = this.bufMgr;\n        scheduler.bufferManager = this.bufMgr;\n        // 替换fLoader\n        this.hlsjs.config.fLoader = FragLoader;\n        // 替换pLoader\n        if (config.sharePlaylist) {\n            this.hlsjs.config.pLoader = PlaylistLoader;\n        }\n        // 防止hls.js报错\n        window.__p2p_loader__ = {\n            scheduler: this.tracker.scheduler,\n            fetcher,\n            p2pBlackList: config.p2pBlackList,\n            isHlsV0: config.isHlsV0,\n        };\n\n        this.trackerTried = false;                                                   //防止重复连接ws\n\n        if (!this.eventListened) {\n            this.hlsjs.on(this.HLSEvents.FRAG_LOADING, this._onFragLoading.bind(this));\n\n            this.hlsjs.on(this.HLSEvents.FRAG_LOADED, this._onFragLoaded.bind(this));\n\n            this.hlsjs.on(this.HLSEvents.FRAG_CHANGED, this._onFragChanged.bind(this));\n\n            this.hlsjs.on(this.HLSEvents.ERROR, this._onHlsError.bind(this));\n\n            this.eventListened = true;\n        }\n\n        this.setupWindowListeners();\n\n        if (!this.trackerTried && !this.tracker.connected && config.p2pEnabled) {\n\n            this.tracker.resumeP2P();\n            this.trackerTried = true;\n        }\n    }\n\n    _onFragLoading(id, data) {\n        // console.warn(`FRAG_LOADING: ${data.frag.sn} loadByHTTP ${data.frag.loadByHTTP}`);\n        // console.warn(this.hlsjs.config.lowLatencyMode)\n        // console.warn(JSON.stringify(data, null, 2));\n        // console.warn(this.hlsjs.config);\n        const frag = data.frag;\n        let {sn, level, segId} = frag;\n        if (!isBlockType(frag.url, this.config.p2pBlackList)) {\n            this.logger.debug('loading frag ' + sn);\n            if (!segId) {\n                let range;\n                if (frag._byteRange) {\n                    range = 'bytes=' + frag._byteRange[0] + '-' + frag._byteRange[1];\n                }\n                let segmentUrl = frag.url;\n                // if (true) {\n                // if (data.part) {\n                //     console.warn(data.part.relurl)\n                //     segmentUrl = frag.type + data.part.relurl;\n                // }\n                segId = data.frag.segId = this.config.segmentId(String(level), frag.sn, segmentUrl, range);\n            }\n            this.emit(Events.FRAG_LOADING, {\n                sn,\n                segId,\n                byHttp: frag.loadByHTTP,\n                level,\n            });\n        }\n    }\n\n    _onFragLoaded(id, data) {\n        // console.warn(`FRAG_LOADED: ${data.frag.sn} loadByHTTP ${data.frag.loadByHTTP}`);\n        // console.warn('FRAG_LOADED: '+ data.frag.sn);\n        // console.warn(JSON.stringify(data.frag, null, 2));\n        const { sn, segId, loaded, duration, level, fromPeerId, loadByP2P, url } = data.frag;\n        const { config, logger } = this;\n        if (!isBlockType(data.frag.url, config.p2pBlackList)) {\n            this.emit(Events.FRAG_LOADED, {\n                url,\n                sn,\n                level,\n                segId,\n                loaded,\n                duration,\n                byP2p: !!loadByP2P,\n                fromPeerId,\n            });\n            // 发起Range请求\n            if (!this.rangeTested && config.useHttpRange) {\n\n                performRangeRequest(data.frag.url, undefined, config.xhrSetup).then(() => {\n                    config.httpRangeSupported = true;\n                    logger.info(`http range is supported`);\n                    // config.httpLoadTime -= 1.5;\n                    // if (config.httpLoadTime < 1.5) {\n                    //     config.httpLoadTime = 1.5;\n                    // }\n                    // console.warn(`config.httpLoadTime ${config.httpLoadTime}`)\n                }).catch(() => {\n                    config.httpRangeSupported = false;\n                    logger.warn(`http range is not supported`);\n                });\n                this.rangeTested = true;\n            }\n        }\n    }\n\n    _onFragChanged(id, data) {\n        if (!isBlockType(data.frag.url, this.config.p2pBlackList)) {\n            this.logger.debug('frag changed: ' + data.frag.sn);\n            const {sn, duration} = data.frag;\n            this.emit(Events.FRAG_CHANGED, {sn, duration});\n        }\n    }\n\n    _onHlsError(event, data) {\n        if (!data) return\n        const { logger } = this;\n        if (data.fatal) {\n            logger.error(`${data.type} details ${data.details} reason ${data.reason}`);\n        } else {\n            logger.warn(`${data.type} details ${data.details} reason ${data.reason}`);\n        }\n        // this.fetcher.exptMsg = data.details;                         // test\n        const errDetails = this.hlsjs.constructor.ErrorDetails;\n        switch (data.details) {\n            case errDetails.BUFFER_STALLED_ERROR:\n                if (this.fetcher) this.fetcher.errsBufStalled++;\n                break;\n            case errDetails.INTERNAL_EXCEPTION:\n                if (this.fetcher) {\n                    this.fetcher.errsInternalExpt++;\n                    this.fetcher.exptMsg = data.err.message;\n                }\n                logger.error(`INTERNAL_EXCEPTION event ${data.event} err ${data.err.message}`);\n                this.emit(Events.EXCEPTION, errCode(data.err, 'HLSJS_EXPT'));\n                break;\n            default:\n                // console.error(event)\n                // console.error(data)\n        }\n    }\n\n    get currentLevel() {\n        const { currentLevel } = this.hlsjs;\n        return currentLevel >= 0 ? currentLevel : 0\n    }\n\n    disableP2P() {                                              //停止p2p\n        if (this.logger) this.logger.warn(`disable P2P`);       // 防止在未初始化时就调用\n        // this.removeAllListeners();\n        // console.warn(`this.p2pEnabled ${this.p2pEnabled}`)\n        if (this.p2pEnabled) {\n            this.p2pEnabled = false;\n            this.config.p2pEnabled = this.hlsjs.config.p2pEnabled = this.p2pEnabled;\n            if (this.tracker) {\n                // console.warn('this.tracker.stopP2P')\n                this.tracker.stopP2P();\n                this.tracker = {};\n                this.fetcher = null;\n                this.bufMgr.destroy();\n                this.bufMgr = null;\n                this.hlsjs.config.fLoader = this.hlsjs.config.pLoader =  this.hlsjs.constructor.DefaultConfig.loader;\n            }\n        }\n        // window.__p2p_loader__ = {};\n    }\n\n}\n\nexport default HlsjsP2pEngine\n","import EventEmitter from 'events'\nimport { isBlockType } from './utils/tool-funs'\nimport Segment from \"../../core/segment\"\nimport queueMicrotask from '../../core/utils/queue-microtask'\nimport { createLoadStats, updateLoadStats } from './utils/tool-funs'\nimport Events from '../events'\nimport { copyBuffer } from '../../core/utils/tool-funs'\nimport { FetchLoader } from \"./utils/fetch-loader\"\nimport SegmentBuilder from \"./utils/segment-builder\"\nimport {SegmentState} from \"../common/segment-state\"\n\n// const sha1 = require('simple-sha1');\nconst MIN_TIME_FOR_LOAD = 7.0;          // 留给scheduler下载的最少时间\nconst MAX_TIME_FOR_WAIT = 4.5;          // 等待have信号的最大时间\n\nclass FragLoader extends EventEmitter {\n    constructor(config) {\n        super();\n\n        this.logger = config.logger;\n        //denoted by sn\n\n        const {scheduler, fetcher, p2pBlackList, isHlsV0} = window.__p2p_loader__;\n\n        this.isHlsV0 = isHlsV0;\n        this.bufMgr = config.bufMgr;\n        this.streamEnabled = config.streamEnabled;\n        this.httpLoader = this.streamEnabled ? new FetchLoader(config) : new config.loader(config);\n        this.p2pEnabled = config.p2pEnabled;\n        this.isLive = config.live;\n        this.scheduler = scheduler;\n        this.fetcher = fetcher;\n        this.segmentId = config.segmentId;\n        this.blockTypes = p2pBlackList;\n        this.forbidden = fetcher.forbidden;\n        this.stats = this.httpLoader.stats || createLoadStats();\n    }\n\n    destroy() {\n        this.httpLoader.destroy();\n    }\n\n    abort() {\n        // console.warn(`abort`)\n        this.httpLoader.abort();\n    }\n\n    /*\n     首先从缓存中寻找请求的seg，如果缓存中找不到则用http请求。\n     */\n    async load(context, config, callbacks) {\n        const { logger, scheduler } = this;\n        const frag = context.frag;\n        // console.warn('FRAG_LOAD: ' + context.url);\n        // console.warn(frag);\n        // console.warn(context);\n        if (!this.isHlsV0) {\n            // v1.x\n            frag.stats = this.stats;\n        }\n        // console.warn(`frag.duration: ${frag.duration}`);\n        // frag.loadByP2P = false;                //初始化flag\n        // frag.loadByHTTP = false;\n        // console.warn(frag.baseurl);\n\n        let segId = context.frag.segId;\n        if (!segId) {\n            let range;\n            if (context.rangeEnd) {\n                range = 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1);\n            }\n            segId = context.frag.segId = this.segmentId(String(frag.level), frag.sn, frag.url, range);\n        }\n\n        // 音频等非ts文件不使用P2P\n        // console.warn(frag)\n        if (!frag.url || isBlockType(frag.url, this.blockTypes)) {\n            logger.info(`HTTP load blockType ${frag.url}`);\n            context.frag.loadByHTTP = true;\n            return this.httpLoader.load(context, config, callbacks);\n        }\n\n        // 检查是否禁用SDK\n        if (this.forbidden) return;\n\n        config.maxRetry = 2;        // TODO 验证\n        const bufferedDuration = scheduler.getBufferedDuration();\n\n        // console.warn(`load segId ${segId} hasSegOfId ${this.bufMgr.hasSegOfId(segId)}`);\n        const seg = await this.bufMgr.getSegById(segId);\n        if (this.p2pEnabled && seg) {                                     //如果命中缓存\n        // if (false) {                                     //如果命中缓存\n            logger.info(`bufMgr found seg sn ${frag.sn} segId ${segId} level ${frag.level}`);\n            const targetBuffer = copyBuffer(seg.data);\n            // let arrayBuffer = new Uint8Array(targetBuffer).buffer;           // 将uint8array转为arraybuffer\n            let arrayBuffer = targetBuffer.buffer;           // 将uint8array转为arraybuffer\n            let response = { url : context.url, data : arrayBuffer };\n            updateLoadStats(this.stats, seg.size);\n            frag.loaded = seg.size;\n            frag.loadByP2P = true;\n            context.frag.fromPeerId = seg.fromPeerId;\n            // logger.debug(`bufMgr loaded ${frag.relurl} at ${frag.sn}`);\n            queueMicrotask(() => {                                                   //必须是异步回调\n                // sha1(response.data, hash => {\n                //     console.warn(`${segId} ${hash}`)\n                // })\n                if (!this.isHlsV0 && callbacks.onProgress) callbacks.onProgress(this.stats, context, response.data);\n                callbacks.onSuccess(response, this.stats, context);\n            })\n        }\n\n        else if (this.p2pEnabled && scheduler.hasAndSetTargetPeer(frag.sn, frag.level, bufferedDuration)) {  //如果在peers的bitmap中找到\n            // console.warn(`loadFragByP2p ${frag.sn}`)\n            this.loadFragByP2p(context, config, callbacks, segId);\n\n        }\n        else {\n            logger.info(`fragLoader load ${segId} at ${frag.sn} level ${frag.level} buffered ${bufferedDuration*1000}`);\n            if (this.isLive && scheduler.hasIdlePeers && bufferedDuration > MIN_TIME_FOR_LOAD && scheduler.shouldWaitForNextSeg()) {\n            // if (bufferedDuration > MIN_TIME_FOR_LOAD) {     // test\n                let waitFor = bufferedDuration - MIN_TIME_FOR_LOAD;\n                if (waitFor > MAX_TIME_FOR_WAIT) waitFor = MAX_TIME_FOR_WAIT;\n                const onPeerHave = segIdHave => {\n                    // console.warn(`SCH_DCHAVE ${segIdHave}`);\n                    if (segIdHave === segId) {\n                        scheduler.off(Events.SCH_DCHAVE, onPeerHave);    // 防止重复触发\n                        clearTimeout(this.waitTimer);\n                        if (scheduler.hasAndSetTargetPeer(frag.sn, frag.level, bufferedDuration)) {\n                            this.loadFragByP2p(context, config, callbacks, segId);\n                        } else {\n                            this.loadFragByHttp(context, config, callbacks, segId);\n                        }\n                    }\n                };\n                logger.info(`wait peer have for ${waitFor}s`);\n                scheduler.on(Events.SCH_DCHAVE, onPeerHave);\n                this.waitTimer = setTimeout(() => {\n                    this.loadFragByHttp(context, config, callbacks, segId);\n                    scheduler.off(Events.SCH_DCHAVE, onPeerHave);\n                }, waitFor*1000);\n            } else {\n                this.loadFragByHttp(context, config, callbacks, segId);\n            }\n\n            // httpLoader timeout 20s\n        }\n    }\n\n    loadFragByHttp(context, config, callbacks, segId) {\n        const { logger, scheduler } = this;\n        const { segmentBuilderMap } = scheduler;\n        scheduler.isReceiver = false;\n        const frag = context.frag;\n        const { sn, level } = frag;\n        if (this.streamEnabled) {\n            scheduler.notifyAllPeers(sn, level, segId, SegmentState.PARTIAL_FORWARD);\n            let segmentBuilder;\n            callbacks.onUpdate = (buffer, done, aborted) => {\n                if (aborted) {\n                    segmentBuilderMap.delete(sn, level);\n                    return\n                }\n                if (segmentBuilder) segmentBuilder.receiveBytes(buffer, done);\n                // console.warn(`onUpdate segId ${segId} size ${buffer.byteLength} done ${done}`)\n            }\n            callbacks.onBodyStart = (total) => {\n                // console.warn(`onBodyStart ${total}`)\n                if (!segmentBuilder) {\n                    // scheduler.notifyAllPeers(sn, level, segId, SegmentState.PARTIAL_FORWARD);\n                    segmentBuilder = new SegmentBuilder(sn, level, segId, total);\n                    if (!segmentBuilderMap.has(sn, level)) {\n                        segmentBuilderMap.set(sn, level, segmentBuilder);\n                    }\n                }\n            }\n        }\n\n        if (this.isHlsV0) {\n            const onSuccess = callbacks.onSuccess;\n            callbacks.onSuccess = async (response, stats, context) => {                       //在onsucess回调中复制并缓存二进制数据\n                if (!await this.bufMgr.hasSegOfId(segId)) {\n                    // console.warn(`byteLength ${response.data.byteLength}`)\n                    // console.warn(response)\n                    const targetBuffer = copyBuffer(response.data).buffer;\n                    const segment = new Segment(sn, segId, targetBuffer, this.fetcher.peerId, level);\n                    this.bufMgr.putSeg(segment);\n\n                    // test  wait/notify\n                    // setTimeout(() => {\n                    //     this.bufMgr.putSeg(segment);\n                    // }, 3000)\n                }\n                segmentBuilderMap.delete(sn, level);\n                // console.warn(`stats.retry ${stats.retry} config.maxRetry ${config.maxRetry} config.retryDelay ${config.retryDelay}`);\n                this.fetcher.reportFlow(stats.total);\n                // console.warn(`this.isHlsV0 ${this.isHlsV0}`)\n                let tTotal = stats.tload - stats.trequest;\n                logger.info(`HTTP loaded ${segId} time ${tTotal}`);\n                scheduler.notifyAllPeers(sn, level, segId);\n                // sha1(response.data, hash => {\n                //     console.warn(`${segId} ${hash}`)\n                // })\n\n                onSuccess(response, stats, context);\n            };\n\n            // const onProgress = callbacks.onProgress;\n            // callbacks.onProgress = (stats, context, data) => {\n            //     // console.warn(`onProgress ${context.url} ${stats.loaded}`)\n            //     // 接收到一部分数据再发送have\n            //     scheduler.notifyAllPeers(sn, level, segId, SegmentState.PARTIAL_FORWARD);\n            //     callbacks.onProgress = onProgress;\n            //     onProgress(stats, context, data);\n            // };\n        } else if (callbacks.onProgress) {     // hls.js v1\n            //  用onProgress代替onSuccess  解决 Cannot perform Construct on a detached ArrayBuffer\n            const onProgress = callbacks.onProgress;\n            callbacks.onProgress = async (stats, context, data) => {\n                // console.warn(`onProgress ${context.url} ${stats.loaded}`)\n                scheduler.notifyAllPeers(sn, level, segId);\n                if (!await this.bufMgr.hasSegOfId(segId)) {\n                    // console.warn(`byteLength ${data.byteLength}`);\n                    const targetBuffer = copyBuffer(data).buffer;\n                    const segment = new Segment(sn, segId, targetBuffer, this.fetcher.peerId, level);\n                    this.bufMgr.putSeg(segment);\n                }\n                segmentBuilderMap.delete(sn, level);\n                // console.warn(`stats.retry ${stats.retry} config.maxRetry ${config.maxRetry} config.retryDelay ${config.retryDelay}`);\n                this.fetcher.reportFlow(stats.total);\n                frag.loaded = stats.total;\n                // console.warn(`this.isHlsV0 ${this.isHlsV0}`)\n                let tTotal = stats.loading.end - stats.loading.start;\n                logger.info(`HTTP loaded ${segId} time ${tTotal}`);\n                onProgress(stats, context, data);\n            };\n        }\n        context.frag.loadByHTTP = true;\n        this.httpLoader.load(context, config, callbacks);\n    }\n\n    loadFragByP2p(context, config, callbacks, segId) {\n        const { logger } = this;\n        const frag = context.frag;\n        this.scheduler.load(context, config, callbacks);\n        const onSuccess = callbacks.onSuccess;\n        const onTimeout = callbacks.onTimeout;\n        callbacks.onTimeout = (stats, context) => {                             //如果P2P下载超时则立即切换到xhr下载\n            logger.warn(`P2P timeout switched to HTTP load ${frag.relurl} at ${frag.sn}`);\n            // frag.loadByP2P = false;\n            // frag.loadByHTTP = true;\n\n            callbacks.onSuccess = onSuccess;\n            this.loadFragByHttp(context, config, callbacks, segId);\n\n            callbacks.onTimeout = onTimeout;\n        };\n        callbacks.onSuccess = async (response, stats, context) => {                       //在onsucess回调中复制并缓存二进制数据\n            // callbacks.onSuccess = () => {\n            //     logger.warn(`p2p loaded ${frag.sn}, http ignore`);\n            // };\n            if (!await this.bufMgr.hasSegOfId(segId)) {\n                const targetBuffer = copyBuffer(response.data).buffer;\n                const segment = new Segment(frag.sn, segId, targetBuffer, frag.fromPeerId || this.fetcher.peerId, frag.level);\n                this.bufMgr.putSeg(segment);\n            }\n            if (!frag.loadByP2P) this.fetcher.reportFlow(stats.total);\n            frag.loaded = stats.loaded;\n            logger.info(`${frag.loadByP2P ? 'P2P' : 'HTTP'} loaded segment id ${segId}`);\n            // v1必须\n            if (!this.isHlsV0 && callbacks.onProgress) callbacks.onProgress(stats, context, response.data);\n\n            // console.warn('p2p onSuccess: ' + frag.sn);\n            // console.warn(JSON.stringify(stats, null, 2));\n            // console.warn(response);\n            // console.warn(context);\n\n            onSuccess(response, stats, context);\n        };\n    }\n}\n\nexport default FragLoader;\n","import EventEmitter from 'events'\nimport queueMicrotask from '../../core/utils/queue-microtask'\nimport { createLoadStats, updateLoadStats } from './utils/tool-funs'\n\nclass PlaylistLoader extends EventEmitter {\n    constructor(config) {\n        super();\n\n        this.logger = config.logger;\n\n        const {scheduler} =  window.__p2p_loader__;\n        this.isHlsV0 = config.isHlsV0;\n        this.xhrLoader = new config.loader(config);\n        this.p2pEnabled = config.p2pEnabled;\n        this.scheduler = scheduler;\n        this.stats = this.xhrLoader.stats || createLoadStats();\n    }\n\n    destroy() {\n        this.xhrLoader.destroy();\n    }\n\n    abort() {\n        // console.warn(`abort`)\n        this.xhrLoader.abort();\n    }\n\n    /*\n     首先从peers中寻找请求的m3u8，如果找不到则用http请求。\n     */\n    load(context, config, callbacks) {\n        const { logger } = this;\n        // console.warn('load playlist: ' + context.url);\n        // console.warn(\"context\");\n        // console.warn(context);\n\n        const { url } = context;\n\n        // console.warn(`url: ${url}`);\n        const netUrl = url.split('?')[0];\n        const onSuccess = callbacks.onSuccess;\n        callbacks.onSuccess = (response, stats, context) => {\n            // console.warn(`response size ${response.data.length}`);\n            // console.warn(JSON.stringify(response.data));\n            this.scheduler.broadcastPlaylist(netUrl, response.data);\n            onSuccess(response, stats, context);\n        };\n        if (this.scheduler.playlistInfo.has(netUrl)) {\n            const playlist = this.scheduler.getPlaylistFromPeer(netUrl);\n            if (playlist && playlist.data) {\n                const { data, seq } = playlist;\n                // console.warn(`got playlist from peer ${data}`);\n                logger.info(`got playlist from peer seq ${seq}`);\n                updateLoadStats(this.stats, data.length);\n                let response = { url, data };\n                queueMicrotask(() => {                                                   //必须是异步回调\n                    callbacks.onSuccess(response, this.stats, context);\n                });\n                return\n            }\n        }\n\n        this.xhrLoader.load(context, config, callbacks);\n\n    }\n\n}\n\nexport default PlaylistLoader;\n","import Events from '.././events'\nimport Segment from '../../core/segment'\nimport { createLoadStats } from './utils/tool-funs'\nimport queueMicrotask from '../../core/utils/queue-microtask'\nimport Scheduler from \"../common/scheduler\"\nimport Synthesizer from \"../common/synthesizer\"\n\nclass HlsjsScheduler extends Scheduler {\n\n    constructor(engine, config) {\n        super(engine, config);\n        this.isHlsjs = true;\n    }\n\n    updatePlaySN(sn) {\n        // const { logger } = this;\n        // logger.info(`updatePlaySN ${sn}`);\n        this.currPlaySN = sn;\n    }\n\n    load(context, config, callbacks) {\n        this.isReceiver = true;\n        const { logger, config: p2pConfig } = this;\n        this.context = context;\n        const { rangeStart, rangeEnd, url } = context;\n        const frag = context.frag;\n        const { segId, sn, level } = frag;\n        this.callbacks = callbacks;\n        this.stats = createLoadStats();\n        this.criticalSeg = { sn, level, segId };\n        let loadTimeout = this.mBufferedDuration - p2pConfig.httpLoadTime;   // second\n        if (loadTimeout > this.dcDownloadTimeout) {\n            loadTimeout = this.dcDownloadTimeout;\n        }\n        const {forwardPeer, reversePeer} = this.targetPeers;\n        if (!forwardPeer && !reversePeer) {\n            loadTimeout -= 1.0\n        }\n        let synthesizer = this.requestingMap.get(sn, level);\n        const ext = {\n            rangeStart: Number(rangeStart),\n            rangeEnd: Number(rangeEnd),\n            url,\n            httpLoadTime: p2pConfig.httpLoadTime*1000 - 500,\n            xhrSetup: p2pConfig.xhrSetup,\n        }\n        if (!synthesizer) {\n            synthesizer = new Synthesizer(this.logger, sn, level, p2pConfig.httpRangeSupported, ext);\n            this._setupSynthesizer(synthesizer);\n            this.requestingMap.set(sn, level, synthesizer);\n        } else {\n            synthesizer.setExtra(ext);\n        }\n        synthesizer.setTimeout(loadTimeout * 1000);\n        // console.warn(`setTimeout ${loadTimeout}`)\n        if (forwardPeer) {\n            synthesizer.setForwardPeer(forwardPeer);\n            forwardPeer.requestDataById(segId, sn, true, { level });\n        }\n        if (reversePeer) {\n            synthesizer.setReversePeer(reversePeer);\n            reversePeer.requestDataById(segId, sn, true, { level, reverse: true });\n        }\n        this.targetPeers = {};    // 重置\n        // console.warn(`!test ${JSON.stringify(this.criticalSeg)}`);\n    }\n\n    // override\n    destroy() {\n        super.destroy();\n        this.logger.warn(`destroy HlsjsScheduler`);\n    }\n\n    // override\n    _setupDC(dc) {\n        // console.warn(`sn scheduler _setupDC`);\n        super._setupDC(dc);\n    }\n\n    _setupSynthesizer(synthesizer) {\n        synthesizer.on(Events.SYN_OUTPUT, (segment, info) => {\n            // console.warn(`p2p ${info.p2p} http ${info.http}`)\n            const { config, logger } = this;\n            const { segId, sn, data, level } = segment;\n            const { speed } = info;\n            const isCritical = this.criticalSeg && this.criticalSeg.segId === segId;\n            const verified = config.validateSegment(segId, new Uint8Array(data));    // 对数据进行校验，防止节点作恶\n            if (verified) {\n                this.notifyAllPeers(sn, level, segId);\n                if (!this.bitset.has(sn, level)) {\n                    // 上报流量\n                    this.reportTraffic(info.http, info.p2p, speed)\n                }\n                const fromPeerId = synthesizer.getFromPeerId();\n                if (isCritical) {\n                    logger.info(`receive criticalSeg seg_id ${segId}`);\n                    let stats = this.stats;\n                    stats.tfirst = stats.loading.first = Math.max(stats.trequest, performance.now());\n                    stats.tload = stats.loading.end = stats.tfirst;\n                    stats.loaded = stats.total = data.byteLength;\n                    this.criticalSeg = null;\n                    const { frag } = this.context;\n                    frag.fromPeerId = fromPeerId;\n                    frag.loadByP2P = true;\n                    this.callbacks.onSuccess({ data, url: this.context.url }, stats, this.context);\n                } else {\n                    // 判断是否已经存储过了\n                    if (this.bitset.has(sn, level)) return;\n                    const segment = new Segment(sn, segId, data, fromPeerId, level);\n                    this.bufMgr.putSeg(segment);\n                    this.updateLoaded(sn, level);                                // 只有预加载请求需要\n                }\n            } else {\n                logger.error(`segment ${segId} validate failed`);\n                if (isCritical) {\n                    this.callbacks.onTimeout(this.stats, this.context, null);\n                }\n            }\n            this.requestingMap.delete(sn, level);\n            if (config.live && !this.criticalSeg) this.checkPeers();\n        })\n            .on(Events.SYN_ERROR, (pieceMsg) => {\n                const { sn, level } = pieceMsg;\n                this.logger.warn(`SYN_ERROR loading ${sn}`);\n                if (this.criticalSeg && this.criticalSeg.sn === sn) {             //接收到critical未找到的响应\n                    this.criticalSeg = null;                                           //触发超时，由xhr下载\n                    this.callbacks.onTimeout(this.stats, this.context, null);\n                }\n                this.requestingMap.delete(sn, level);\n            })\n    }\n\n    _setupEngine(){\n        super._setupEngine();\n        this.engine.on(Events.FRAG_LOADING, ({sn, segId, byHttp, level}) => {\n            this.loadingSN = sn;\n            this.loadingSegId = segId;\n        })\n            .on(Events.FRAG_LOADED, ({sn, segId, byP2p, level}) => {\n                // console.warn(`sch FRAG_LOADED ${sn} byHttp ${byHttp}`)\n                this.requestingMap.delete(sn, level);\n                this.updateLoaded(sn, level);\n            })\n            .on(Events.FRAG_CHANGED, ({sn}) => {\n                this.updatePlaySN(sn);\n            })\n    }\n\n    _handleDCHave(peer, sn, level, state) {\n        if (this.criticalSeg && this.criticalSeg.sn === sn && this.criticalSeg.level === level) {\n            this._notifySynthesizer(peer, this.criticalSeg.segId, sn, level, state);\n        }\n        // else if (sn === this.loadingSN + 1) {\n        //     this._notifySynthesizer(peer, null, sn, level, state, false);\n        // }\n        if (this.config.live && !this.criticalSeg) {\n            queueMicrotask(() => {                                                   //必须是异步回调\n                this.checkPeers();\n            })\n        }\n    }\n}\n\nexport default HlsjsScheduler\n","import EventEmitter from 'events'\n\nexport default class FakeXhr extends EventEmitter {\n\n    constructor() {\n        super();\n\n        this.UNSENT = 0;\n        this.OPENED = 1;\n        this.HEADERS_RECEIVED = 2;\n        this.LOADING = 3;\n        this.DONE = 4;\n\n        this.timeout = 0;\n        this.withCredentials = false;\n        this.status = 0;\n        this.readyState = this.UNSENT;\n        this.headers = new Map();\n        this.responseHeaders = null;\n        this.on('load', (e)  => {\n            if (this.onload) this.onload(e)\n        })\n        this.on('abort', (e)  => {\n            if (this.onabort) this.onabort(e)\n        })\n        this.on('error', (e)  => {\n            if (this.onerror) this.onerror(e)\n        })\n        this.on('loadstart', (e)  => {\n            if (this.onloadstart) this.onloadstart(e)\n        })\n        this.on('progress', (e)  => {\n            if (this.onprogress) this.onprogress(e)\n        })\n        this.on('timeout', (e)  => {\n            if (this.ontimeout) this.ontimeout(e)\n        })\n        this.on('loadend', (e)  => {\n            if (this.onloadend) this.onloadend(e)\n        })\n        this.on('readystatechange', () => {\n            if (this.onreadystatechange) this.onreadystatechange()\n        })\n    }\n\n    setRequestHeader(name, value) {\n        this.headers.set(name, value)\n    }\n\n    addEventListener(type, listener) {\n        this.addListener(type, listener)\n    }\n\n    removeEventListener(type, listener) {\n        this.removeListener(type, listener)\n    }\n\n    overrideMimeType() {}\n    getAllResponseHeaders() {\n        if (!this.responseHeaders) return null\n        let ret = '';\n        this.responseHeaders.forEach((value, key)  => {\n            ret += `${key}: ${value}\n`\n        });\n        return ret\n    }\n    getResponseHeader(key) {\n        if (!this.responseHeaders) return null\n        return this.responseHeaders.get(key)\n    }\n    open() {\n        this.readyState = this.OPENED;\n        this.emit('loadstart')\n    }\n    abort() {\n        this.readyState = this.DONE;\n        this.status = 0;\n    }\n    send() {}\n\n    _emitEvent(type) {\n        this.emit(type, new ProgressEvent(type));\n    }\n}\n","import { createLoadStats } from './tool-funs'\nimport { Buffer } from '../../../core/utils/buffer'\nimport Peer from \"../../../core/peer\"\nimport FakeXhr from \"./fake-xhr\"\nimport { splitBytes } from '../../../core/utils/tool-funs'\n\nexport function fetchSupported() {\n    if (\n        window.fetch &&\n        window.AbortController &&\n        window.ReadableStream &&\n        window.Request\n    ) {\n        try {\n            new window.ReadableStream({});\n            return true;\n        } catch (e) {\n            /* noop */\n        }\n    }\n    return false;\n}\n\nexport class FetchLoader {\n    constructor(config /* HlsConfig */) {\n        // console.warn(`using FetchLoader`)\n        this.fetchSetup = config.fetchSetup || getRequest;\n        this.xhrSetup = config.xhrSetup;\n        this.controller = new window.AbortController();\n        this.stats = createLoadStats();\n        this.packetSize = Peer.defaultPacketSize;\n        this.fakeXhr = new FakeXhr();\n    }\n\n    destroy() {\n        this.loader = this.callbacks = null;\n        this.abortInternal();\n    }\n\n    abortInternal() {\n        // console.warn(`abort`)\n        const response = this.response;\n        if (!response || !response.ok) {\n            this.stats.aborted = true;\n            if (this.callbacks && this.callbacks.onUpdate) this.callbacks.onUpdate(undefined, false, true);\n            this.controller.abort();\n        }\n    }\n\n    abort() {\n        this.abortInternal();\n        if (this.callbacks && this.callbacks.onAbort) {\n            this.callbacks.onAbort(this.stats, this.context, this.response);\n        }\n    }\n\n    load(\n        context,\n        config,\n        callbacks\n    ) {\n        const stats = this.stats;\n        // if (stats.loading.start) {\n        //     throw new Error('Loader can only be used once.');\n        // }\n        stats.trequest = stats.loading.start = performance.now();\n\n        let initParams = getRequestParameters(context, this.controller.signal);\n        const isArrayBuffer = context.responseType === 'arraybuffer';\n        const LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n        const onUpdate = callbacks.onUpdate;\n        const onBodyStart = callbacks.onBodyStart;\n        this.context = context;\n        this.config = config;\n        this.callbacks = callbacks;\n        // 合并 fake xhr\n        if (this.xhrSetup) {\n            this.xhrSetup(this.fakeXhr, context.url)\n            initParams = mergeXhrSetup(this.fakeXhr, initParams);\n        }\n        this.request = this.fetchSetup(context, initParams);\n        clearTimeout(this.requestTimeout);\n        this.requestTimeout = setTimeout(() => {\n            this.abortInternal();\n            this.fakeXhr._emitEvent('timeout');\n            this.fakeXhr._emitEvent('loadend');\n            callbacks.onTimeout(stats, context, this.response);\n        }, this.fakeXhr.timeout || config.timeout);\n\n        const { fakeXhr } = this;\n        fakeXhr.readyState = fakeXhr.OPENED\n        fakeXhr.emit('readystatechange');\n        fakeXhr._emitEvent('loadstart');\n        fetch(this.request)\n            .then((response) => {\n            this.response = this.loader = response;\n\n            if (!response.ok) {\n                const { status, statusText } = response;\n                if (onUpdate) onUpdate(undefined, false, true);\n                throw new FetchError(\n                    statusText || 'fetch, bad network response',\n                    status,\n                    response\n                );\n            }\n            stats.tfirst = stats.loading.first = Math.max(performance.now(), stats.loading.start);\n            stats.total = parseInt(response.headers.get('Content-Length') || '0');\n\n            const { fakeXhr } = this;\n            fakeXhr.readyState = fakeXhr.HEADERS_RECEIVED;\n            fakeXhr.responseHeaders = response.headers;\n            fakeXhr.emit('readystatechange');\n\n            if (onUpdate && stats.total !== '0') {\n\n                if (onBodyStart) onBodyStart(stats.total);\n\n                return this.loadProgressively(\n                    response,\n                    stats,\n                    context,\n                    onUpdate,\n                );\n            } else {\n                fakeXhr.emit('progress', new ProgressEvent('progress', { lengthComputable: false }));\n            }\n\n            if (isArrayBuffer) {\n                return response.arrayBuffer();\n            }\n            return response.text();\n        })\n    .then((responseData) => {\n            const { response } = this;\n            clearTimeout(this.requestTimeout);\n            stats.tload = stats.loading.end = Math.max(\n                performance.now(),\n                stats.loading.first\n            );\n            stats.loaded = stats.total = responseData[LENGTH];\n\n            const loaderResponse = {\n                url: response.url,\n                data: responseData,\n            };\n\n            callbacks.onProgress(stats, context, responseData, response);\n            callbacks.onSuccess(loaderResponse, stats, context, response);\n\n        })\n            .catch((error) => {\n                clearTimeout(this.requestTimeout);\n                if (stats.aborted) {\n                    return;\n                }\n                if (onUpdate) onUpdate(undefined, false, true);\n                // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n                // when destroying, 'error' itself can be undefined\n                const code = !error ? 0 : error.code || 0;\n                const text = !error ? null : error.message;\n                callbacks.onError(\n                    { code, text },\n                    context,\n                    error ? error.details : null\n                );\n            });\n    }\n\n    loadProgressively(\n        response,\n        stats,\n        context,\n        onUpdate\n    ) {\n        const reader = response.body.getReader();\n        let bytesReadIncrement = 0;\n        let sentCount = 0;\n        let sink = Buffer(0);\n\n        const pump = () => {\n            return reader\n                .read()\n                .then(({ value, done }) => {\n                    // console.warn(value.length)\n\n                    const { fakeXhr } = this;\n                    if (fakeXhr.readyState !== fakeXhr.LOADING) {\n                        fakeXhr.readyState = fakeXhr.LOADING\n                        fakeXhr.emit('readystatechange');\n                    }\n\n                    if (value) {\n                        bytesReadIncrement += value.length;\n                    }\n                    if (done) {\n                        if (sink.byteLength > 0) {\n                            if (bytesReadIncrement <= this.packetSize) {\n                                const buffer = Buffer(bytesReadIncrement);\n                                sink.copy(buffer, 0, sentCount*this.packetSize, sink.byteLength)\n                                onUpdate(buffer, true);\n                            } else {\n                                const bufferList = splitBytes(sink, sentCount*this.packetSize);\n                                for (let i=0; i<bufferList.length; i++) {\n                                    onUpdate(bufferList[i], i === bufferList.length-1);\n                                }\n                            }\n                        }\n                        // const buffer = new Uint8Array(sink).buffer;\n                        const buffer = sink.buffer;\n                        // console.warn(`loadProgressively resolve data ${buffer.byteLength}`)\n                        const { fakeXhr } = this;\n                        const { status, statusText, url } = response\n                        fakeXhr.readyState = fakeXhr.DONE\n                        fakeXhr.responseText = status;\n                        fakeXhr.status = statusText;\n                        fakeXhr.responseURL = url;\n                        fakeXhr.responseType = 'arraybuffer';\n                        fakeXhr.response = buffer;\n                        fakeXhr.emit('readystatechange');\n                        fakeXhr._emitEvent('load');\n                        fakeXhr._emitEvent('loadend');\n\n                        return Promise.resolve(buffer);\n                    }\n                    const chunk = Buffer.from(value);\n                    // const len = chunk.byteLength;\n                    stats.loaded += value.length;\n                    fakeXhr.emit('progress', new ProgressEvent('progress', {\n                        lengthComputable: true,\n                        loaded: stats.loaded,\n                        total: stats.total,\n                    }));\n                    // console.warn(`pump len ${value.length} chunk byteLength ${chunk.byteLength}`);\n                    sink = Buffer.concat([sink, chunk])\n                    if (bytesReadIncrement >= this.packetSize) {\n                        bytesReadIncrement -= this.packetSize;\n                        // arraybuffer\n                        const buffer = Buffer(this.packetSize);\n                        sink.copy(buffer, 0, sentCount * this.packetSize, (sentCount + 1) * this.packetSize)\n                        sentCount ++;\n                        onUpdate(buffer, false);\n                    }\n                    return pump();\n                })\n                .catch(() => {\n                    /* aborted */\n                    this.fakeXhr._emitEvent('abort');\n                    this.fakeXhr._emitEvent('loadend');\n                    return Promise.reject();\n                });\n        };\n\n        return pump();\n    }\n}\n\nfunction getRequestParameters(context, signal) {\n    const initParams = {\n        method: 'GET',\n        mode: 'cors',\n        credentials: 'same-origin',\n        signal,\n        headers: new window.Headers(Object.assign({}, context.headers)),\n    };\n\n    if (context.rangeEnd) {\n        initParams.headers.set(\n            'Range',\n            'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1)\n        );\n    }\n\n    return initParams;\n}\n\nfunction getRequest(context, initParams) {\n    return new window.Request(context.url, initParams);\n}\n\nfunction mergeXhrSetup(xhr, initParams) {\n    if (xhr.withCredentials) {\n        initParams.credentials = 'include';\n    }\n    for (let [key, value] of xhr.headers) {\n        initParams.headers.set(key, value)\n    }\n    return initParams\n}\n\nclass FetchError extends Error {\n    constructor(message, code, details) {\n        super(message);\n        this.code = code;\n        this.details = details;\n    }\n}\n","import Peer from \"../../../core/peer\"\nimport Events from \"../../../core/events\"\n\nexport default class SegmentBuilder {\n\n    constructor(sn, level, segId, dataSize) {\n        this.bufferList = [];           // 正向的\n        this.streamListeners = [];\n        this.finished = false;\n        this.packetSize = Peer.defaultPacketSize;\n        this.attachments = dataSize % this.packetSize === 0 ? dataSize / this.packetSize : Math.floor(dataSize / this.packetSize) + 1;\n        this.pieceMsg = {\n            event: Events.DC_PIECE,\n            attachments: this.attachments,\n            seg_id: segId,\n            sn,\n            level,\n            size: dataSize,\n            reverse: false,\n        }\n    }\n\n    receiveBytes(buffer, done) {\n        if (!buffer.byteLength) return\n        this.bufferList.push(buffer);\n        if (done) this.finished = true;\n        this._notifyStreamListeners(buffer);\n    }\n\n    destroy() {\n        if (this.finished) return\n        this._notifyStreamListenersAbort();\n    }\n\n    addStreamListener(reverse, handler) {\n        this.streamListeners.push({ handler });\n    }\n\n    _notifyStreamListenersAbort() {\n        const { sn, seg_id } = this.pieceMsg;\n        for (let item of this.streamListeners) {\n            const { handler } = item;\n            handler(sn, seg_id, true, 'aborted by httpLoader');\n        }\n        this.streamListeners.length = 0;\n    }\n\n    _notifyStreamListeners(data) {\n        const { sn, seg_id } = this.pieceMsg;\n        for (let item of this.streamListeners) {\n            const { handler } = item;\n            // console.warn(`_notifyStreamListeners sn ${sn} length ${data.byteLength} finished ${this.finished}`);\n            handler(sn, seg_id, false, data, this.finished);\n        }\n        if (this.finished) {\n            // console.warn(`_notifyStreamListeners finished`)\n            this.streamListeners.length = 0;\n        }\n    }\n}\n","import URLToolkit from 'url-toolkit'\n\nexport function isBlockType(url, blackList) {\n    const urlObj = URLToolkit.parseURL(url);\n    const mediaType = urlObj.path.substring(urlObj.path.lastIndexOf('.')+1);\n    // console.warn(`mediaType ${mediaType}`);\n    // const extname = path.extname(url).toLowerCase();\n    return blackList.indexOf(mediaType) !== -1;\n\n}\n\nexport function createLoadStats() {\n    const now = performance.now();\n    return {\n        // compat with HLS < 1.0.0\n        trequest: now,\n        tfirst: 0,\n        tload: 0,\n\n        aborted: false,\n        loaded: 0,\n        retry: 0,\n        total: 0,\n        chunkCount: 0,\n        bwEstimate: 0,\n        loading: { start: now, first: 0, end: 0 },\n        parsing: { start: 0, end: 0 },\n        buffering: { start: 0, first: 0, end: 0 }\n    }\n}\n\nexport function updateLoadStats(stats, size) {\n    let trequest, tfirst, tload, loaded, total;\n    const now = performance.now();\n    trequest = now - 300;\n    tfirst = now - 200;\n    tload = now;\n    stats.trequest = trequest;\n    stats.tfirst = tfirst;\n    stats.tload = tload;\n    stats.loading = {\n        first: trequest,\n        start: tfirst,\n        end: tload\n    };\n    loaded = total = size;\n    stats.loaded = loaded;\n    stats.total = total;\n}\n","import Engine from \"./common/engine\"\n\nclass ShadowP2pEngine extends Engine {\n    static get name() {\n        return 'ShadowP2pEngine'\n    }\n    constructor() {\n        super();\n    }\n\n    get currentLevel() {\n        return 0\n    }\n\n    disableP2P() {\n    }\n\n}\n\nexport default ShadowP2pEngine\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Events from './events'\nimport EngineBase from \"../core/engine-base\"\nimport HlsSwP2pEngine from \"./hls-sw.p2pengine\"\nimport HlsjsP2pEngine from \"./hlsjs.p2pengine\"\nimport Peer from \"../core/peer\"\nimport { isMSESupported } from '../core/utils/mse'\nimport platform from \"../core/utils/platform\"\nimport ShadowP2pEngine from \"./shadow.p2pengine\"\nimport { getQueryParam } from \"../core/utils/tool-funs\"\nimport TsValidator from \"../common/hls/ts-validator\"\n\nclass P2pEngine {\n\n    static get Events() {\n        return Events;\n    }\n\n    static isSupported() {\n        return EngineBase.isSupported() && (isMSESupported() || HlsSwP2pEngine.isServiceWorkerSupported())\n    }\n\n    static isServiceWorkerSupported() {\n        return HlsSwP2pEngine.isServiceWorkerSupported()\n    }\n\n    static isMSESupported() {\n        return isMSESupported()\n    }\n\n    static getBrowser() {\n        return platform.getBrowser()\n    }\n\n    static get ServiceWorkerEngine() {\n        return HlsSwP2pEngine\n    }\n\n    static get HlsjsEngine() {\n        return HlsjsP2pEngine\n    }\n\n    constructor(p2pConfig = {}) {\n        const { hlsjsInstance } = p2pConfig;\n        delete p2pConfig.hlsjsInstance;\n\n        if (!p2pConfig.validateSegment) {\n            p2pConfig.validateSegment = function (segId, data) {\n                // console.warn(`validate ${segId}`)\n                return TsValidator.validate(data)\n            }\n        }\n\n        if (window.__swP2pEngineHlsActive) {\n            console.warn(`P2pEngineHls is already activated`);\n            this._realEngine = new ShadowP2pEngine(p2pConfig)\n            return\n        }\n        // 兼容\n        if (p2pConfig.videoElem) p2pConfig.mediaElem = p2pConfig.videoElem;\n        if (getQueryParam('_ios') === '1') {\n            this._realEngine = new HlsSwP2pEngine(p2pConfig)\n            return\n        }\n        if (!p2pConfig.proxyOnly && hlsjsInstance && isMSESupported()) {\n            this._realEngine = new HlsjsP2pEngine(hlsjsInstance, p2pConfig)\n        } else {\n            this._realEngine = new HlsSwP2pEngine(p2pConfig)\n        }\n    }\n\n    get realEngine() {\n        return this._realEngine\n    }\n\n    get engineName() {\n        return this._realEngine.constructor.name\n    }\n\n    once(name, handler) {\n        return this._realEngine.once(name, handler)\n    }\n\n    on(name, handler) {\n        return this._realEngine.on(name, handler)\n    }\n\n    off(name, handler) {\n        return this._realEngine.off(name, handler)\n    }\n\n    removeListener(name, handler) {\n        return this._realEngine.removeListener(name, handler)\n    }\n\n    removeAllListeners(name) {\n        return this._realEngine.removeAllListeners(name)\n    }\n\n    set p2pEnabled(bool) {\n        this._realEngine.p2pEnabled = bool\n    }\n\n    get p2pEnabled() {\n        return this._realEngine.p2pEnabled\n    }\n\n    enableP2P() {\n        this._realEngine.enableP2P()\n    }\n\n    disableP2P() {\n        this._realEngine.disableP2P()\n    }\n\n    destroy() {\n        this._realEngine.destroy()\n    }\n\n    registerServiceWorker() {\n        if (typeof this._realEngine['registerServiceWorker'] === 'function') {\n            return this._realEngine.registerServiceWorker()\n        }\n        return Promise.reject(\"Not supported by this engine\")\n    }\n\n    unregisterServiceWorker() {\n        if (typeof this._realEngine['unregisterServiceWorker'] === 'function') {\n            return this._realEngine.unregisterServiceWorker()\n        }\n        return Promise.reject(\"Not supported by this engine\")\n    }\n\n    get version() {\n        return EngineBase.version;\n    }\n\n}\n\nP2pEngine.version = EngineBase.version;\n\nP2pEngine.protocolVersion = Peer.VERSION;\n\nif (window) {\n    window.P2PEngineHls = P2pEngine;\n}\n\nexport default P2pEngine\n"],"names":[],"sourceRoot":""}